<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>burdock.sql.parser.SqlSmallParser API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>burdock.sql.parser.SqlSmallParser</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Generated from SqlSmall.g4 by ANTLR 4.8
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] &gt; 5:
        from typing import TextIO
else:
        from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write(&#34;\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\177&#34;)
        buf.write(&#34;\u0228\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7&#34;)
        buf.write(&#34;\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16&#34;)
        buf.write(&#34;\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23&#34;)
        buf.write(&#34;\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31&#34;)
        buf.write(&#34;\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36&#34;)
        buf.write(&#34;\4\37\t\37\4 \t \4!\t!\4\&#34;\t\&#34;\4#\t#\4$\t$\4%\t%\4&amp;\t&#34;)
        buf.write(&#34;&amp;\4\&#39;\t\&#39;\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4&#34;)
        buf.write(&#34;/\t/\4\60\t\60\4\61\t\61\3\2\3\2\3\2\7\2f\n\2\f\2\16\2&#34;)
        buf.write(&#34;i\13\2\3\2\5\2l\n\2\3\2\3\2\3\3\3\3\3\3\5\3s\n\3\3\3\5&#34;)
        buf.write(&#34;\3v\n\3\3\3\5\3y\n\3\3\3\5\3|\n\3\3\3\5\3\177\n\3\3\4&#34;)
        buf.write(&#34;\3\4\3\4\3\4\5\4\u0085\n\4\3\4\5\4\u0088\n\4\3\4\5\4\u008b&#34;)
        buf.write(&#34;\n\4\3\4\5\4\u008e\n\4\3\4\3\4\3\5\3\5\3\6\3\6\5\6\u0096&#34;)
        buf.write(&#34;\n\6\3\6\3\6\3\7\3\7\3\7\3\7\7\7\u009e\n\7\f\7\16\7\u00a1&#34;)
        buf.write(&#34;\13\7\3\b\3\b\3\b\3\t\3\t\3\t\3\t\3\t\7\t\u00ab\n\t\f&#34;)
        buf.write(&#34;\t\16\t\u00ae\13\t\3\n\3\n\3\n\3\13\3\13\3\13\3\13\3\13&#34;)
        buf.write(&#34;\7\13\u00b8\n\13\f\13\16\13\u00bb\13\13\3\f\3\f\3\f\3&#34;)
        buf.write(&#34;\r\3\r\3\r\3\16\3\16\3\16\3\16\5\16\u00c7\n\16\3\17\5&#34;)
        buf.write(&#34;\17\u00ca\n\17\3\17\3\17\3\17\5\17\u00cf\n\17\3\17\5\17&#34;)
        buf.write(&#34;\u00d2\n\17\3\17\3\17\3\17\5\17\u00d7\n\17\3\17\3\17\5&#34;)
        buf.write(&#34;\17\u00db\n\17\3\17\5\17\u00de\n\17\3\17\5\17\u00e1\n&#34;)
        buf.write(&#34;\17\3\20\3\20\3\20\3\20\3\20\3\20\3\20\7\20\u00ea\n\20&#34;)
        buf.write(&#34;\f\20\16\20\u00ed\13\20\3\20\3\20\5\20\u00f1\n\20\3\21&#34;)
        buf.write(&#34;\3\21\5\21\u00f5\n\21\3\22\3\22\3\22\5\22\u00fa\n\22\3&#34;)
        buf.write(&#34;\23\3\23\7\23\u00fe\n\23\f\23\16\23\u0101\13\23\3\24\3&#34;)
        buf.write(&#34;\24\3\24\5\24\u0106\n\24\3\24\3\24\3\24\5\24\u010b\n\24&#34;)
        buf.write(&#34;\3\24\3\24\3\24\3\24\3\24\5\24\u0112\n\24\5\24\u0114\n&#34;)
        buf.write(&#34;\24\3\25\3\25\5\25\u0118\n\25\3\25\6\25\u011b\n\25\r\25&#34;)
        buf.write(&#34;\16\25\u011c\3\25\3\25\5\25\u0121\n\25\3\25\3\25\3\26&#34;)
        buf.write(&#34;\3\26\3\26\5\26\u0128\n\26\3\27\3\27\3\27\7\27\u012d\n&#34;)
        buf.write(&#34;\27\f\27\16\27\u0130\13\27\3\30\3\30\3\30\5\30\u0135\n&#34;)
        buf.write(&#34;\30\3\30\3\30\3\30\3\31\3\31\3\31\3\31\3\31\3\31\3\31&#34;)
        buf.write(&#34;\3\31\3\31\3\31\3\31\3\31\5\31\u0146\n\31\3\31\3\31\3&#34;)
        buf.write(&#34;\31\3\31\3\31\3\31\3\31\3\31\3\31\3\31\3\31\3\31\3\31&#34;)
        buf.write(&#34;\3\31\3\31\7\31\u0157\n\31\f\31\16\31\u015a\13\31\3\32&#34;)
        buf.write(&#34;\3\32\3\32\3\32\3\32\5\32\u0161\n\32\3\33\3\33\3\33\3&#34;)
        buf.write(&#34;\33\3\33\5\33\u0168\n\33\3\34\3\34\3\34\3\34\3\34\3\34&#34;)
        buf.write(&#34;\3\34\3\34\3\34\3\34\3\34\3\34\3\34\3\34\5\34\u0178\n&#34;)
        buf.write(&#34;\34\3\34\3\34\3\34\3\34\3\34\3\34\7\34\u0180\n\34\f\34&#34;)
        buf.write(&#34;\16\34\u0183\13\34\3\35\5\35\u0186\n\35\3\35\3\35\3\35&#34;)
        buf.write(&#34;\3\35\3\35\3\35\5\35\u018e\n\35\3\35\3\35\3\35\3\35\3&#34;)
        buf.write(&#34;\35\7\35\u0195\n\35\f\35\16\35\u0198\13\35\3\35\3\35\3&#34;)
        buf.write(&#34;\35\3\35\5\35\u019e\n\35\3\35\5\35\u01a1\n\35\3\36\3\36&#34;)
        buf.write(&#34;\3\37\3\37\3 \3 \3 \3 \3 \3 \5 \u01ad\n \3 \3 \3 \3 \3&#34;)
        buf.write(&#34; \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \6&#34;)
        buf.write(&#34; \u01c5\n \r \16 \u01c6\3 \3 \5 \u01cb\n \3!\3!\3!\3!&#34;)
        buf.write(&#34;\3\&#34;\3\&#34;\3\&#34;\3\&#34;\3\&#34;\3#\3#\3#\3#\3#\3#\3#\3$\3$\3$\3$&#34;)
        buf.write(&#34;\3$\3$\3$\3%\3%\3&amp;\3&amp;\3\&#39;\3\&#39;\3(\3(\3)\3)\3)\3)\3)\5)&#34;)
        buf.write(&#34;\u01f1\n)\3)\5)\u01f4\n)\3)\3)\3*\3*\3*\5*\u01fb\n*\3&#34;)
        buf.write(&#34;+\3+\5+\u01ff\n+\3+\3+\3+\5+\u0204\n+\7+\u0206\n+\f+\16&#34;)
        buf.write(&#34;+\u0209\13+\3,\3,\3,\7,\u020e\n,\f,\16,\u0211\13,\3-\3&#34;)
        buf.write(&#34;-\3-\5-\u0216\n-\3.\3.\3/\3/\3\60\3\60\3\61\5\61\u021f&#34;)
        buf.write(&#34;\n\61\3\61\3\61\5\61\u0223\n\61\3\61\5\61\u0226\n\61\3&#34;)
        buf.write(&#34;\61\2\4\60\66\62\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36&#34;)
        buf.write(&#34; \&#34;$&amp;(*,.\60\62\64\668:&lt;&gt;@BDFHJLNPRTVXZ\\^`\2\f\4\2\16&#34;)
        buf.write(&#34;\16\35\35\5\2##88YY\3\2`g\4\2##YY\5\2\34\34FFII\b\2\21&#34;)
        buf.write(&#34;\21\31\31\64\65@ASU\\]\r\2\b\t\17\20\25\25\27\27\33\33&#34;)
        buf.write(&#34;\&#34;\&#34;$$\62\63MNQRVV\5\2\66\66BBDE\3\2uw\4\2uuww\2\u0253&#34;)
        buf.write(&#34;\2b\3\2\2\2\4o\3\2\2\2\6\u0080\3\2\2\2\b\u0091\3\2\2\2&#34;)
        buf.write(&#34;\n\u0093\3\2\2\2\f\u0099\3\2\2\2\16\u00a2\3\2\2\2\20\u00a5&#34;)
        buf.write(&#34;\3\2\2\2\22\u00af\3\2\2\2\24\u00b2\3\2\2\2\26\u00bc\3&#34;)
        buf.write(&#34;\2\2\2\30\u00bf\3\2\2\2\32\u00c2\3\2\2\2\34\u00e0\3\2&#34;)
        buf.write(&#34;\2\2\36\u00f0\3\2\2\2 \u00f2\3\2\2\2\&#34;\u00f9\3\2\2\2$&#34;)
        buf.write(&#34;\u00fb\3\2\2\2&amp;\u0113\3\2\2\2(\u0115\3\2\2\2*\u0124\3&#34;)
        buf.write(&#34;\2\2\2,\u0129\3\2\2\2.\u0131\3\2\2\2\60\u0145\3\2\2\2&#34;)
        buf.write(&#34;\62\u0160\3\2\2\2\64\u0167\3\2\2\2\66\u0177\3\2\2\28\u01a0&#34;)
        buf.write(&#34;\3\2\2\2:\u01a2\3\2\2\2&lt;\u01a4\3\2\2\2&gt;\u01ca\3\2\2\2&#34;)
        buf.write(&#34;@\u01cc\3\2\2\2B\u01d0\3\2\2\2D\u01d5\3\2\2\2F\u01dc\3&#34;)
        buf.write(&#34;\2\2\2H\u01e3\3\2\2\2J\u01e5\3\2\2\2L\u01e7\3\2\2\2N\u01e9&#34;)
        buf.write(&#34;\3\2\2\2P\u01eb\3\2\2\2R\u01f7\3\2\2\2T\u01fe\3\2\2\2&#34;)
        buf.write(&#34;V\u020a\3\2\2\2X\u0212\3\2\2\2Z\u0217\3\2\2\2\\\u0219&#34;)
        buf.write(&#34;\3\2\2\2^\u021b\3\2\2\2`\u0225\3\2\2\2bg\5\4\3\2cd\7\3&#34;)
        buf.write(&#34;\2\2df\5\4\3\2ec\3\2\2\2fi\3\2\2\2ge\3\2\2\2gh\3\2\2\2&#34;)
        buf.write(&#34;hk\3\2\2\2ig\3\2\2\2jl\7\3\2\2kj\3\2\2\2kl\3\2\2\2lm\3&#34;)
        buf.write(&#34;\2\2\2mn\7\2\2\3n\3\3\2\2\2op\5\n\6\2pr\5\f\7\2qs\5\16&#34;)
        buf.write(&#34;\b\2rq\3\2\2\2rs\3\2\2\2su\3\2\2\2tv\5\20\t\2ut\3\2\2&#34;)
        buf.write(&#34;\2uv\3\2\2\2vx\3\2\2\2wy\5\22\n\2xw\3\2\2\2xy\3\2\2\2&#34;)
        buf.write(&#34;y{\3\2\2\2z|\5\24\13\2{z\3\2\2\2{|\3\2\2\2|~\3\2\2\2}&#34;)
        buf.write(&#34;\177\5\26\f\2~}\3\2\2\2~\177\3\2\2\2\177\5\3\2\2\2\u0080&#34;)
        buf.write(&#34;\u0081\7\4\2\2\u0081\u0082\5\n\6\2\u0082\u0084\5\f\7\2&#34;)
        buf.write(&#34;\u0083\u0085\5\16\b\2\u0084\u0083\3\2\2\2\u0084\u0085&#34;)
        buf.write(&#34;\3\2\2\2\u0085\u0087\3\2\2\2\u0086\u0088\5\20\t\2\u0087&#34;)
        buf.write(&#34;\u0086\3\2\2\2\u0087\u0088\3\2\2\2\u0088\u008a\3\2\2\2&#34;)
        buf.write(&#34;\u0089\u008b\5\22\n\2\u008a\u0089\3\2\2\2\u008a\u008b&#34;)
        buf.write(&#34;\3\2\2\2\u008b\u008d\3\2\2\2\u008c\u008e\5\24\13\2\u008d&#34;)
        buf.write(&#34;\u008c\3\2\2\2\u008d\u008e\3\2\2\2\u008e\u008f\3\2\2\2&#34;)
        buf.write(&#34;\u008f\u0090\7\5\2\2\u0090\7\3\2\2\2\u0091\u0092\5\6\4&#34;)
        buf.write(&#34;\2\u0092\t\3\2\2\2\u0093\u0095\7K\2\2\u0094\u0096\5\&#34;&#34;)
        buf.write(&#34;\22\2\u0095\u0094\3\2\2\2\u0095\u0096\3\2\2\2\u0096\u0097&#34;)
        buf.write(&#34;\3\2\2\2\u0097\u0098\5,\27\2\u0098\13\3\2\2\2\u0099\u009a&#34;)
        buf.write(&#34;\7%\2\2\u009a\u009f\5$\23\2\u009b\u009c\7\6\2\2\u009c&#34;)
        buf.write(&#34;\u009e\5$\23\2\u009d\u009b\3\2\2\2\u009e\u00a1\3\2\2\2&#34;)
        buf.write(&#34;\u009f\u009d\3\2\2\2\u009f\u00a0\3\2\2\2\u00a0\r\3\2\2&#34;)
        buf.write(&#34;\2\u00a1\u009f\3\2\2\2\u00a2\u00a3\7_\2\2\u00a3\u00a4&#34;)
        buf.write(&#34;\5\66\34\2\u00a4\17\3\2\2\2\u00a5\u00a6\7\&#39;\2\2\u00a6&#34;)
        buf.write(&#34;\u00a7\7\23\2\2\u00a7\u00ac\5\60\31\2\u00a8\u00a9\7\6&#34;)
        buf.write(&#34;\2\2\u00a9\u00ab\5\60\31\2\u00aa\u00a8\3\2\2\2\u00ab\u00ae&#34;)
        buf.write(&#34;\3\2\2\2\u00ac\u00aa\3\2\2\2\u00ac\u00ad\3\2\2\2\u00ad&#34;)
        buf.write(&#34;\21\3\2\2\2\u00ae\u00ac\3\2\2\2\u00af\u00b0\7(\2\2\u00b0&#34;)
        buf.write(&#34;\u00b1\5\66\34\2\u00b1\23\3\2\2\2\u00b2\u00b3\7&lt;\2\2\u00b3&#34;)
        buf.write(&#34;\u00b4\7\23\2\2\u00b4\u00b9\5 \21\2\u00b5\u00b6\7\6\2&#34;)
        buf.write(&#34;\2\u00b6\u00b8\5 \21\2\u00b7\u00b5\3\2\2\2\u00b8\u00bb&#34;)
        buf.write(&#34;\3\2\2\2\u00b9\u00b7\3\2\2\2\u00b9\u00ba\3\2\2\2\u00ba&#34;)
        buf.write(&#34;\25\3\2\2\2\u00bb\u00b9\3\2\2\2\u00bc\u00bd\7\61\2\2\u00bd&#34;)
        buf.write(&#34;\u00be\5`\61\2\u00be\27\3\2\2\2\u00bf\u00c0\7X\2\2\u00c0&#34;)
        buf.write(&#34;\u00c1\5`\61\2\u00c1\31\3\2\2\2\u00c2\u00c3\5\34\17\2&#34;)
        buf.write(&#34;\u00c3\u00c4\7/\2\2\u00c4\u00c6\5&amp;\24\2\u00c5\u00c7\5&#34;)
        buf.write(&#34;\36\20\2\u00c6\u00c5\3\2\2\2\u00c6\u00c7\3\2\2\2\u00c7&#34;)
        buf.write(&#34;\33\3\2\2\2\u00c8\u00ca\7,\2\2\u00c9\u00c8\3\2\2\2\u00c9&#34;)
        buf.write(&#34;\u00ca\3\2\2\2\u00ca\u00e1\3\2\2\2\u00cb\u00e1\7\32\2&#34;)
        buf.write(&#34;\2\u00cc\u00ce\7\60\2\2\u00cd\u00cf\7=\2\2\u00ce\u00cd&#34;)
        buf.write(&#34;\3\2\2\2\u00ce\u00cf\3\2\2\2\u00cf\u00e1\3\2\2\2\u00d0&#34;)
        buf.write(&#34;\u00d2\7\60\2\2\u00d1\u00d0\3\2\2\2\u00d1\u00d2\3\2\2&#34;)
        buf.write(&#34;\2\u00d2\u00d3\3\2\2\2\u00d3\u00e1\7L\2\2\u00d4\u00d6&#34;)
        buf.write(&#34;\7G\2\2\u00d5\u00d7\7=\2\2\u00d6\u00d5\3\2\2\2\u00d6\u00d7&#34;)
        buf.write(&#34;\3\2\2\2\u00d7\u00e1\3\2\2\2\u00d8\u00da\7&amp;\2\2\u00d9&#34;)
        buf.write(&#34;\u00db\7=\2\2\u00da\u00d9\3\2\2\2\u00da\u00db\3\2\2\2&#34;)
        buf.write(&#34;\u00db\u00e1\3\2\2\2\u00dc\u00de\7\60\2\2\u00dd\u00dc&#34;)
        buf.write(&#34;\3\2\2\2\u00dd\u00de\3\2\2\2\u00de\u00df\3\2\2\2\u00df&#34;)
        buf.write(&#34;\u00e1\7\f\2\2\u00e0\u00c9\3\2\2\2\u00e0\u00cb\3\2\2\2&#34;)
        buf.write(&#34;\u00e0\u00cc\3\2\2\2\u00e0\u00d1\3\2\2\2\u00e0\u00d4\3&#34;)
        buf.write(&#34;\2\2\2\u00e0\u00d8\3\2\2\2\u00e0\u00dd\3\2\2\2\u00e1\35&#34;)
        buf.write(&#34;\3\2\2\2\u00e2\u00e3\7:\2\2\u00e3\u00f1\5\66\34\2\u00e4&#34;)
        buf.write(&#34;\u00e5\7[\2\2\u00e5\u00e6\7\4\2\2\u00e6\u00eb\5^\60\2&#34;)
        buf.write(&#34;\u00e7\u00e8\7\6\2\2\u00e8\u00ea\5^\60\2\u00e9\u00e7\3&#34;)
        buf.write(&#34;\2\2\2\u00ea\u00ed\3\2\2\2\u00eb\u00e9\3\2\2\2\u00eb\u00ec&#34;)
        buf.write(&#34;\3\2\2\2\u00ec\u00ee\3\2\2\2\u00ed\u00eb\3\2\2\2\u00ee&#34;)
        buf.write(&#34;\u00ef\7\5\2\2\u00ef\u00f1\3\2\2\2\u00f0\u00e2\3\2\2\2&#34;)
        buf.write(&#34;\u00f0\u00e4\3\2\2\2\u00f1\37\3\2\2\2\u00f2\u00f4\5\60&#34;)
        buf.write(&#34;\31\2\u00f3\u00f5\t\2\2\2\u00f4\u00f3\3\2\2\2\u00f4\u00f5&#34;)
        buf.write(&#34;\3\2\2\2\u00f5!\3\2\2\2\u00f6\u00fa\7\36\2\2\u00f7\u00fa&#34;)
        buf.write(&#34;\7\n\2\2\u00f8\u00fa\5\30\r\2\u00f9\u00f6\3\2\2\2\u00f9&#34;)
        buf.write(&#34;\u00f7\3\2\2\2\u00f9\u00f8\3\2\2\2\u00fa#\3\2\2\2\u00fb&#34;)
        buf.write(&#34;\u00ff\5&amp;\24\2\u00fc\u00fe\5\32\16\2\u00fd\u00fc\3\2\2&#34;)
        buf.write(&#34;\2\u00fe\u0101\3\2\2\2\u00ff\u00fd\3\2\2\2\u00ff\u0100&#34;)
        buf.write(&#34;\3\2\2\2\u0100%\3\2\2\2\u0101\u00ff\3\2\2\2\u0102\u0105&#34;)
        buf.write(&#34;\5Z.\2\u0103\u0104\7\r\2\2\u0104\u0106\5^\60\2\u0105\u0103&#34;)
        buf.write(&#34;\3\2\2\2\u0105\u0106\3\2\2\2\u0106\u0114\3\2\2\2\u0107&#34;)
        buf.write(&#34;\u010a\5\6\4\2\u0108\u0109\7\r\2\2\u0109\u010b\5^\60\2&#34;)
        buf.write(&#34;\u010a\u0108\3\2\2\2\u010a\u010b\3\2\2\2\u010b\u0114\3&#34;)
        buf.write(&#34;\2\2\2\u010c\u010d\7\4\2\2\u010d\u010e\5$\23\2\u010e\u0111&#34;)
        buf.write(&#34;\7\5\2\2\u010f\u0110\7\r\2\2\u0110\u0112\5^\60\2\u0111&#34;)
        buf.write(&#34;\u010f\3\2\2\2\u0111\u0112\3\2\2\2\u0112\u0114\3\2\2\2&#34;)
        buf.write(&#34;\u0113\u0102\3\2\2\2\u0113\u0107\3\2\2\2\u0113\u010c\3&#34;)
        buf.write(&#34;\2\2\2\u0114\&#39;\3\2\2\2\u0115\u0117\7\24\2\2\u0116\u0118&#34;)
        buf.write(&#34;\5\60\31\2\u0117\u0116\3\2\2\2\u0117\u0118\3\2\2\2\u0118&#34;)
        buf.write(&#34;\u011a\3\2\2\2\u0119\u011b\5.\30\2\u011a\u0119\3\2\2\2&#34;)
        buf.write(&#34;\u011b\u011c\3\2\2\2\u011c\u011a\3\2\2\2\u011c\u011d\3&#34;)
        buf.write(&#34;\2\2\2\u011d\u0120\3\2\2\2\u011e\u011f\7 \2\2\u011f\u0121&#34;)
        buf.write(&#34;\5\60\31\2\u0120\u011e\3\2\2\2\u0120\u0121\3\2\2\2\u0121&#34;)
        buf.write(&#34;\u0122\3\2\2\2\u0122\u0123\7!\2\2\u0123)\3\2\2\2\u0124&#34;)
        buf.write(&#34;\u0127\5\60\31\2\u0125\u0126\7\r\2\2\u0126\u0128\5^\60&#34;)
        buf.write(&#34;\2\u0127\u0125\3\2\2\2\u0127\u0128\3\2\2\2\u0128+\3\2&#34;)
        buf.write(&#34;\2\2\u0129\u012e\5*\26\2\u012a\u012b\7\6\2\2\u012b\u012d&#34;)
        buf.write(&#34;\5*\26\2\u012c\u012a\3\2\2\2\u012d\u0130\3\2\2\2\u012e&#34;)
        buf.write(&#34;\u012c\3\2\2\2\u012e\u012f\3\2\2\2\u012f-\3\2\2\2\u0130&#34;)
        buf.write(&#34;\u012e\3\2\2\2\u0131\u0134\7^\2\2\u0132\u0135\5\66\34&#34;)
        buf.write(&#34;\2\u0133\u0135\5\60\31\2\u0134\u0132\3\2\2\2\u0134\u0133&#34;)
        buf.write(&#34;\3\2\2\2\u0135\u0136\3\2\2\2\u0136\u0137\7W\2\2\u0137&#34;)
        buf.write(&#34;\u0138\5\60\31\2\u0138/\3\2\2\2\u0139\u013a\b\31\1\2\u013a&#34;)
        buf.write(&#34;\u0146\5\\/\2\u013b\u0146\5(\25\2\u013c\u0146\5\62\32&#34;)
        buf.write(&#34;\2\u013d\u0146\5\64\33\2\u013e\u0146\5B\&#34;\2\u013f\u0146&#34;)
        buf.write(&#34;\5&gt; \2\u0140\u0146\5\b\5\2\u0141\u0142\7\4\2\2\u0142\u0143&#34;)
        buf.write(&#34;\5\60\31\2\u0143\u0144\7\5\2\2\u0144\u0146\3\2\2\2\u0145&#34;)
        buf.write(&#34;\u0139\3\2\2\2\u0145\u013b\3\2\2\2\u0145\u013c\3\2\2\2&#34;)
        buf.write(&#34;\u0145\u013d\3\2\2\2\u0145\u013e\3\2\2\2\u0145\u013f\3&#34;)
        buf.write(&#34;\2\2\2\u0145\u0140\3\2\2\2\u0145\u0141\3\2\2\2\u0146\u0158&#34;)
        buf.write(&#34;\3\2\2\2\u0147\u0148\f\16\2\2\u0148\u0149\7j\2\2\u0149&#34;)
        buf.write(&#34;\u0157\5\60\31\17\u014a\u014b\f\r\2\2\u014b\u014c\7k\2&#34;)
        buf.write(&#34;\2\u014c\u0157\5\60\31\16\u014d\u014e\f\f\2\2\u014e\u014f&#34;)
        buf.write(&#34;\7l\2\2\u014f\u0157\5\60\31\r\u0150\u0151\f\13\2\2\u0151&#34;)
        buf.write(&#34;\u0152\7h\2\2\u0152\u0157\5\60\31\f\u0153\u0154\f\n\2&#34;)
        buf.write(&#34;\2\u0154\u0155\7i\2\2\u0155\u0157\5\60\31\13\u0156\u0147&#34;)
        buf.write(&#34;\3\2\2\2\u0156\u014a\3\2\2\2\u0156\u014d\3\2\2\2\u0156&#34;)
        buf.write(&#34;\u0150\3\2\2\2\u0156\u0153\3\2\2\2\u0157\u015a\3\2\2\2&#34;)
        buf.write(&#34;\u0158\u0156\3\2\2\2\u0158\u0159\3\2\2\2\u0159\61\3\2&#34;)
        buf.write(&#34;\2\2\u015a\u0158\3\2\2\2\u015b\u0161\7j\2\2\u015c\u015d&#34;)
        buf.write(&#34;\5^\60\2\u015d\u015e\7\7\2\2\u015e\u015f\7j\2\2\u015f&#34;)
        buf.write(&#34;\u0161\3\2\2\2\u0160\u015b\3\2\2\2\u0160\u015c\3\2\2\2&#34;)
        buf.write(&#34;\u0161\63\3\2\2\2\u0162\u0168\7r\2\2\u0163\u0168\5`\61&#34;)
        buf.write(&#34;\2\u0164\u0168\7Y\2\2\u0165\u0168\7#\2\2\u0166\u0168\7&#34;)
        buf.write(&#34;8\2\2\u0167\u0162\3\2\2\2\u0167\u0163\3\2\2\2\u0167\u0164&#34;)
        buf.write(&#34;\3\2\2\2\u0167\u0165\3\2\2\2\u0167\u0166\3\2\2\2\u0168&#34;)
        buf.write(&#34;\65\3\2\2\2\u0169\u016a\b\34\1\2\u016a\u016b\7\67\2\2&#34;)
        buf.write(&#34;\u016b\u0178\5\66\34\b\u016c\u016d\5\60\31\2\u016d\u016e&#34;)
        buf.write(&#34;\5:\36\2\u016e\u016f\5\60\31\2\u016f\u0178\3\2\2\2\u0170&#34;)
        buf.write(&#34;\u0171\7\4\2\2\u0171\u0172\5\66\34\2\u0172\u0173\7\5\2&#34;)
        buf.write(&#34;\2\u0173\u0178\3\2\2\2\u0174\u0175\5\60\31\2\u0175\u0176&#34;)
        buf.write(&#34;\58\35\2\u0176\u0178\3\2\2\2\u0177\u0169\3\2\2\2\u0177&#34;)
        buf.write(&#34;\u016c\3\2\2\2\u0177\u0170\3\2\2\2\u0177\u0174\3\2\2\2&#34;)
        buf.write(&#34;\u0178\u0181\3\2\2\2\u0179\u017a\f\6\2\2\u017a\u017b\7&#34;)
        buf.write(&#34;\13\2\2\u017b\u0180\5\66\34\7\u017c\u017d\f\5\2\2\u017d&#34;)
        buf.write(&#34;\u017e\7;\2\2\u017e\u0180\5\66\34\6\u017f\u0179\3\2\2&#34;)
        buf.write(&#34;\2\u017f\u017c\3\2\2\2\u0180\u0183\3\2\2\2\u0181\u017f&#34;)
        buf.write(&#34;\3\2\2\2\u0181\u0182\3\2\2\2\u0182\67\3\2\2\2\u0183\u0181&#34;)
        buf.write(&#34;\3\2\2\2\u0184\u0186\7\67\2\2\u0185\u0184\3\2\2\2\u0185&#34;)
        buf.write(&#34;\u0186\3\2\2\2\u0186\u0187\3\2\2\2\u0187\u0188\7\22\2&#34;)
        buf.write(&#34;\2\u0188\u0189\5\60\31\2\u0189\u018a\7\13\2\2\u018a\u018b&#34;)
        buf.write(&#34;\5\60\31\2\u018b\u01a1\3\2\2\2\u018c\u018e\7\67\2\2\u018d&#34;)
        buf.write(&#34;\u018c\3\2\2\2\u018d\u018e\3\2\2\2\u018e\u018f\3\2\2\2&#34;)
        buf.write(&#34;\u018f\u0190\7+\2\2\u0190\u0191\7\4\2\2\u0191\u0196\5&#34;)
        buf.write(&#34;\60\31\2\u0192\u0193\7\6\2\2\u0193\u0195\5\60\31\2\u0194&#34;)
        buf.write(&#34;\u0192\3\2\2\2\u0195\u0198\3\2\2\2\u0196\u0194\3\2\2\2&#34;)
        buf.write(&#34;\u0196\u0197\3\2\2\2\u0197\u0199\3\2\2\2\u0198\u0196\3&#34;)
        buf.write(&#34;\2\2\2\u0199\u019a\7\5\2\2\u019a\u01a1\3\2\2\2\u019b\u019d&#34;)
        buf.write(&#34;\7.\2\2\u019c\u019e\7\67\2\2\u019d\u019c\3\2\2\2\u019d&#34;)
        buf.write(&#34;\u019e\3\2\2\2\u019e\u019f\3\2\2\2\u019f\u01a1\t\3\2\2&#34;)
        buf.write(&#34;\u01a0\u0185\3\2\2\2\u01a0\u018d\3\2\2\2\u01a0\u019b\3&#34;)
        buf.write(&#34;\2\2\2\u01a19\3\2\2\2\u01a2\u01a3\t\4\2\2\u01a3;\3\2\2&#34;)
        buf.write(&#34;\2\u01a4\u01a5\t\5\2\2\u01a5=\3\2\2\2\u01a6\u01cb\5@!&#34;)
        buf.write(&#34;\2\u01a7\u01cb\5D#\2\u01a8\u01cb\5F$\2\u01a9\u01aa\5J&#34;)
        buf.write(&#34;&amp;\2\u01aa\u01ac\7\4\2\2\u01ab\u01ad\5\&#34;\22\2\u01ac\u01ab&#34;)
        buf.write(&#34;\3\2\2\2\u01ac\u01ad\3\2\2\2\u01ad\u01ae\3\2\2\2\u01ae&#34;)
        buf.write(&#34;\u01af\5\60\31\2\u01af\u01b0\7\5\2\2\u01b0\u01cb\3\2\2&#34;)
        buf.write(&#34;\2\u01b1\u01b2\5L\&#39;\2\u01b2\u01b3\7\4\2\2\u01b3\u01b4&#34;)
        buf.write(&#34;\5\60\31\2\u01b4\u01b5\7\5\2\2\u01b5\u01cb\3\2\2\2\u01b6&#34;)
        buf.write(&#34;\u01b7\7*\2\2\u01b7\u01b8\7\4\2\2\u01b8\u01b9\5\66\34&#34;)
        buf.write(&#34;\2\u01b9\u01ba\7\6\2\2\u01ba\u01bb\5\60\31\2\u01bb\u01bc&#34;)
        buf.write(&#34;\7\6\2\2\u01bc\u01bd\5\60\31\2\u01bd\u01be\7\5\2\2\u01be&#34;)
        buf.write(&#34;\u01cb\3\2\2\2\u01bf\u01c0\7\26\2\2\u01c0\u01c1\7\4\2&#34;)
        buf.write(&#34;\2\u01c1\u01c4\5\60\31\2\u01c2\u01c3\7\6\2\2\u01c3\u01c5&#34;)
        buf.write(&#34;\5\64\33\2\u01c4\u01c2\3\2\2\2\u01c5\u01c6\3\2\2\2\u01c6&#34;)
        buf.write(&#34;\u01c4\3\2\2\2\u01c6\u01c7\3\2\2\2\u01c7\u01c8\3\2\2\2&#34;)
        buf.write(&#34;\u01c8\u01c9\7\5\2\2\u01c9\u01cb\3\2\2\2\u01ca\u01a6\3&#34;)
        buf.write(&#34;\2\2\2\u01ca\u01a7\3\2\2\2\u01ca\u01a8\3\2\2\2\u01ca\u01a9&#34;)
        buf.write(&#34;\3\2\2\2\u01ca\u01b1\3\2\2\2\u01ca\u01b6\3\2\2\2\u01ca&#34;)
        buf.write(&#34;\u01bf\3\2\2\2\u01cb?\3\2\2\2\u01cc\u01cd\5N(\2\u01cd&#34;)
        buf.write(&#34;\u01ce\7\4\2\2\u01ce\u01cf\7\5\2\2\u01cfA\3\2\2\2\u01d0&#34;)
        buf.write(&#34;\u01d1\5H%\2\u01d1\u01d2\7\4\2\2\u01d2\u01d3\7\5\2\2\u01d3&#34;)
        buf.write(&#34;\u01d4\5P)\2\u01d4C\3\2\2\2\u01d5\u01d6\7H\2\2\u01d6\u01d7&#34;)
        buf.write(&#34;\7\4\2\2\u01d7\u01d8\5\60\31\2\u01d8\u01d9\7\6\2\2\u01d9&#34;)
        buf.write(&#34;\u01da\5`\61\2\u01da\u01db\7\5\2\2\u01dbE\3\2\2\2\u01dc&#34;)
        buf.write(&#34;\u01dd\7C\2\2\u01dd\u01de\7\4\2\2\u01de\u01df\5\60\31&#34;)
        buf.write(&#34;\2\u01df\u01e0\7\6\2\2\u01e0\u01e1\5`\61\2\u01e1\u01e2&#34;)
        buf.write(&#34;\7\5\2\2\u01e2G\3\2\2\2\u01e3\u01e4\t\6\2\2\u01e4I\3\2&#34;)
        buf.write(&#34;\2\2\u01e5\u01e6\t\7\2\2\u01e6K\3\2\2\2\u01e7\u01e8\t&#34;)
        buf.write(&#34;\b\2\2\u01e8M\3\2\2\2\u01e9\u01ea\t\t\2\2\u01eaO\3\2\2&#34;)
        buf.write(&#34;\2\u01eb\u01ec\7&gt;\2\2\u01ec\u01f0\7\4\2\2\u01ed\u01ee&#34;)
        buf.write(&#34;\7?\2\2\u01ee\u01ef\7\23\2\2\u01ef\u01f1\5\60\31\2\u01f0&#34;)
        buf.write(&#34;\u01ed\3\2\2\2\u01f0\u01f1\3\2\2\2\u01f1\u01f3\3\2\2\2&#34;)
        buf.write(&#34;\u01f2\u01f4\5\24\13\2\u01f3\u01f2\3\2\2\2\u01f3\u01f4&#34;)
        buf.write(&#34;\3\2\2\2\u01f4\u01f5\3\2\2\2\u01f5\u01f6\7\5\2\2\u01f6&#34;)
        buf.write(&#34;Q\3\2\2\2\u01f7\u01fa\5\6\4\2\u01f8\u01f9\7\r\2\2\u01f9&#34;)
        buf.write(&#34;\u01fb\5^\60\2\u01fa\u01f8\3\2\2\2\u01fa\u01fb\3\2\2\2&#34;)
        buf.write(&#34;\u01fbS\3\2\2\2\u01fc\u01ff\5X-\2\u01fd\u01ff\5R*\2\u01fe&#34;)
        buf.write(&#34;\u01fc\3\2\2\2\u01fe\u01fd\3\2\2\2\u01ff\u0207\3\2\2\2&#34;)
        buf.write(&#34;\u0200\u0203\7\6\2\2\u0201\u0204\5X-\2\u0202\u0204\5R&#34;)
        buf.write(&#34;*\2\u0203\u0201\3\2\2\2\u0203\u0202\3\2\2\2\u0204\u0206&#34;)
        buf.write(&#34;\3\2\2\2\u0205\u0200\3\2\2\2\u0206\u0209\3\2\2\2\u0207&#34;)
        buf.write(&#34;\u0205\3\2\2\2\u0207\u0208\3\2\2\2\u0208U\3\2\2\2\u0209&#34;)
        buf.write(&#34;\u0207\3\2\2\2\u020a\u020f\5X-\2\u020b\u020c\7\6\2\2\u020c&#34;)
        buf.write(&#34;\u020e\5X-\2\u020d\u020b\3\2\2\2\u020e\u0211\3\2\2\2\u020f&#34;)
        buf.write(&#34;\u020d\3\2\2\2\u020f\u0210\3\2\2\2\u0210W\3\2\2\2\u0211&#34;)
        buf.write(&#34;\u020f\3\2\2\2\u0212\u0215\5Z.\2\u0213\u0214\7\r\2\2\u0214&#34;)
        buf.write(&#34;\u0216\5^\60\2\u0215\u0213\3\2\2\2\u0215\u0216\3\2\2\2&#34;)
        buf.write(&#34;\u0216Y\3\2\2\2\u0217\u0218\t\n\2\2\u0218[\3\2\2\2\u0219&#34;)
        buf.write(&#34;\u021a\t\13\2\2\u021a]\3\2\2\2\u021b\u021c\7w\2\2\u021c&#34;)
        buf.write(&#34;_\3\2\2\2\u021d\u021f\7i\2\2\u021e\u021d\3\2\2\2\u021e&#34;)
        buf.write(&#34;\u021f\3\2\2\2\u021f\u0220\3\2\2\2\u0220\u0226\7t\2\2&#34;)
        buf.write(&#34;\u0221\u0223\7i\2\2\u0222\u0221\3\2\2\2\u0222\u0223\3&#34;)
        buf.write(&#34;\2\2\2\u0223\u0224\3\2\2\2\u0224\u0226\7s\2\2\u0225\u021e&#34;)
        buf.write(&#34;\3\2\2\2\u0225\u0222\3\2\2\2\u0226a\3\2\2\2Cgkrux{~\u0084&#34;)
        buf.write(&#34;\u0087\u008a\u008d\u0095\u009f\u00ac\u00b9\u00c6\u00c9&#34;)
        buf.write(&#34;\u00ce\u00d1\u00d6\u00da\u00dd\u00e0\u00eb\u00f0\u00f4&#34;)
        buf.write(&#34;\u00f9\u00ff\u0105\u010a\u0111\u0113\u0117\u011c\u0120&#34;)
        buf.write(&#34;\u0127\u012e\u0134\u0145\u0156\u0158\u0160\u0167\u0177&#34;)
        buf.write(&#34;\u017f\u0181\u0185\u018d\u0196\u019d\u01a0\u01ac\u01c6&#34;)
        buf.write(&#34;\u01ca\u01f0\u01f3\u01fa\u01fe\u0203\u0207\u020f\u0215&#34;)
        buf.write(&#34;\u021e\u0222\u0225&#34;)
        return buf.getvalue()


class SqlSmallParser ( Parser ):

    grammarFileName = &#34;SqlSmall.g4&#34;

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ &#34;&lt;INVALID&gt;&#34;, &#34;&#39;;&#39;&#34;, &#34;&#39;(&#39;&#34;, &#34;&#39;)&#39;&#34;, &#34;&#39;,&#39;&#34;, &#34;&#39;.&#39;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&#39;&lt;=&gt;&#39;&#34;, &#34;&#39;&lt;&gt;&#39;&#34;, &#34;&#39;!=&#39;&#34;, &#34;&#39;&lt;&#39;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&#39;&gt;&#39;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&#39;+&#39;&#34;, &#34;&#39;-&#39;&#34;, &#34;&#39;*&#39;&#34;, &#34;&#39;/&#39;&#34;, &#34;&#39;%&#39;&#34;, &#34;&#39;~&#39;&#34;, 
                     &#34;&#39;&amp;&#39;&#34;, &#34;&#39;|&#39;&#34;, &#34;&#39;||&#39;&#34;, &#34;&#39;^&#39;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&#39;/**/&#39;&#34; ]

    symbolicNames = [ &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                      &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;ABS&#34;, &#34;ACOS&#34;, &#34;ALL&#34;, &#34;AND&#34;, 
                      &#34;ANTI&#34;, &#34;AS&#34;, &#34;ASC&#34;, &#34;ASIN&#34;, &#34;ATAN&#34;, &#34;AVG&#34;, &#34;BETWEEN&#34;, 
                      &#34;BY&#34;, &#34;CASE&#34;, &#34;CEILING&#34;, &#34;CHOOSE&#34;, &#34;COS&#34;, &#34;COT&#34;, &#34;COUNT&#34;, 
                      &#34;CROSS&#34;, &#34;DEGREES&#34;, &#34;DENSE_RANK&#34;, &#34;DESC&#34;, &#34;DISTINCT&#34;, 
                      &#34;DIV&#34;, &#34;ELSE&#34;, &#34;END&#34;, &#34;EXP&#34;, &#34;FALSE&#34;, &#34;FLOOR&#34;, &#34;FROM&#34;, 
                      &#34;FULL&#34;, &#34;GROUP&#34;, &#34;HAVING&#34;, &#34;IF&#34;, &#34;IIF&#34;, &#34;IN&#34;, &#34;INNER&#34;, 
                      &#34;INTERSECT&#34;, &#34;IS&#34;, &#34;JOIN&#34;, &#34;LEFT&#34;, &#34;LIMIT&#34;, &#34;LOG&#34;, 
                      &#34;LOG10&#34;, &#34;MAX&#34;, &#34;MIN&#34;, &#34;NEWID&#34;, &#34;NOT&#34;, &#34;NULL&#34;, &#34;NUMERIC&#34;, 
                      &#34;ON&#34;, &#34;OR&#34;, &#34;ORDER&#34;, &#34;OUTER&#34;, &#34;OVER&#34;, &#34;PARTITION&#34;, 
                      &#34;PERCENTILE_CONT&#34;, &#34;PERCENTILE_DISC&#34;, &#34;PI&#34;, &#34;POWER&#34;, 
                      &#34;RAND&#34;, &#34;RANDOM&#34;, &#34;RANK&#34;, &#34;RIGHT&#34;, &#34;ROUND&#34;, &#34;ROW_NUMBER&#34;, 
                      &#34;ROWNUM&#34;, &#34;SELECT&#34;, &#34;SEMI&#34;, &#34;SIGN&#34;, &#34;SIN&#34;, &#34;SORT&#34;, 
                      &#34;SQL&#34;, &#34;SQRT&#34;, &#34;SQUARE&#34;, &#34;STD&#34;, &#34;STDDEV&#34;, &#34;SUM&#34;, &#34;TAN&#34;, 
                      &#34;THEN&#34;, &#34;TOP&#34;, &#34;TRUE&#34;, &#34;UNION&#34;, &#34;USING&#34;, &#34;VAR&#34;, &#34;VARIANCE&#34;, 
                      &#34;WHEN&#34;, &#34;WHERE&#34;, &#34;EQ&#34;, &#34;NSEQ&#34;, &#34;NEQ&#34;, &#34;NEQJ&#34;, &#34;LT&#34;, 
                      &#34;LTE&#34;, &#34;GT&#34;, &#34;GTE&#34;, &#34;PLUS&#34;, &#34;MINUS&#34;, &#34;ASTERISK&#34;, &#34;SLASH&#34;, 
                      &#34;PERCENT&#34;, &#34;TILDE&#34;, &#34;AMPERSAND&#34;, &#34;PIPE&#34;, &#34;CONCAT_PIPE&#34;, 
                      &#34;HAT&#34;, &#34;STRING&#34;, &#34;INTEGER_VALUE&#34;, &#34;DECIMAL_VALUE&#34;, 
                      &#34;QN2&#34;, &#34;QN3&#34;, &#34;IDENT&#34;, &#34;IDENTIFIER&#34;, &#34;ESCAPED_IDENTIFIER&#34;, 
                      &#34;LETTER&#34;, &#34;SIMPLE_COMMENT&#34;, &#34;BRACKETED_EMPTY_COMMENT&#34;, 
                      &#34;BRACKETED_COMMENT&#34;, &#34;WS&#34;, &#34;SPACE&#34; ]

    RULE_batch = 0
    RULE_query = 1
    RULE_subquery = 2
    RULE_expressionSubquery = 3
    RULE_selectClause = 4
    RULE_fromClause = 5
    RULE_whereClause = 6
    RULE_aggregationClause = 7
    RULE_havingClause = 8
    RULE_orderClause = 9
    RULE_limitClause = 10
    RULE_topClause = 11
    RULE_joinRelation = 12
    RULE_joinType = 13
    RULE_joinCriteria = 14
    RULE_sortItem = 15
    RULE_setQuantifier = 16
    RULE_relation = 17
    RULE_relationPrimary = 18
    RULE_caseExpression = 19
    RULE_namedExpression = 20
    RULE_namedExpressionSeq = 21
    RULE_whenExpression = 22
    RULE_expression = 23
    RULE_allExpression = 24
    RULE_literal = 25
    RULE_booleanExpression = 26
    RULE_predicate = 27
    RULE_comparisonOperator = 28
    RULE_booleanValue = 29
    RULE_functionExpression = 30
    RULE_bareFunction = 31
    RULE_rankingFunction = 32
    RULE_roundFunction = 33
    RULE_powerFunction = 34
    RULE_rankingFunctionName = 35
    RULE_aggregateFunctionName = 36
    RULE_mathFunctionName = 37
    RULE_bareFunctionName = 38
    RULE_overClause = 39
    RULE_aliasedSubquery = 40
    RULE_aliasedTableOrSubquerySeq = 41
    RULE_aliasedTableSeq = 42
    RULE_aliasedTableName = 43
    RULE_qualifiedTableName = 44
    RULE_qualifiedColumnName = 45
    RULE_identifier = 46
    RULE_number = 47

    ruleNames =  [ &#34;batch&#34;, &#34;query&#34;, &#34;subquery&#34;, &#34;expressionSubquery&#34;, &#34;selectClause&#34;, 
                   &#34;fromClause&#34;, &#34;whereClause&#34;, &#34;aggregationClause&#34;, &#34;havingClause&#34;, 
                   &#34;orderClause&#34;, &#34;limitClause&#34;, &#34;topClause&#34;, &#34;joinRelation&#34;, 
                   &#34;joinType&#34;, &#34;joinCriteria&#34;, &#34;sortItem&#34;, &#34;setQuantifier&#34;, 
                   &#34;relation&#34;, &#34;relationPrimary&#34;, &#34;caseExpression&#34;, &#34;namedExpression&#34;, 
                   &#34;namedExpressionSeq&#34;, &#34;whenExpression&#34;, &#34;expression&#34;, 
                   &#34;allExpression&#34;, &#34;literal&#34;, &#34;booleanExpression&#34;, &#34;predicate&#34;, 
                   &#34;comparisonOperator&#34;, &#34;booleanValue&#34;, &#34;functionExpression&#34;, 
                   &#34;bareFunction&#34;, &#34;rankingFunction&#34;, &#34;roundFunction&#34;, &#34;powerFunction&#34;, 
                   &#34;rankingFunctionName&#34;, &#34;aggregateFunctionName&#34;, &#34;mathFunctionName&#34;, 
                   &#34;bareFunctionName&#34;, &#34;overClause&#34;, &#34;aliasedSubquery&#34;, 
                   &#34;aliasedTableOrSubquerySeq&#34;, &#34;aliasedTableSeq&#34;, &#34;aliasedTableName&#34;, 
                   &#34;qualifiedTableName&#34;, &#34;qualifiedColumnName&#34;, &#34;identifier&#34;, 
                   &#34;number&#34; ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    ABS=6
    ACOS=7
    ALL=8
    AND=9
    ANTI=10
    AS=11
    ASC=12
    ASIN=13
    ATAN=14
    AVG=15
    BETWEEN=16
    BY=17
    CASE=18
    CEILING=19
    CHOOSE=20
    COS=21
    COT=22
    COUNT=23
    CROSS=24
    DEGREES=25
    DENSE_RANK=26
    DESC=27
    DISTINCT=28
    DIV=29
    ELSE=30
    END=31
    EXP=32
    FALSE=33
    FLOOR=34
    FROM=35
    FULL=36
    GROUP=37
    HAVING=38
    IF=39
    IIF=40
    IN=41
    INNER=42
    INTERSECT=43
    IS=44
    JOIN=45
    LEFT=46
    LIMIT=47
    LOG=48
    LOG10=49
    MAX=50
    MIN=51
    NEWID=52
    NOT=53
    NULL=54
    NUMERIC=55
    ON=56
    OR=57
    ORDER=58
    OUTER=59
    OVER=60
    PARTITION=61
    PERCENTILE_CONT=62
    PERCENTILE_DISC=63
    PI=64
    POWER=65
    RAND=66
    RANDOM=67
    RANK=68
    RIGHT=69
    ROUND=70
    ROW_NUMBER=71
    ROWNUM=72
    SELECT=73
    SEMI=74
    SIGN=75
    SIN=76
    SORT=77
    SQL=78
    SQRT=79
    SQUARE=80
    STD=81
    STDDEV=82
    SUM=83
    TAN=84
    THEN=85
    TOP=86
    TRUE=87
    UNION=88
    USING=89
    VAR=90
    VARIANCE=91
    WHEN=92
    WHERE=93
    EQ=94
    NSEQ=95
    NEQ=96
    NEQJ=97
    LT=98
    LTE=99
    GT=100
    GTE=101
    PLUS=102
    MINUS=103
    ASTERISK=104
    SLASH=105
    PERCENT=106
    TILDE=107
    AMPERSAND=108
    PIPE=109
    CONCAT_PIPE=110
    HAT=111
    STRING=112
    INTEGER_VALUE=113
    DECIMAL_VALUE=114
    QN2=115
    QN3=116
    IDENT=117
    IDENTIFIER=118
    ESCAPED_IDENTIFIER=119
    LETTER=120
    SIMPLE_COMMENT=121
    BRACKETED_EMPTY_COMMENT=122
    BRACKETED_COMMENT=123
    WS=124
    SPACE=125

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion(&#34;4.8&#34;)
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class BatchContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def query(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.QueryContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.QueryContext,i)


        def EOF(self):
            return self.getToken(SqlSmallParser.EOF, 0)

        def getRuleIndex(self):
            return SqlSmallParser.RULE_batch

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterBatch&#34; ):
                listener.enterBatch(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitBatch&#34; ):
                listener.exitBatch(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitBatch&#34; ):
                return visitor.visitBatch(self)
            else:
                return visitor.visitChildren(self)




    def batch(self):

        localctx = SqlSmallParser.BatchContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_batch)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 96
            self.query()
            self.state = 101
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,0,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 97
                    self.match(SqlSmallParser.T__0)
                    self.state = 98
                    self.query() 
                self.state = 103
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,0,self._ctx)

            self.state = 105
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.T__0:
                self.state = 104
                self.match(SqlSmallParser.T__0)


            self.state = 107
            self.match(SqlSmallParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QueryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def selectClause(self):
            return self.getTypedRuleContext(SqlSmallParser.SelectClauseContext,0)


        def fromClause(self):
            return self.getTypedRuleContext(SqlSmallParser.FromClauseContext,0)


        def whereClause(self):
            return self.getTypedRuleContext(SqlSmallParser.WhereClauseContext,0)


        def aggregationClause(self):
            return self.getTypedRuleContext(SqlSmallParser.AggregationClauseContext,0)


        def havingClause(self):
            return self.getTypedRuleContext(SqlSmallParser.HavingClauseContext,0)


        def orderClause(self):
            return self.getTypedRuleContext(SqlSmallParser.OrderClauseContext,0)


        def limitClause(self):
            return self.getTypedRuleContext(SqlSmallParser.LimitClauseContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_query

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterQuery&#34; ):
                listener.enterQuery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitQuery&#34; ):
                listener.exitQuery(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitQuery&#34; ):
                return visitor.visitQuery(self)
            else:
                return visitor.visitChildren(self)




    def query(self):

        localctx = SqlSmallParser.QueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_query)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 109
            self.selectClause()
            self.state = 110
            self.fromClause()
            self.state = 112
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.WHERE:
                self.state = 111
                self.whereClause()


            self.state = 115
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.GROUP:
                self.state = 114
                self.aggregationClause()


            self.state = 118
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.HAVING:
                self.state = 117
                self.havingClause()


            self.state = 121
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.ORDER:
                self.state = 120
                self.orderClause()


            self.state = 124
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.LIMIT:
                self.state = 123
                self.limitClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubqueryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def selectClause(self):
            return self.getTypedRuleContext(SqlSmallParser.SelectClauseContext,0)


        def fromClause(self):
            return self.getTypedRuleContext(SqlSmallParser.FromClauseContext,0)


        def whereClause(self):
            return self.getTypedRuleContext(SqlSmallParser.WhereClauseContext,0)


        def aggregationClause(self):
            return self.getTypedRuleContext(SqlSmallParser.AggregationClauseContext,0)


        def havingClause(self):
            return self.getTypedRuleContext(SqlSmallParser.HavingClauseContext,0)


        def orderClause(self):
            return self.getTypedRuleContext(SqlSmallParser.OrderClauseContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_subquery

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterSubquery&#34; ):
                listener.enterSubquery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitSubquery&#34; ):
                listener.exitSubquery(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitSubquery&#34; ):
                return visitor.visitSubquery(self)
            else:
                return visitor.visitChildren(self)




    def subquery(self):

        localctx = SqlSmallParser.SubqueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_subquery)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 126
            self.match(SqlSmallParser.T__1)
            self.state = 127
            self.selectClause()
            self.state = 128
            self.fromClause()
            self.state = 130
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.WHERE:
                self.state = 129
                self.whereClause()


            self.state = 133
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.GROUP:
                self.state = 132
                self.aggregationClause()


            self.state = 136
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.HAVING:
                self.state = 135
                self.havingClause()


            self.state = 139
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.ORDER:
                self.state = 138
                self.orderClause()


            self.state = 141
            self.match(SqlSmallParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionSubqueryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def subquery(self):
            return self.getTypedRuleContext(SqlSmallParser.SubqueryContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_expressionSubquery

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterExpressionSubquery&#34; ):
                listener.enterExpressionSubquery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitExpressionSubquery&#34; ):
                listener.exitExpressionSubquery(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitExpressionSubquery&#34; ):
                return visitor.visitExpressionSubquery(self)
            else:
                return visitor.visitChildren(self)




    def expressionSubquery(self):

        localctx = SqlSmallParser.ExpressionSubqueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_expressionSubquery)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 143
            self.subquery()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SelectClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SELECT(self):
            return self.getToken(SqlSmallParser.SELECT, 0)

        def namedExpressionSeq(self):
            return self.getTypedRuleContext(SqlSmallParser.NamedExpressionSeqContext,0)


        def setQuantifier(self):
            return self.getTypedRuleContext(SqlSmallParser.SetQuantifierContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_selectClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterSelectClause&#34; ):
                listener.enterSelectClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitSelectClause&#34; ):
                listener.exitSelectClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitSelectClause&#34; ):
                return visitor.visitSelectClause(self)
            else:
                return visitor.visitChildren(self)




    def selectClause(self):

        localctx = SqlSmallParser.SelectClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_selectClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 145
            self.match(SqlSmallParser.SELECT)
            self.state = 147
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.ALL or _la==SqlSmallParser.DISTINCT or _la==SqlSmallParser.TOP:
                self.state = 146
                self.setQuantifier()


            self.state = 149
            self.namedExpressionSeq()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FromClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FROM(self):
            return self.getToken(SqlSmallParser.FROM, 0)

        def relation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.RelationContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.RelationContext,i)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_fromClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterFromClause&#34; ):
                listener.enterFromClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitFromClause&#34; ):
                listener.exitFromClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitFromClause&#34; ):
                return visitor.visitFromClause(self)
            else:
                return visitor.visitChildren(self)




    def fromClause(self):

        localctx = SqlSmallParser.FromClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_fromClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 151
            self.match(SqlSmallParser.FROM)
            self.state = 152
            self.relation()
            self.state = 157
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SqlSmallParser.T__3:
                self.state = 153
                self.match(SqlSmallParser.T__3)
                self.state = 154
                self.relation()
                self.state = 159
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhereClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHERE(self):
            return self.getToken(SqlSmallParser.WHERE, 0)

        def booleanExpression(self):
            return self.getTypedRuleContext(SqlSmallParser.BooleanExpressionContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_whereClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterWhereClause&#34; ):
                listener.enterWhereClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitWhereClause&#34; ):
                listener.exitWhereClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitWhereClause&#34; ):
                return visitor.visitWhereClause(self)
            else:
                return visitor.visitChildren(self)




    def whereClause(self):

        localctx = SqlSmallParser.WhereClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_whereClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 160
            self.match(SqlSmallParser.WHERE)
            self.state = 161
            self.booleanExpression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregationClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._expression = None # ExpressionContext
            self.groupingExpressions = list() # of ExpressionContexts

        def GROUP(self):
            return self.getToken(SqlSmallParser.GROUP, 0)

        def BY(self):
            return self.getToken(SqlSmallParser.BY, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,i)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_aggregationClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterAggregationClause&#34; ):
                listener.enterAggregationClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitAggregationClause&#34; ):
                listener.exitAggregationClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitAggregationClause&#34; ):
                return visitor.visitAggregationClause(self)
            else:
                return visitor.visitChildren(self)




    def aggregationClause(self):

        localctx = SqlSmallParser.AggregationClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_aggregationClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 163
            self.match(SqlSmallParser.GROUP)
            self.state = 164
            self.match(SqlSmallParser.BY)
            self.state = 165
            localctx._expression = self.expression(0)
            localctx.groupingExpressions.append(localctx._expression)
            self.state = 170
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SqlSmallParser.T__3:
                self.state = 166
                self.match(SqlSmallParser.T__3)
                self.state = 167
                localctx._expression = self.expression(0)
                localctx.groupingExpressions.append(localctx._expression)
                self.state = 172
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HavingClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HAVING(self):
            return self.getToken(SqlSmallParser.HAVING, 0)

        def booleanExpression(self):
            return self.getTypedRuleContext(SqlSmallParser.BooleanExpressionContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_havingClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterHavingClause&#34; ):
                listener.enterHavingClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitHavingClause&#34; ):
                listener.exitHavingClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitHavingClause&#34; ):
                return visitor.visitHavingClause(self)
            else:
                return visitor.visitChildren(self)




    def havingClause(self):

        localctx = SqlSmallParser.HavingClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_havingClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 173
            self.match(SqlSmallParser.HAVING)
            self.state = 174
            self.booleanExpression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._sortItem = None # SortItemContext
            self.order = list() # of SortItemContexts

        def ORDER(self):
            return self.getToken(SqlSmallParser.ORDER, 0)

        def BY(self):
            return self.getToken(SqlSmallParser.BY, 0)

        def sortItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.SortItemContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.SortItemContext,i)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_orderClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterOrderClause&#34; ):
                listener.enterOrderClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitOrderClause&#34; ):
                listener.exitOrderClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitOrderClause&#34; ):
                return visitor.visitOrderClause(self)
            else:
                return visitor.visitChildren(self)




    def orderClause(self):

        localctx = SqlSmallParser.OrderClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_orderClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 176
            self.match(SqlSmallParser.ORDER)
            self.state = 177
            self.match(SqlSmallParser.BY)
            self.state = 178
            localctx._sortItem = self.sortItem()
            localctx.order.append(localctx._sortItem)
            self.state = 183
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SqlSmallParser.T__3:
                self.state = 179
                self.match(SqlSmallParser.T__3)
                self.state = 180
                localctx._sortItem = self.sortItem()
                localctx.order.append(localctx._sortItem)
                self.state = 185
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LimitClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.n = None # NumberContext

        def LIMIT(self):
            return self.getToken(SqlSmallParser.LIMIT, 0)

        def number(self):
            return self.getTypedRuleContext(SqlSmallParser.NumberContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_limitClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterLimitClause&#34; ):
                listener.enterLimitClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitLimitClause&#34; ):
                listener.exitLimitClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitLimitClause&#34; ):
                return visitor.visitLimitClause(self)
            else:
                return visitor.visitChildren(self)




    def limitClause(self):

        localctx = SqlSmallParser.LimitClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_limitClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 186
            self.match(SqlSmallParser.LIMIT)
            self.state = 187
            localctx.n = self.number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.n = None # NumberContext

        def TOP(self):
            return self.getToken(SqlSmallParser.TOP, 0)

        def number(self):
            return self.getTypedRuleContext(SqlSmallParser.NumberContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_topClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterTopClause&#34; ):
                listener.enterTopClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitTopClause&#34; ):
                listener.exitTopClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitTopClause&#34; ):
                return visitor.visitTopClause(self)
            else:
                return visitor.visitChildren(self)




    def topClause(self):

        localctx = SqlSmallParser.TopClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_topClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 189
            self.match(SqlSmallParser.TOP)
            self.state = 190
            localctx.n = self.number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class JoinRelationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.right = None # RelationPrimaryContext

        def JOIN(self):
            return self.getToken(SqlSmallParser.JOIN, 0)

        def relationPrimary(self):
            return self.getTypedRuleContext(SqlSmallParser.RelationPrimaryContext,0)


        def joinType(self):
            return self.getTypedRuleContext(SqlSmallParser.JoinTypeContext,0)


        def joinCriteria(self):
            return self.getTypedRuleContext(SqlSmallParser.JoinCriteriaContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_joinRelation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterJoinRelation&#34; ):
                listener.enterJoinRelation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitJoinRelation&#34; ):
                listener.exitJoinRelation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitJoinRelation&#34; ):
                return visitor.visitJoinRelation(self)
            else:
                return visitor.visitChildren(self)




    def joinRelation(self):

        localctx = SqlSmallParser.JoinRelationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_joinRelation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 192
            self.joinType()
            self.state = 193
            self.match(SqlSmallParser.JOIN)
            self.state = 194
            localctx.right = self.relationPrimary()
            self.state = 196
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.ON or _la==SqlSmallParser.USING:
                self.state = 195
                self.joinCriteria()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class JoinTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INNER(self):
            return self.getToken(SqlSmallParser.INNER, 0)

        def CROSS(self):
            return self.getToken(SqlSmallParser.CROSS, 0)

        def LEFT(self):
            return self.getToken(SqlSmallParser.LEFT, 0)

        def OUTER(self):
            return self.getToken(SqlSmallParser.OUTER, 0)

        def SEMI(self):
            return self.getToken(SqlSmallParser.SEMI, 0)

        def RIGHT(self):
            return self.getToken(SqlSmallParser.RIGHT, 0)

        def FULL(self):
            return self.getToken(SqlSmallParser.FULL, 0)

        def ANTI(self):
            return self.getToken(SqlSmallParser.ANTI, 0)

        def getRuleIndex(self):
            return SqlSmallParser.RULE_joinType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterJoinType&#34; ):
                listener.enterJoinType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitJoinType&#34; ):
                listener.exitJoinType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitJoinType&#34; ):
                return visitor.visitJoinType(self)
            else:
                return visitor.visitChildren(self)




    def joinType(self):

        localctx = SqlSmallParser.JoinTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_joinType)
        self._la = 0 # Token type
        try:
            self.state = 222
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 199
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlSmallParser.INNER:
                    self.state = 198
                    self.match(SqlSmallParser.INNER)


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 201
                self.match(SqlSmallParser.CROSS)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 202
                self.match(SqlSmallParser.LEFT)
                self.state = 204
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlSmallParser.OUTER:
                    self.state = 203
                    self.match(SqlSmallParser.OUTER)


                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 207
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlSmallParser.LEFT:
                    self.state = 206
                    self.match(SqlSmallParser.LEFT)


                self.state = 209
                self.match(SqlSmallParser.SEMI)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 210
                self.match(SqlSmallParser.RIGHT)
                self.state = 212
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlSmallParser.OUTER:
                    self.state = 211
                    self.match(SqlSmallParser.OUTER)


                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 214
                self.match(SqlSmallParser.FULL)
                self.state = 216
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlSmallParser.OUTER:
                    self.state = 215
                    self.match(SqlSmallParser.OUTER)


                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 219
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlSmallParser.LEFT:
                    self.state = 218
                    self.match(SqlSmallParser.LEFT)


                self.state = 221
                self.match(SqlSmallParser.ANTI)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class JoinCriteriaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlSmallParser.RULE_joinCriteria

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class BooleanJoinContext(JoinCriteriaContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.JoinCriteriaContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ON(self):
            return self.getToken(SqlSmallParser.ON, 0)
        def booleanExpression(self):
            return self.getTypedRuleContext(SqlSmallParser.BooleanExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterBooleanJoin&#34; ):
                listener.enterBooleanJoin(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitBooleanJoin&#34; ):
                listener.exitBooleanJoin(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitBooleanJoin&#34; ):
                return visitor.visitBooleanJoin(self)
            else:
                return visitor.visitChildren(self)


    class UsingJoinContext(JoinCriteriaContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.JoinCriteriaContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def USING(self):
            return self.getToken(SqlSmallParser.USING, 0)
        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.IdentifierContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterUsingJoin&#34; ):
                listener.enterUsingJoin(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitUsingJoin&#34; ):
                listener.exitUsingJoin(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitUsingJoin&#34; ):
                return visitor.visitUsingJoin(self)
            else:
                return visitor.visitChildren(self)



    def joinCriteria(self):

        localctx = SqlSmallParser.JoinCriteriaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_joinCriteria)
        self._la = 0 # Token type
        try:
            self.state = 238
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlSmallParser.ON]:
                localctx = SqlSmallParser.BooleanJoinContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 224
                self.match(SqlSmallParser.ON)
                self.state = 225
                self.booleanExpression(0)
                pass
            elif token in [SqlSmallParser.USING]:
                localctx = SqlSmallParser.UsingJoinContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 226
                self.match(SqlSmallParser.USING)
                self.state = 227
                self.match(SqlSmallParser.T__1)
                self.state = 228
                self.identifier()
                self.state = 233
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==SqlSmallParser.T__3:
                    self.state = 229
                    self.match(SqlSmallParser.T__3)
                    self.state = 230
                    self.identifier()
                    self.state = 235
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 236
                self.match(SqlSmallParser.T__2)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SortItemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ordering = None # Token

        def expression(self):
            return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,0)


        def ASC(self):
            return self.getToken(SqlSmallParser.ASC, 0)

        def DESC(self):
            return self.getToken(SqlSmallParser.DESC, 0)

        def getRuleIndex(self):
            return SqlSmallParser.RULE_sortItem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterSortItem&#34; ):
                listener.enterSortItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitSortItem&#34; ):
                listener.exitSortItem(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitSortItem&#34; ):
                return visitor.visitSortItem(self)
            else:
                return visitor.visitChildren(self)




    def sortItem(self):

        localctx = SqlSmallParser.SortItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_sortItem)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 240
            self.expression(0)
            self.state = 242
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.ASC or _la==SqlSmallParser.DESC:
                self.state = 241
                localctx.ordering = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==SqlSmallParser.ASC or _la==SqlSmallParser.DESC):
                    localctx.ordering = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetQuantifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DISTINCT(self):
            return self.getToken(SqlSmallParser.DISTINCT, 0)

        def ALL(self):
            return self.getToken(SqlSmallParser.ALL, 0)

        def topClause(self):
            return self.getTypedRuleContext(SqlSmallParser.TopClauseContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_setQuantifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterSetQuantifier&#34; ):
                listener.enterSetQuantifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitSetQuantifier&#34; ):
                listener.exitSetQuantifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitSetQuantifier&#34; ):
                return visitor.visitSetQuantifier(self)
            else:
                return visitor.visitChildren(self)




    def setQuantifier(self):

        localctx = SqlSmallParser.SetQuantifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_setQuantifier)
        try:
            self.state = 247
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlSmallParser.DISTINCT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 244
                self.match(SqlSmallParser.DISTINCT)
                pass
            elif token in [SqlSmallParser.ALL]:
                self.enterOuterAlt(localctx, 2)
                self.state = 245
                self.match(SqlSmallParser.ALL)
                pass
            elif token in [SqlSmallParser.TOP]:
                self.enterOuterAlt(localctx, 3)
                self.state = 246
                self.topClause()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RelationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def relationPrimary(self):
            return self.getTypedRuleContext(SqlSmallParser.RelationPrimaryContext,0)


        def joinRelation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.JoinRelationContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.JoinRelationContext,i)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_relation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterRelation&#34; ):
                listener.enterRelation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitRelation&#34; ):
                listener.exitRelation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitRelation&#34; ):
                return visitor.visitRelation(self)
            else:
                return visitor.visitChildren(self)




    def relation(self):

        localctx = SqlSmallParser.RelationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_relation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 249
            self.relationPrimary()
            self.state = 253
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) &amp; ~0x3f) == 0 and ((1 &lt;&lt; _la) &amp; ((1 &lt;&lt; SqlSmallParser.ANTI) | (1 &lt;&lt; SqlSmallParser.CROSS) | (1 &lt;&lt; SqlSmallParser.FULL) | (1 &lt;&lt; SqlSmallParser.INNER) | (1 &lt;&lt; SqlSmallParser.JOIN) | (1 &lt;&lt; SqlSmallParser.LEFT))) != 0) or _la==SqlSmallParser.RIGHT or _la==SqlSmallParser.SEMI:
                self.state = 250
                self.joinRelation()
                self.state = 255
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RelationPrimaryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlSmallParser.RULE_relationPrimary

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class AliasedRelationContext(RelationPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.RelationPrimaryContext
            super().__init__(parser)
            self.alias = None # IdentifierContext
            self.copyFrom(ctx)

        def relation(self):
            return self.getTypedRuleContext(SqlSmallParser.RelationContext,0)

        def AS(self):
            return self.getToken(SqlSmallParser.AS, 0)
        def identifier(self):
            return self.getTypedRuleContext(SqlSmallParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterAliasedRelation&#34; ):
                listener.enterAliasedRelation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitAliasedRelation&#34; ):
                listener.exitAliasedRelation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitAliasedRelation&#34; ):
                return visitor.visitAliasedRelation(self)
            else:
                return visitor.visitChildren(self)


    class AliasedQueryContext(RelationPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.RelationPrimaryContext
            super().__init__(parser)
            self.alias = None # IdentifierContext
            self.copyFrom(ctx)

        def subquery(self):
            return self.getTypedRuleContext(SqlSmallParser.SubqueryContext,0)

        def AS(self):
            return self.getToken(SqlSmallParser.AS, 0)
        def identifier(self):
            return self.getTypedRuleContext(SqlSmallParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterAliasedQuery&#34; ):
                listener.enterAliasedQuery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitAliasedQuery&#34; ):
                listener.exitAliasedQuery(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitAliasedQuery&#34; ):
                return visitor.visitAliasedQuery(self)
            else:
                return visitor.visitChildren(self)


    class TableContext(RelationPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.RelationPrimaryContext
            super().__init__(parser)
            self.alias = None # IdentifierContext
            self.copyFrom(ctx)

        def qualifiedTableName(self):
            return self.getTypedRuleContext(SqlSmallParser.QualifiedTableNameContext,0)

        def AS(self):
            return self.getToken(SqlSmallParser.AS, 0)
        def identifier(self):
            return self.getTypedRuleContext(SqlSmallParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterTable&#34; ):
                listener.enterTable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitTable&#34; ):
                listener.exitTable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitTable&#34; ):
                return visitor.visitTable(self)
            else:
                return visitor.visitChildren(self)



    def relationPrimary(self):

        localctx = SqlSmallParser.RelationPrimaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_relationPrimary)
        self._la = 0 # Token type
        try:
            self.state = 273
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,31,self._ctx)
            if la_ == 1:
                localctx = SqlSmallParser.TableContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 256
                self.qualifiedTableName()
                self.state = 259
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlSmallParser.AS:
                    self.state = 257
                    self.match(SqlSmallParser.AS)
                    self.state = 258
                    localctx.alias = self.identifier()


                pass

            elif la_ == 2:
                localctx = SqlSmallParser.AliasedQueryContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 261
                self.subquery()
                self.state = 264
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlSmallParser.AS:
                    self.state = 262
                    self.match(SqlSmallParser.AS)
                    self.state = 263
                    localctx.alias = self.identifier()


                pass

            elif la_ == 3:
                localctx = SqlSmallParser.AliasedRelationContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 266
                self.match(SqlSmallParser.T__1)
                self.state = 267
                self.relation()
                self.state = 268
                self.match(SqlSmallParser.T__2)
                self.state = 271
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlSmallParser.AS:
                    self.state = 269
                    self.match(SqlSmallParser.AS)
                    self.state = 270
                    localctx.alias = self.identifier()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CaseExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.baseCaseExpr = None # ExpressionContext
            self.elseExpr = None # ExpressionContext

        def CASE(self):
            return self.getToken(SqlSmallParser.CASE, 0)

        def END(self):
            return self.getToken(SqlSmallParser.END, 0)

        def whenExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.WhenExpressionContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.WhenExpressionContext,i)


        def ELSE(self):
            return self.getToken(SqlSmallParser.ELSE, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,i)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_caseExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterCaseExpression&#34; ):
                listener.enterCaseExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitCaseExpression&#34; ):
                listener.exitCaseExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitCaseExpression&#34; ):
                return visitor.visitCaseExpression(self)
            else:
                return visitor.visitChildren(self)




    def caseExpression(self):

        localctx = SqlSmallParser.CaseExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_caseExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 275
            self.match(SqlSmallParser.CASE)
            self.state = 277
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) &amp; ~0x3f) == 0 and ((1 &lt;&lt; _la) &amp; ((1 &lt;&lt; SqlSmallParser.T__1) | (1 &lt;&lt; SqlSmallParser.ABS) | (1 &lt;&lt; SqlSmallParser.ACOS) | (1 &lt;&lt; SqlSmallParser.ASIN) | (1 &lt;&lt; SqlSmallParser.ATAN) | (1 &lt;&lt; SqlSmallParser.AVG) | (1 &lt;&lt; SqlSmallParser.CASE) | (1 &lt;&lt; SqlSmallParser.CEILING) | (1 &lt;&lt; SqlSmallParser.CHOOSE) | (1 &lt;&lt; SqlSmallParser.COS) | (1 &lt;&lt; SqlSmallParser.COUNT) | (1 &lt;&lt; SqlSmallParser.DEGREES) | (1 &lt;&lt; SqlSmallParser.DENSE_RANK) | (1 &lt;&lt; SqlSmallParser.EXP) | (1 &lt;&lt; SqlSmallParser.FALSE) | (1 &lt;&lt; SqlSmallParser.FLOOR) | (1 &lt;&lt; SqlSmallParser.IIF) | (1 &lt;&lt; SqlSmallParser.LOG) | (1 &lt;&lt; SqlSmallParser.LOG10) | (1 &lt;&lt; SqlSmallParser.MAX) | (1 &lt;&lt; SqlSmallParser.MIN) | (1 &lt;&lt; SqlSmallParser.NEWID) | (1 &lt;&lt; SqlSmallParser.NULL) | (1 &lt;&lt; SqlSmallParser.PERCENTILE_CONT) | (1 &lt;&lt; SqlSmallParser.PERCENTILE_DISC))) != 0) or ((((_la - 64)) &amp; ~0x3f) == 0 and ((1 &lt;&lt; (_la - 64)) &amp; ((1 &lt;&lt; (SqlSmallParser.PI - 64)) | (1 &lt;&lt; (SqlSmallParser.POWER - 64)) | (1 &lt;&lt; (SqlSmallParser.RAND - 64)) | (1 &lt;&lt; (SqlSmallParser.RANDOM - 64)) | (1 &lt;&lt; (SqlSmallParser.RANK - 64)) | (1 &lt;&lt; (SqlSmallParser.ROUND - 64)) | (1 &lt;&lt; (SqlSmallParser.ROW_NUMBER - 64)) | (1 &lt;&lt; (SqlSmallParser.SIGN - 64)) | (1 &lt;&lt; (SqlSmallParser.SIN - 64)) | (1 &lt;&lt; (SqlSmallParser.SQRT - 64)) | (1 &lt;&lt; (SqlSmallParser.SQUARE - 64)) | (1 &lt;&lt; (SqlSmallParser.STD - 64)) | (1 &lt;&lt; (SqlSmallParser.STDDEV - 64)) | (1 &lt;&lt; (SqlSmallParser.SUM - 64)) | (1 &lt;&lt; (SqlSmallParser.TAN - 64)) | (1 &lt;&lt; (SqlSmallParser.TRUE - 64)) | (1 &lt;&lt; (SqlSmallParser.VAR - 64)) | (1 &lt;&lt; (SqlSmallParser.VARIANCE - 64)) | (1 &lt;&lt; (SqlSmallParser.MINUS - 64)) | (1 &lt;&lt; (SqlSmallParser.ASTERISK - 64)) | (1 &lt;&lt; (SqlSmallParser.STRING - 64)) | (1 &lt;&lt; (SqlSmallParser.INTEGER_VALUE - 64)) | (1 &lt;&lt; (SqlSmallParser.DECIMAL_VALUE - 64)) | (1 &lt;&lt; (SqlSmallParser.QN2 - 64)) | (1 &lt;&lt; (SqlSmallParser.IDENT - 64)))) != 0):
                self.state = 276
                localctx.baseCaseExpr = self.expression(0)


            self.state = 280 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 279
                self.whenExpression()
                self.state = 282 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==SqlSmallParser.WHEN):
                    break

            self.state = 286
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.ELSE:
                self.state = 284
                self.match(SqlSmallParser.ELSE)
                self.state = 285
                localctx.elseExpr = self.expression(0)


            self.state = 288
            self.match(SqlSmallParser.END)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NamedExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext

        def expression(self):
            return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,0)


        def AS(self):
            return self.getToken(SqlSmallParser.AS, 0)

        def identifier(self):
            return self.getTypedRuleContext(SqlSmallParser.IdentifierContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_namedExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterNamedExpression&#34; ):
                listener.enterNamedExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitNamedExpression&#34; ):
                listener.exitNamedExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitNamedExpression&#34; ):
                return visitor.visitNamedExpression(self)
            else:
                return visitor.visitChildren(self)




    def namedExpression(self):

        localctx = SqlSmallParser.NamedExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_namedExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 290
            self.expression(0)
            self.state = 293
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.AS:
                self.state = 291
                self.match(SqlSmallParser.AS)
                self.state = 292
                localctx.name = self.identifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NamedExpressionSeqContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def namedExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.NamedExpressionContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.NamedExpressionContext,i)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_namedExpressionSeq

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterNamedExpressionSeq&#34; ):
                listener.enterNamedExpressionSeq(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitNamedExpressionSeq&#34; ):
                listener.exitNamedExpressionSeq(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitNamedExpressionSeq&#34; ):
                return visitor.visitNamedExpressionSeq(self)
            else:
                return visitor.visitChildren(self)




    def namedExpressionSeq(self):

        localctx = SqlSmallParser.NamedExpressionSeqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_namedExpressionSeq)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 295
            self.namedExpression()
            self.state = 300
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SqlSmallParser.T__3:
                self.state = 296
                self.match(SqlSmallParser.T__3)
                self.state = 297
                self.namedExpression()
                self.state = 302
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhenExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.baseBoolExpr = None # BooleanExpressionContext
            self.baseWhenExpr = None # ExpressionContext
            self.thenExpr = None # ExpressionContext

        def WHEN(self):
            return self.getToken(SqlSmallParser.WHEN, 0)

        def THEN(self):
            return self.getToken(SqlSmallParser.THEN, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,i)


        def booleanExpression(self):
            return self.getTypedRuleContext(SqlSmallParser.BooleanExpressionContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_whenExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterWhenExpression&#34; ):
                listener.enterWhenExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitWhenExpression&#34; ):
                listener.exitWhenExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitWhenExpression&#34; ):
                return visitor.visitWhenExpression(self)
            else:
                return visitor.visitChildren(self)




    def whenExpression(self):

        localctx = SqlSmallParser.WhenExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_whenExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 303
            self.match(SqlSmallParser.WHEN)
            self.state = 306
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,37,self._ctx)
            if la_ == 1:
                self.state = 304
                localctx.baseBoolExpr = self.booleanExpression(0)
                pass

            elif la_ == 2:
                self.state = 305
                localctx.baseWhenExpr = self.expression(0)
                pass


            self.state = 308
            self.match(SqlSmallParser.THEN)
            self.state = 309
            localctx.thenExpr = self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlSmallParser.RULE_expression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class AddContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.ExpressionContext
            super().__init__(parser)
            self.left = None # ExpressionContext
            self.op = None # Token
            self.right = None # ExpressionContext
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,i)

        def PLUS(self):
            return self.getToken(SqlSmallParser.PLUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterAdd&#34; ):
                listener.enterAdd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitAdd&#34; ):
                listener.exitAdd(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitAdd&#34; ):
                return visitor.visitAdd(self)
            else:
                return visitor.visitChildren(self)


    class SubtractContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.ExpressionContext
            super().__init__(parser)
            self.left = None # ExpressionContext
            self.op = None # Token
            self.right = None # ExpressionContext
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,i)

        def MINUS(self):
            return self.getToken(SqlSmallParser.MINUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterSubtract&#34; ):
                listener.enterSubtract(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitSubtract&#34; ):
                listener.exitSubtract(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitSubtract&#34; ):
                return visitor.visitSubtract(self)
            else:
                return visitor.visitChildren(self)


    class NestedExprContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterNestedExpr&#34; ):
                listener.enterNestedExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitNestedExpr&#34; ):
                listener.exitNestedExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitNestedExpr&#34; ):
                return visitor.visitNestedExpr(self)
            else:
                return visitor.visitChildren(self)


    class SubqueryExprContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expressionSubquery(self):
            return self.getTypedRuleContext(SqlSmallParser.ExpressionSubqueryContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterSubqueryExpr&#34; ):
                listener.enterSubqueryExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitSubqueryExpr&#34; ):
                listener.exitSubqueryExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitSubqueryExpr&#34; ):
                return visitor.visitSubqueryExpr(self)
            else:
                return visitor.visitChildren(self)


    class AllExprContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def allExpression(self):
            return self.getTypedRuleContext(SqlSmallParser.AllExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterAllExpr&#34; ):
                listener.enterAllExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitAllExpr&#34; ):
                listener.exitAllExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitAllExpr&#34; ):
                return visitor.visitAllExpr(self)
            else:
                return visitor.visitChildren(self)


    class FunctionExprContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def functionExpression(self):
            return self.getTypedRuleContext(SqlSmallParser.FunctionExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterFunctionExpr&#34; ):
                listener.enterFunctionExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitFunctionExpr&#34; ):
                listener.exitFunctionExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitFunctionExpr&#34; ):
                return visitor.visitFunctionExpr(self)
            else:
                return visitor.visitChildren(self)


    class RankFunctionContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def rankingFunction(self):
            return self.getTypedRuleContext(SqlSmallParser.RankingFunctionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterRankFunction&#34; ):
                listener.enterRankFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitRankFunction&#34; ):
                listener.exitRankFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitRankFunction&#34; ):
                return visitor.visitRankFunction(self)
            else:
                return visitor.visitChildren(self)


    class LiteralExprContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def literal(self):
            return self.getTypedRuleContext(SqlSmallParser.LiteralContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterLiteralExpr&#34; ):
                listener.enterLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitLiteralExpr&#34; ):
                listener.exitLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitLiteralExpr&#34; ):
                return visitor.visitLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class DivideContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.ExpressionContext
            super().__init__(parser)
            self.left = None # ExpressionContext
            self.op = None # Token
            self.right = None # ExpressionContext
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,i)

        def SLASH(self):
            return self.getToken(SqlSmallParser.SLASH, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterDivide&#34; ):
                listener.enterDivide(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitDivide&#34; ):
                listener.exitDivide(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitDivide&#34; ):
                return visitor.visitDivide(self)
            else:
                return visitor.visitChildren(self)


    class CaseExprContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def caseExpression(self):
            return self.getTypedRuleContext(SqlSmallParser.CaseExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterCaseExpr&#34; ):
                listener.enterCaseExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitCaseExpr&#34; ):
                listener.exitCaseExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitCaseExpr&#34; ):
                return visitor.visitCaseExpr(self)
            else:
                return visitor.visitChildren(self)


    class MultiplyContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.ExpressionContext
            super().__init__(parser)
            self.left = None # ExpressionContext
            self.op = None # Token
            self.right = None # ExpressionContext
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,i)

        def ASTERISK(self):
            return self.getToken(SqlSmallParser.ASTERISK, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterMultiply&#34; ):
                listener.enterMultiply(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitMultiply&#34; ):
                listener.exitMultiply(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitMultiply&#34; ):
                return visitor.visitMultiply(self)
            else:
                return visitor.visitChildren(self)


    class ModuloContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.ExpressionContext
            super().__init__(parser)
            self.left = None # ExpressionContext
            self.op = None # Token
            self.right = None # ExpressionContext
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,i)

        def PERCENT(self):
            return self.getToken(SqlSmallParser.PERCENT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterModulo&#34; ):
                listener.enterModulo(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitModulo&#34; ):
                listener.exitModulo(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitModulo&#34; ):
                return visitor.visitModulo(self)
            else:
                return visitor.visitChildren(self)


    class ColumnNameContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.ExpressionContext
            super().__init__(parser)
            self.name = None # QualifiedColumnNameContext
            self.copyFrom(ctx)

        def qualifiedColumnName(self):
            return self.getTypedRuleContext(SqlSmallParser.QualifiedColumnNameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterColumnName&#34; ):
                listener.enterColumnName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitColumnName&#34; ):
                listener.exitColumnName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitColumnName&#34; ):
                return visitor.visitColumnName(self)
            else:
                return visitor.visitChildren(self)



    def expression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = SqlSmallParser.ExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 46
        self.enterRecursionRule(localctx, 46, self.RULE_expression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 323
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,38,self._ctx)
            if la_ == 1:
                localctx = SqlSmallParser.ColumnNameContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 312
                localctx.name = self.qualifiedColumnName()
                pass

            elif la_ == 2:
                localctx = SqlSmallParser.CaseExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 313
                self.caseExpression()
                pass

            elif la_ == 3:
                localctx = SqlSmallParser.AllExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 314
                self.allExpression()
                pass

            elif la_ == 4:
                localctx = SqlSmallParser.LiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 315
                self.literal()
                pass

            elif la_ == 5:
                localctx = SqlSmallParser.RankFunctionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 316
                self.rankingFunction()
                pass

            elif la_ == 6:
                localctx = SqlSmallParser.FunctionExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 317
                self.functionExpression()
                pass

            elif la_ == 7:
                localctx = SqlSmallParser.SubqueryExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 318
                self.expressionSubquery()
                pass

            elif la_ == 8:
                localctx = SqlSmallParser.NestedExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 319
                self.match(SqlSmallParser.T__1)
                self.state = 320
                self.expression(0)
                self.state = 321
                self.match(SqlSmallParser.T__2)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 342
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,40,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 340
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,39,self._ctx)
                    if la_ == 1:
                        localctx = SqlSmallParser.MultiplyContext(self, SqlSmallParser.ExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 325
                        if not self.precpred(self._ctx, 12):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, &#34;self.precpred(self._ctx, 12)&#34;)
                        self.state = 326
                        localctx.op = self.match(SqlSmallParser.ASTERISK)
                        self.state = 327
                        localctx.right = self.expression(13)
                        pass

                    elif la_ == 2:
                        localctx = SqlSmallParser.DivideContext(self, SqlSmallParser.ExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 328
                        if not self.precpred(self._ctx, 11):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, &#34;self.precpred(self._ctx, 11)&#34;)
                        self.state = 329
                        localctx.op = self.match(SqlSmallParser.SLASH)
                        self.state = 330
                        localctx.right = self.expression(12)
                        pass

                    elif la_ == 3:
                        localctx = SqlSmallParser.ModuloContext(self, SqlSmallParser.ExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 331
                        if not self.precpred(self._ctx, 10):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, &#34;self.precpred(self._ctx, 10)&#34;)
                        self.state = 332
                        localctx.op = self.match(SqlSmallParser.PERCENT)
                        self.state = 333
                        localctx.right = self.expression(11)
                        pass

                    elif la_ == 4:
                        localctx = SqlSmallParser.AddContext(self, SqlSmallParser.ExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 334
                        if not self.precpred(self._ctx, 9):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, &#34;self.precpred(self._ctx, 9)&#34;)
                        self.state = 335
                        localctx.op = self.match(SqlSmallParser.PLUS)
                        self.state = 336
                        localctx.right = self.expression(10)
                        pass

                    elif la_ == 5:
                        localctx = SqlSmallParser.SubtractContext(self, SqlSmallParser.ExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 337
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, &#34;self.precpred(self._ctx, 8)&#34;)
                        self.state = 338
                        localctx.op = self.match(SqlSmallParser.MINUS)
                        self.state = 339
                        localctx.right = self.expression(9)
                        pass

             
                self.state = 344
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,40,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class AllExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASTERISK(self):
            return self.getToken(SqlSmallParser.ASTERISK, 0)

        def identifier(self):
            return self.getTypedRuleContext(SqlSmallParser.IdentifierContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_allExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterAllExpression&#34; ):
                listener.enterAllExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitAllExpression&#34; ):
                listener.exitAllExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitAllExpression&#34; ):
                return visitor.visitAllExpression(self)
            else:
                return visitor.visitChildren(self)




    def allExpression(self):

        localctx = SqlSmallParser.AllExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_allExpression)
        try:
            self.state = 350
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlSmallParser.ASTERISK]:
                self.enterOuterAlt(localctx, 1)
                self.state = 345
                self.match(SqlSmallParser.ASTERISK)
                pass
            elif token in [SqlSmallParser.IDENT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 346
                self.identifier()
                self.state = 347
                self.match(SqlSmallParser.T__4)
                self.state = 348
                self.match(SqlSmallParser.ASTERISK)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlSmallParser.RULE_literal

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class NullLiteralContext(LiteralContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.LiteralContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NULL(self):
            return self.getToken(SqlSmallParser.NULL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterNullLiteral&#34; ):
                listener.enterNullLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitNullLiteral&#34; ):
                listener.exitNullLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitNullLiteral&#34; ):
                return visitor.visitNullLiteral(self)
            else:
                return visitor.visitChildren(self)


    class FalseLiteralContext(LiteralContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.LiteralContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def FALSE(self):
            return self.getToken(SqlSmallParser.FALSE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterFalseLiteral&#34; ):
                listener.enterFalseLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitFalseLiteral&#34; ):
                listener.exitFalseLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitFalseLiteral&#34; ):
                return visitor.visitFalseLiteral(self)
            else:
                return visitor.visitChildren(self)


    class StringLiteralContext(LiteralContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.LiteralContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def STRING(self):
            return self.getToken(SqlSmallParser.STRING, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterStringLiteral&#34; ):
                listener.enterStringLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitStringLiteral&#34; ):
                listener.exitStringLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitStringLiteral&#34; ):
                return visitor.visitStringLiteral(self)
            else:
                return visitor.visitChildren(self)


    class TrueLiteralContext(LiteralContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.LiteralContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TRUE(self):
            return self.getToken(SqlSmallParser.TRUE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterTrueLiteral&#34; ):
                listener.enterTrueLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitTrueLiteral&#34; ):
                listener.exitTrueLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitTrueLiteral&#34; ):
                return visitor.visitTrueLiteral(self)
            else:
                return visitor.visitChildren(self)


    class NumberLiteralContext(LiteralContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.LiteralContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def number(self):
            return self.getTypedRuleContext(SqlSmallParser.NumberContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterNumberLiteral&#34; ):
                listener.enterNumberLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitNumberLiteral&#34; ):
                listener.exitNumberLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitNumberLiteral&#34; ):
                return visitor.visitNumberLiteral(self)
            else:
                return visitor.visitChildren(self)



    def literal(self):

        localctx = SqlSmallParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_literal)
        try:
            self.state = 357
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlSmallParser.STRING]:
                localctx = SqlSmallParser.StringLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 352
                self.match(SqlSmallParser.STRING)
                pass
            elif token in [SqlSmallParser.MINUS, SqlSmallParser.INTEGER_VALUE, SqlSmallParser.DECIMAL_VALUE]:
                localctx = SqlSmallParser.NumberLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 353
                self.number()
                pass
            elif token in [SqlSmallParser.TRUE]:
                localctx = SqlSmallParser.TrueLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 354
                self.match(SqlSmallParser.TRUE)
                pass
            elif token in [SqlSmallParser.FALSE]:
                localctx = SqlSmallParser.FalseLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 355
                self.match(SqlSmallParser.FALSE)
                pass
            elif token in [SqlSmallParser.NULL]:
                localctx = SqlSmallParser.NullLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 356
                self.match(SqlSmallParser.NULL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlSmallParser.RULE_booleanExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class LogicalNotContext(BooleanExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.BooleanExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NOT(self):
            return self.getToken(SqlSmallParser.NOT, 0)
        def booleanExpression(self):
            return self.getTypedRuleContext(SqlSmallParser.BooleanExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterLogicalNot&#34; ):
                listener.enterLogicalNot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitLogicalNot&#34; ):
                listener.exitLogicalNot(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitLogicalNot&#34; ):
                return visitor.visitLogicalNot(self)
            else:
                return visitor.visitChildren(self)


    class ComparisonContext(BooleanExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.BooleanExpressionContext
            super().__init__(parser)
            self.left = None # ExpressionContext
            self.op = None # ComparisonOperatorContext
            self.right = None # ExpressionContext
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,i)

        def comparisonOperator(self):
            return self.getTypedRuleContext(SqlSmallParser.ComparisonOperatorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterComparison&#34; ):
                listener.enterComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitComparison&#34; ):
                listener.exitComparison(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitComparison&#34; ):
                return visitor.visitComparison(self)
            else:
                return visitor.visitChildren(self)


    class PredicatedContext(BooleanExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.BooleanExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,0)

        def predicate(self):
            return self.getTypedRuleContext(SqlSmallParser.PredicateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterPredicated&#34; ):
                listener.enterPredicated(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitPredicated&#34; ):
                listener.exitPredicated(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitPredicated&#34; ):
                return visitor.visitPredicated(self)
            else:
                return visitor.visitChildren(self)


    class ConjunctionContext(BooleanExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.BooleanExpressionContext
            super().__init__(parser)
            self.left = None # BooleanExpressionContext
            self.right = None # BooleanExpressionContext
            self.copyFrom(ctx)

        def AND(self):
            return self.getToken(SqlSmallParser.AND, 0)
        def booleanExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.BooleanExpressionContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.BooleanExpressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterConjunction&#34; ):
                listener.enterConjunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitConjunction&#34; ):
                listener.exitConjunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitConjunction&#34; ):
                return visitor.visitConjunction(self)
            else:
                return visitor.visitChildren(self)


    class DisjunctionContext(BooleanExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.BooleanExpressionContext
            super().__init__(parser)
            self.left = None # BooleanExpressionContext
            self.right = None # BooleanExpressionContext
            self.copyFrom(ctx)

        def OR(self):
            return self.getToken(SqlSmallParser.OR, 0)
        def booleanExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.BooleanExpressionContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.BooleanExpressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterDisjunction&#34; ):
                listener.enterDisjunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitDisjunction&#34; ):
                listener.exitDisjunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitDisjunction&#34; ):
                return visitor.visitDisjunction(self)
            else:
                return visitor.visitChildren(self)


    class NestedBooleanContext(BooleanExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.BooleanExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def booleanExpression(self):
            return self.getTypedRuleContext(SqlSmallParser.BooleanExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterNestedBoolean&#34; ):
                listener.enterNestedBoolean(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitNestedBoolean&#34; ):
                listener.exitNestedBoolean(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitNestedBoolean&#34; ):
                return visitor.visitNestedBoolean(self)
            else:
                return visitor.visitChildren(self)



    def booleanExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = SqlSmallParser.BooleanExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 52
        self.enterRecursionRule(localctx, 52, self.RULE_booleanExpression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 373
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,43,self._ctx)
            if la_ == 1:
                localctx = SqlSmallParser.LogicalNotContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 360
                self.match(SqlSmallParser.NOT)
                self.state = 361
                self.booleanExpression(6)
                pass

            elif la_ == 2:
                localctx = SqlSmallParser.ComparisonContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 362
                localctx.left = self.expression(0)
                self.state = 363
                localctx.op = self.comparisonOperator()
                self.state = 364
                localctx.right = self.expression(0)
                pass

            elif la_ == 3:
                localctx = SqlSmallParser.NestedBooleanContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 366
                self.match(SqlSmallParser.T__1)
                self.state = 367
                self.booleanExpression(0)
                self.state = 368
                self.match(SqlSmallParser.T__2)
                pass

            elif la_ == 4:
                localctx = SqlSmallParser.PredicatedContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 370
                self.expression(0)
                self.state = 371
                self.predicate()
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 383
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,45,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 381
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,44,self._ctx)
                    if la_ == 1:
                        localctx = SqlSmallParser.ConjunctionContext(self, SqlSmallParser.BooleanExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_booleanExpression)
                        self.state = 375
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, &#34;self.precpred(self._ctx, 4)&#34;)
                        self.state = 376
                        self.match(SqlSmallParser.AND)
                        self.state = 377
                        localctx.right = self.booleanExpression(5)
                        pass

                    elif la_ == 2:
                        localctx = SqlSmallParser.DisjunctionContext(self, SqlSmallParser.BooleanExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_booleanExpression)
                        self.state = 378
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, &#34;self.precpred(self._ctx, 3)&#34;)
                        self.state = 379
                        self.match(SqlSmallParser.OR)
                        self.state = 380
                        localctx.right = self.booleanExpression(4)
                        pass

             
                self.state = 385
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,45,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class PredicateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlSmallParser.RULE_predicate

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class InConditionContext(PredicateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.PredicateContext
            super().__init__(parser)
            self.kind = None # Token
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,i)

        def IN(self):
            return self.getToken(SqlSmallParser.IN, 0)
        def NOT(self):
            return self.getToken(SqlSmallParser.NOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterInCondition&#34; ):
                listener.enterInCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitInCondition&#34; ):
                listener.exitInCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitInCondition&#34; ):
                return visitor.visitInCondition(self)
            else:
                return visitor.visitChildren(self)


    class IsConditionContext(PredicateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.PredicateContext
            super().__init__(parser)
            self.kind = None # Token
            self.copyFrom(ctx)

        def IS(self):
            return self.getToken(SqlSmallParser.IS, 0)
        def NULL(self):
            return self.getToken(SqlSmallParser.NULL, 0)
        def TRUE(self):
            return self.getToken(SqlSmallParser.TRUE, 0)
        def FALSE(self):
            return self.getToken(SqlSmallParser.FALSE, 0)
        def NOT(self):
            return self.getToken(SqlSmallParser.NOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterIsCondition&#34; ):
                listener.enterIsCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitIsCondition&#34; ):
                listener.exitIsCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitIsCondition&#34; ):
                return visitor.visitIsCondition(self)
            else:
                return visitor.visitChildren(self)


    class BetweenConditionContext(PredicateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.PredicateContext
            super().__init__(parser)
            self.kind = None # Token
            self.lower = None # ExpressionContext
            self.upper = None # ExpressionContext
            self.copyFrom(ctx)

        def AND(self):
            return self.getToken(SqlSmallParser.AND, 0)
        def BETWEEN(self):
            return self.getToken(SqlSmallParser.BETWEEN, 0)
        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,i)

        def NOT(self):
            return self.getToken(SqlSmallParser.NOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterBetweenCondition&#34; ):
                listener.enterBetweenCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitBetweenCondition&#34; ):
                listener.exitBetweenCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitBetweenCondition&#34; ):
                return visitor.visitBetweenCondition(self)
            else:
                return visitor.visitChildren(self)



    def predicate(self):

        localctx = SqlSmallParser.PredicateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_predicate)
        self._la = 0 # Token type
        try:
            self.state = 414
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,50,self._ctx)
            if la_ == 1:
                localctx = SqlSmallParser.BetweenConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 387
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlSmallParser.NOT:
                    self.state = 386
                    self.match(SqlSmallParser.NOT)


                self.state = 389
                localctx.kind = self.match(SqlSmallParser.BETWEEN)
                self.state = 390
                localctx.lower = self.expression(0)
                self.state = 391
                self.match(SqlSmallParser.AND)
                self.state = 392
                localctx.upper = self.expression(0)
                pass

            elif la_ == 2:
                localctx = SqlSmallParser.InConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 395
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlSmallParser.NOT:
                    self.state = 394
                    self.match(SqlSmallParser.NOT)


                self.state = 397
                localctx.kind = self.match(SqlSmallParser.IN)
                self.state = 398
                self.match(SqlSmallParser.T__1)
                self.state = 399
                self.expression(0)
                self.state = 404
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==SqlSmallParser.T__3:
                    self.state = 400
                    self.match(SqlSmallParser.T__3)
                    self.state = 401
                    self.expression(0)
                    self.state = 406
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 407
                self.match(SqlSmallParser.T__2)
                pass

            elif la_ == 3:
                localctx = SqlSmallParser.IsConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 409
                self.match(SqlSmallParser.IS)
                self.state = 411
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlSmallParser.NOT:
                    self.state = 410
                    self.match(SqlSmallParser.NOT)


                self.state = 413
                localctx.kind = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 33)) &amp; ~0x3f) == 0 and ((1 &lt;&lt; (_la - 33)) &amp; ((1 &lt;&lt; (SqlSmallParser.FALSE - 33)) | (1 &lt;&lt; (SqlSmallParser.NULL - 33)) | (1 &lt;&lt; (SqlSmallParser.TRUE - 33)))) != 0)):
                    localctx.kind = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonOperatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQ(self):
            return self.getToken(SqlSmallParser.EQ, 0)

        def NEQ(self):
            return self.getToken(SqlSmallParser.NEQ, 0)

        def NEQJ(self):
            return self.getToken(SqlSmallParser.NEQJ, 0)

        def LT(self):
            return self.getToken(SqlSmallParser.LT, 0)

        def LTE(self):
            return self.getToken(SqlSmallParser.LTE, 0)

        def GT(self):
            return self.getToken(SqlSmallParser.GT, 0)

        def GTE(self):
            return self.getToken(SqlSmallParser.GTE, 0)

        def NSEQ(self):
            return self.getToken(SqlSmallParser.NSEQ, 0)

        def getRuleIndex(self):
            return SqlSmallParser.RULE_comparisonOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterComparisonOperator&#34; ):
                listener.enterComparisonOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitComparisonOperator&#34; ):
                listener.exitComparisonOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitComparisonOperator&#34; ):
                return visitor.visitComparisonOperator(self)
            else:
                return visitor.visitChildren(self)




    def comparisonOperator(self):

        localctx = SqlSmallParser.ComparisonOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_comparisonOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 416
            _la = self._input.LA(1)
            if not(((((_la - 94)) &amp; ~0x3f) == 0 and ((1 &lt;&lt; (_la - 94)) &amp; ((1 &lt;&lt; (SqlSmallParser.EQ - 94)) | (1 &lt;&lt; (SqlSmallParser.NSEQ - 94)) | (1 &lt;&lt; (SqlSmallParser.NEQ - 94)) | (1 &lt;&lt; (SqlSmallParser.NEQJ - 94)) | (1 &lt;&lt; (SqlSmallParser.LT - 94)) | (1 &lt;&lt; (SqlSmallParser.LTE - 94)) | (1 &lt;&lt; (SqlSmallParser.GT - 94)) | (1 &lt;&lt; (SqlSmallParser.GTE - 94)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanValueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUE(self):
            return self.getToken(SqlSmallParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(SqlSmallParser.FALSE, 0)

        def getRuleIndex(self):
            return SqlSmallParser.RULE_booleanValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterBooleanValue&#34; ):
                listener.enterBooleanValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitBooleanValue&#34; ):
                listener.exitBooleanValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitBooleanValue&#34; ):
                return visitor.visitBooleanValue(self)
            else:
                return visitor.visitChildren(self)




    def booleanValue(self):

        localctx = SqlSmallParser.BooleanValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_booleanValue)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 418
            _la = self._input.LA(1)
            if not(_la==SqlSmallParser.FALSE or _la==SqlSmallParser.TRUE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlSmallParser.RULE_functionExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class IifFuncContext(FunctionExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.FunctionExpressionContext
            super().__init__(parser)
            self.test = None # BooleanExpressionContext
            self.yes = None # ExpressionContext
            self.no = None # ExpressionContext
            self.copyFrom(ctx)

        def IIF(self):
            return self.getToken(SqlSmallParser.IIF, 0)
        def booleanExpression(self):
            return self.getTypedRuleContext(SqlSmallParser.BooleanExpressionContext,0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterIifFunc&#34; ):
                listener.enterIifFunc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitIifFunc&#34; ):
                listener.exitIifFunc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitIifFunc&#34; ):
                return visitor.visitIifFunc(self)
            else:
                return visitor.visitChildren(self)


    class PowerFuncContext(FunctionExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.FunctionExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def powerFunction(self):
            return self.getTypedRuleContext(SqlSmallParser.PowerFunctionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterPowerFunc&#34; ):
                listener.enterPowerFunc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitPowerFunc&#34; ):
                listener.exitPowerFunc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitPowerFunc&#34; ):
                return visitor.visitPowerFunc(self)
            else:
                return visitor.visitChildren(self)


    class ChooseFuncContext(FunctionExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.FunctionExpressionContext
            super().__init__(parser)
            self.index = None # ExpressionContext
            self.copyFrom(ctx)

        def CHOOSE(self):
            return self.getToken(SqlSmallParser.CHOOSE, 0)
        def expression(self):
            return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,0)

        def literal(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.LiteralContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.LiteralContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterChooseFunc&#34; ):
                listener.enterChooseFunc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitChooseFunc&#34; ):
                listener.exitChooseFunc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitChooseFunc&#34; ):
                return visitor.visitChooseFunc(self)
            else:
                return visitor.visitChildren(self)


    class MathFuncContext(FunctionExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.FunctionExpressionContext
            super().__init__(parser)
            self.function = None # MathFunctionNameContext
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,0)

        def mathFunctionName(self):
            return self.getTypedRuleContext(SqlSmallParser.MathFunctionNameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterMathFunc&#34; ):
                listener.enterMathFunc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitMathFunc&#34; ):
                listener.exitMathFunc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitMathFunc&#34; ):
                return visitor.visitMathFunc(self)
            else:
                return visitor.visitChildren(self)


    class AggFuncContext(FunctionExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.FunctionExpressionContext
            super().__init__(parser)
            self.function = None # AggregateFunctionNameContext
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,0)

        def aggregateFunctionName(self):
            return self.getTypedRuleContext(SqlSmallParser.AggregateFunctionNameContext,0)

        def setQuantifier(self):
            return self.getTypedRuleContext(SqlSmallParser.SetQuantifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterAggFunc&#34; ):
                listener.enterAggFunc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitAggFunc&#34; ):
                listener.exitAggFunc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitAggFunc&#34; ):
                return visitor.visitAggFunc(self)
            else:
                return visitor.visitChildren(self)


    class BareFuncContext(FunctionExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.FunctionExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def bareFunction(self):
            return self.getTypedRuleContext(SqlSmallParser.BareFunctionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterBareFunc&#34; ):
                listener.enterBareFunc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitBareFunc&#34; ):
                listener.exitBareFunc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitBareFunc&#34; ):
                return visitor.visitBareFunc(self)
            else:
                return visitor.visitChildren(self)


    class RoundFuncContext(FunctionExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.FunctionExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def roundFunction(self):
            return self.getTypedRuleContext(SqlSmallParser.RoundFunctionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterRoundFunc&#34; ):
                listener.enterRoundFunc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitRoundFunc&#34; ):
                listener.exitRoundFunc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitRoundFunc&#34; ):
                return visitor.visitRoundFunc(self)
            else:
                return visitor.visitChildren(self)



    def functionExpression(self):

        localctx = SqlSmallParser.FunctionExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_functionExpression)
        self._la = 0 # Token type
        try:
            self.state = 456
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlSmallParser.NEWID, SqlSmallParser.PI, SqlSmallParser.RAND, SqlSmallParser.RANDOM]:
                localctx = SqlSmallParser.BareFuncContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 420
                self.bareFunction()
                pass
            elif token in [SqlSmallParser.ROUND]:
                localctx = SqlSmallParser.RoundFuncContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 421
                self.roundFunction()
                pass
            elif token in [SqlSmallParser.POWER]:
                localctx = SqlSmallParser.PowerFuncContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 422
                self.powerFunction()
                pass
            elif token in [SqlSmallParser.AVG, SqlSmallParser.COUNT, SqlSmallParser.MAX, SqlSmallParser.MIN, SqlSmallParser.PERCENTILE_CONT, SqlSmallParser.PERCENTILE_DISC, SqlSmallParser.STD, SqlSmallParser.STDDEV, SqlSmallParser.SUM, SqlSmallParser.VAR, SqlSmallParser.VARIANCE]:
                localctx = SqlSmallParser.AggFuncContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 423
                localctx.function = self.aggregateFunctionName()
                self.state = 424
                self.match(SqlSmallParser.T__1)
                self.state = 426
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlSmallParser.ALL or _la==SqlSmallParser.DISTINCT or _la==SqlSmallParser.TOP:
                    self.state = 425
                    self.setQuantifier()


                self.state = 428
                self.expression(0)
                self.state = 429
                self.match(SqlSmallParser.T__2)
                pass
            elif token in [SqlSmallParser.ABS, SqlSmallParser.ACOS, SqlSmallParser.ASIN, SqlSmallParser.ATAN, SqlSmallParser.CEILING, SqlSmallParser.COS, SqlSmallParser.DEGREES, SqlSmallParser.EXP, SqlSmallParser.FLOOR, SqlSmallParser.LOG, SqlSmallParser.LOG10, SqlSmallParser.SIGN, SqlSmallParser.SIN, SqlSmallParser.SQRT, SqlSmallParser.SQUARE, SqlSmallParser.TAN]:
                localctx = SqlSmallParser.MathFuncContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 431
                localctx.function = self.mathFunctionName()
                self.state = 432
                self.match(SqlSmallParser.T__1)
                self.state = 433
                self.expression(0)
                self.state = 434
                self.match(SqlSmallParser.T__2)
                pass
            elif token in [SqlSmallParser.IIF]:
                localctx = SqlSmallParser.IifFuncContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 436
                self.match(SqlSmallParser.IIF)
                self.state = 437
                self.match(SqlSmallParser.T__1)
                self.state = 438
                localctx.test = self.booleanExpression(0)
                self.state = 439
                self.match(SqlSmallParser.T__3)
                self.state = 440
                localctx.yes = self.expression(0)
                self.state = 441
                self.match(SqlSmallParser.T__3)
                self.state = 442
                localctx.no = self.expression(0)
                self.state = 443
                self.match(SqlSmallParser.T__2)
                pass
            elif token in [SqlSmallParser.CHOOSE]:
                localctx = SqlSmallParser.ChooseFuncContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 445
                self.match(SqlSmallParser.CHOOSE)
                self.state = 446
                self.match(SqlSmallParser.T__1)
                self.state = 447
                localctx.index = self.expression(0)
                self.state = 450 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 448
                    self.match(SqlSmallParser.T__3)
                    self.state = 449
                    self.literal()
                    self.state = 452 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==SqlSmallParser.T__3):
                        break

                self.state = 454
                self.match(SqlSmallParser.T__2)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BareFunctionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.function = None # BareFunctionNameContext

        def bareFunctionName(self):
            return self.getTypedRuleContext(SqlSmallParser.BareFunctionNameContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_bareFunction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterBareFunction&#34; ):
                listener.enterBareFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitBareFunction&#34; ):
                listener.exitBareFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitBareFunction&#34; ):
                return visitor.visitBareFunction(self)
            else:
                return visitor.visitChildren(self)




    def bareFunction(self):

        localctx = SqlSmallParser.BareFunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_bareFunction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 458
            localctx.function = self.bareFunctionName()
            self.state = 459
            self.match(SqlSmallParser.T__1)
            self.state = 460
            self.match(SqlSmallParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RankingFunctionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.function = None # RankingFunctionNameContext

        def overClause(self):
            return self.getTypedRuleContext(SqlSmallParser.OverClauseContext,0)


        def rankingFunctionName(self):
            return self.getTypedRuleContext(SqlSmallParser.RankingFunctionNameContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_rankingFunction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterRankingFunction&#34; ):
                listener.enterRankingFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitRankingFunction&#34; ):
                listener.exitRankingFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitRankingFunction&#34; ):
                return visitor.visitRankingFunction(self)
            else:
                return visitor.visitChildren(self)




    def rankingFunction(self):

        localctx = SqlSmallParser.RankingFunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_rankingFunction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 462
            localctx.function = self.rankingFunctionName()
            self.state = 463
            self.match(SqlSmallParser.T__1)
            self.state = 464
            self.match(SqlSmallParser.T__2)
            self.state = 465
            self.overClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoundFunctionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.digits = None # NumberContext

        def ROUND(self):
            return self.getToken(SqlSmallParser.ROUND, 0)

        def expression(self):
            return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,0)


        def number(self):
            return self.getTypedRuleContext(SqlSmallParser.NumberContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_roundFunction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterRoundFunction&#34; ):
                listener.enterRoundFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitRoundFunction&#34; ):
                listener.exitRoundFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitRoundFunction&#34; ):
                return visitor.visitRoundFunction(self)
            else:
                return visitor.visitChildren(self)




    def roundFunction(self):

        localctx = SqlSmallParser.RoundFunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_roundFunction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 467
            self.match(SqlSmallParser.ROUND)
            self.state = 468
            self.match(SqlSmallParser.T__1)
            self.state = 469
            self.expression(0)
            self.state = 470
            self.match(SqlSmallParser.T__3)
            self.state = 471
            localctx.digits = self.number()
            self.state = 472
            self.match(SqlSmallParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PowerFunctionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def POWER(self):
            return self.getToken(SqlSmallParser.POWER, 0)

        def expression(self):
            return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,0)


        def number(self):
            return self.getTypedRuleContext(SqlSmallParser.NumberContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_powerFunction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterPowerFunction&#34; ):
                listener.enterPowerFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitPowerFunction&#34; ):
                listener.exitPowerFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitPowerFunction&#34; ):
                return visitor.visitPowerFunction(self)
            else:
                return visitor.visitChildren(self)




    def powerFunction(self):

        localctx = SqlSmallParser.PowerFunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_powerFunction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 474
            self.match(SqlSmallParser.POWER)
            self.state = 475
            self.match(SqlSmallParser.T__1)
            self.state = 476
            self.expression(0)
            self.state = 477
            self.match(SqlSmallParser.T__3)
            self.state = 478
            self.number()
            self.state = 479
            self.match(SqlSmallParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RankingFunctionNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ROW_NUMBER(self):
            return self.getToken(SqlSmallParser.ROW_NUMBER, 0)

        def RANK(self):
            return self.getToken(SqlSmallParser.RANK, 0)

        def DENSE_RANK(self):
            return self.getToken(SqlSmallParser.DENSE_RANK, 0)

        def getRuleIndex(self):
            return SqlSmallParser.RULE_rankingFunctionName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterRankingFunctionName&#34; ):
                listener.enterRankingFunctionName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitRankingFunctionName&#34; ):
                listener.exitRankingFunctionName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitRankingFunctionName&#34; ):
                return visitor.visitRankingFunctionName(self)
            else:
                return visitor.visitChildren(self)




    def rankingFunctionName(self):

        localctx = SqlSmallParser.RankingFunctionNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_rankingFunctionName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 481
            _la = self._input.LA(1)
            if not(((((_la - 26)) &amp; ~0x3f) == 0 and ((1 &lt;&lt; (_la - 26)) &amp; ((1 &lt;&lt; (SqlSmallParser.DENSE_RANK - 26)) | (1 &lt;&lt; (SqlSmallParser.RANK - 26)) | (1 &lt;&lt; (SqlSmallParser.ROW_NUMBER - 26)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregateFunctionNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COUNT(self):
            return self.getToken(SqlSmallParser.COUNT, 0)

        def SUM(self):
            return self.getToken(SqlSmallParser.SUM, 0)

        def AVG(self):
            return self.getToken(SqlSmallParser.AVG, 0)

        def VAR(self):
            return self.getToken(SqlSmallParser.VAR, 0)

        def VARIANCE(self):
            return self.getToken(SqlSmallParser.VARIANCE, 0)

        def STD(self):
            return self.getToken(SqlSmallParser.STD, 0)

        def STDDEV(self):
            return self.getToken(SqlSmallParser.STDDEV, 0)

        def MIN(self):
            return self.getToken(SqlSmallParser.MIN, 0)

        def MAX(self):
            return self.getToken(SqlSmallParser.MAX, 0)

        def PERCENTILE_DISC(self):
            return self.getToken(SqlSmallParser.PERCENTILE_DISC, 0)

        def PERCENTILE_CONT(self):
            return self.getToken(SqlSmallParser.PERCENTILE_CONT, 0)

        def getRuleIndex(self):
            return SqlSmallParser.RULE_aggregateFunctionName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterAggregateFunctionName&#34; ):
                listener.enterAggregateFunctionName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitAggregateFunctionName&#34; ):
                listener.exitAggregateFunctionName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitAggregateFunctionName&#34; ):
                return visitor.visitAggregateFunctionName(self)
            else:
                return visitor.visitChildren(self)




    def aggregateFunctionName(self):

        localctx = SqlSmallParser.AggregateFunctionNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_aggregateFunctionName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 483
            _la = self._input.LA(1)
            if not((((_la) &amp; ~0x3f) == 0 and ((1 &lt;&lt; _la) &amp; ((1 &lt;&lt; SqlSmallParser.AVG) | (1 &lt;&lt; SqlSmallParser.COUNT) | (1 &lt;&lt; SqlSmallParser.MAX) | (1 &lt;&lt; SqlSmallParser.MIN) | (1 &lt;&lt; SqlSmallParser.PERCENTILE_CONT) | (1 &lt;&lt; SqlSmallParser.PERCENTILE_DISC))) != 0) or ((((_la - 81)) &amp; ~0x3f) == 0 and ((1 &lt;&lt; (_la - 81)) &amp; ((1 &lt;&lt; (SqlSmallParser.STD - 81)) | (1 &lt;&lt; (SqlSmallParser.STDDEV - 81)) | (1 &lt;&lt; (SqlSmallParser.SUM - 81)) | (1 &lt;&lt; (SqlSmallParser.VAR - 81)) | (1 &lt;&lt; (SqlSmallParser.VARIANCE - 81)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MathFunctionNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ABS(self):
            return self.getToken(SqlSmallParser.ABS, 0)

        def CEILING(self):
            return self.getToken(SqlSmallParser.CEILING, 0)

        def FLOOR(self):
            return self.getToken(SqlSmallParser.FLOOR, 0)

        def SIGN(self):
            return self.getToken(SqlSmallParser.SIGN, 0)

        def SQRT(self):
            return self.getToken(SqlSmallParser.SQRT, 0)

        def SQUARE(self):
            return self.getToken(SqlSmallParser.SQUARE, 0)

        def EXP(self):
            return self.getToken(SqlSmallParser.EXP, 0)

        def LOG(self):
            return self.getToken(SqlSmallParser.LOG, 0)

        def LOG10(self):
            return self.getToken(SqlSmallParser.LOG10, 0)

        def SIN(self):
            return self.getToken(SqlSmallParser.SIN, 0)

        def COS(self):
            return self.getToken(SqlSmallParser.COS, 0)

        def TAN(self):
            return self.getToken(SqlSmallParser.TAN, 0)

        def ASIN(self):
            return self.getToken(SqlSmallParser.ASIN, 0)

        def ACOS(self):
            return self.getToken(SqlSmallParser.ACOS, 0)

        def ATAN(self):
            return self.getToken(SqlSmallParser.ATAN, 0)

        def DEGREES(self):
            return self.getToken(SqlSmallParser.DEGREES, 0)

        def getRuleIndex(self):
            return SqlSmallParser.RULE_mathFunctionName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterMathFunctionName&#34; ):
                listener.enterMathFunctionName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitMathFunctionName&#34; ):
                listener.exitMathFunctionName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitMathFunctionName&#34; ):
                return visitor.visitMathFunctionName(self)
            else:
                return visitor.visitChildren(self)




    def mathFunctionName(self):

        localctx = SqlSmallParser.MathFunctionNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_mathFunctionName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 485
            _la = self._input.LA(1)
            if not((((_la) &amp; ~0x3f) == 0 and ((1 &lt;&lt; _la) &amp; ((1 &lt;&lt; SqlSmallParser.ABS) | (1 &lt;&lt; SqlSmallParser.ACOS) | (1 &lt;&lt; SqlSmallParser.ASIN) | (1 &lt;&lt; SqlSmallParser.ATAN) | (1 &lt;&lt; SqlSmallParser.CEILING) | (1 &lt;&lt; SqlSmallParser.COS) | (1 &lt;&lt; SqlSmallParser.DEGREES) | (1 &lt;&lt; SqlSmallParser.EXP) | (1 &lt;&lt; SqlSmallParser.FLOOR) | (1 &lt;&lt; SqlSmallParser.LOG) | (1 &lt;&lt; SqlSmallParser.LOG10))) != 0) or ((((_la - 75)) &amp; ~0x3f) == 0 and ((1 &lt;&lt; (_la - 75)) &amp; ((1 &lt;&lt; (SqlSmallParser.SIGN - 75)) | (1 &lt;&lt; (SqlSmallParser.SIN - 75)) | (1 &lt;&lt; (SqlSmallParser.SQRT - 75)) | (1 &lt;&lt; (SqlSmallParser.SQUARE - 75)) | (1 &lt;&lt; (SqlSmallParser.TAN - 75)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BareFunctionNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PI(self):
            return self.getToken(SqlSmallParser.PI, 0)

        def RANDOM(self):
            return self.getToken(SqlSmallParser.RANDOM, 0)

        def RAND(self):
            return self.getToken(SqlSmallParser.RAND, 0)

        def NEWID(self):
            return self.getToken(SqlSmallParser.NEWID, 0)

        def getRuleIndex(self):
            return SqlSmallParser.RULE_bareFunctionName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterBareFunctionName&#34; ):
                listener.enterBareFunctionName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitBareFunctionName&#34; ):
                listener.exitBareFunctionName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitBareFunctionName&#34; ):
                return visitor.visitBareFunctionName(self)
            else:
                return visitor.visitChildren(self)




    def bareFunctionName(self):

        localctx = SqlSmallParser.BareFunctionNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_bareFunctionName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 487
            _la = self._input.LA(1)
            if not(((((_la - 52)) &amp; ~0x3f) == 0 and ((1 &lt;&lt; (_la - 52)) &amp; ((1 &lt;&lt; (SqlSmallParser.NEWID - 52)) | (1 &lt;&lt; (SqlSmallParser.PI - 52)) | (1 &lt;&lt; (SqlSmallParser.RAND - 52)) | (1 &lt;&lt; (SqlSmallParser.RANDOM - 52)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OverClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OVER(self):
            return self.getToken(SqlSmallParser.OVER, 0)

        def PARTITION(self):
            return self.getToken(SqlSmallParser.PARTITION, 0)

        def BY(self):
            return self.getToken(SqlSmallParser.BY, 0)

        def expression(self):
            return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,0)


        def orderClause(self):
            return self.getTypedRuleContext(SqlSmallParser.OrderClauseContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_overClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterOverClause&#34; ):
                listener.enterOverClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitOverClause&#34; ):
                listener.exitOverClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitOverClause&#34; ):
                return visitor.visitOverClause(self)
            else:
                return visitor.visitChildren(self)




    def overClause(self):

        localctx = SqlSmallParser.OverClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_overClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 489
            self.match(SqlSmallParser.OVER)
            self.state = 490
            self.match(SqlSmallParser.T__1)
            self.state = 494
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.PARTITION:
                self.state = 491
                self.match(SqlSmallParser.PARTITION)
                self.state = 492
                self.match(SqlSmallParser.BY)
                self.state = 493
                self.expression(0)


            self.state = 497
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.ORDER:
                self.state = 496
                self.orderClause()


            self.state = 499
            self.match(SqlSmallParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AliasedSubqueryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.alias = None # IdentifierContext

        def subquery(self):
            return self.getTypedRuleContext(SqlSmallParser.SubqueryContext,0)


        def AS(self):
            return self.getToken(SqlSmallParser.AS, 0)

        def identifier(self):
            return self.getTypedRuleContext(SqlSmallParser.IdentifierContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_aliasedSubquery

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterAliasedSubquery&#34; ):
                listener.enterAliasedSubquery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitAliasedSubquery&#34; ):
                listener.exitAliasedSubquery(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitAliasedSubquery&#34; ):
                return visitor.visitAliasedSubquery(self)
            else:
                return visitor.visitChildren(self)




    def aliasedSubquery(self):

        localctx = SqlSmallParser.AliasedSubqueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_aliasedSubquery)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 501
            self.subquery()
            self.state = 504
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.AS:
                self.state = 502
                self.match(SqlSmallParser.AS)
                self.state = 503
                localctx.alias = self.identifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AliasedTableOrSubquerySeqContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def aliasedTableName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.AliasedTableNameContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.AliasedTableNameContext,i)


        def aliasedSubquery(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.AliasedSubqueryContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.AliasedSubqueryContext,i)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_aliasedTableOrSubquerySeq

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterAliasedTableOrSubquerySeq&#34; ):
                listener.enterAliasedTableOrSubquerySeq(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitAliasedTableOrSubquerySeq&#34; ):
                listener.exitAliasedTableOrSubquerySeq(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitAliasedTableOrSubquerySeq&#34; ):
                return visitor.visitAliasedTableOrSubquerySeq(self)
            else:
                return visitor.visitChildren(self)




    def aliasedTableOrSubquerySeq(self):

        localctx = SqlSmallParser.AliasedTableOrSubquerySeqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_aliasedTableOrSubquerySeq)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 508
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlSmallParser.QN2, SqlSmallParser.QN3, SqlSmallParser.IDENT]:
                self.state = 506
                self.aliasedTableName()
                pass
            elif token in [SqlSmallParser.T__1]:
                self.state = 507
                self.aliasedSubquery()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 517
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SqlSmallParser.T__3:
                self.state = 510
                self.match(SqlSmallParser.T__3)
                self.state = 513
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [SqlSmallParser.QN2, SqlSmallParser.QN3, SqlSmallParser.IDENT]:
                    self.state = 511
                    self.aliasedTableName()
                    pass
                elif token in [SqlSmallParser.T__1]:
                    self.state = 512
                    self.aliasedSubquery()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 519
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AliasedTableSeqContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def aliasedTableName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.AliasedTableNameContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.AliasedTableNameContext,i)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_aliasedTableSeq

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterAliasedTableSeq&#34; ):
                listener.enterAliasedTableSeq(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitAliasedTableSeq&#34; ):
                listener.exitAliasedTableSeq(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitAliasedTableSeq&#34; ):
                return visitor.visitAliasedTableSeq(self)
            else:
                return visitor.visitChildren(self)




    def aliasedTableSeq(self):

        localctx = SqlSmallParser.AliasedTableSeqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_aliasedTableSeq)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 520
            self.aliasedTableName()
            self.state = 525
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SqlSmallParser.T__3:
                self.state = 521
                self.match(SqlSmallParser.T__3)
                self.state = 522
                self.aliasedTableName()
                self.state = 527
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AliasedTableNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.alias = None # IdentifierContext

        def qualifiedTableName(self):
            return self.getTypedRuleContext(SqlSmallParser.QualifiedTableNameContext,0)


        def AS(self):
            return self.getToken(SqlSmallParser.AS, 0)

        def identifier(self):
            return self.getTypedRuleContext(SqlSmallParser.IdentifierContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_aliasedTableName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterAliasedTableName&#34; ):
                listener.enterAliasedTableName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitAliasedTableName&#34; ):
                listener.exitAliasedTableName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitAliasedTableName&#34; ):
                return visitor.visitAliasedTableName(self)
            else:
                return visitor.visitChildren(self)




    def aliasedTableName(self):

        localctx = SqlSmallParser.AliasedTableNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_aliasedTableName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 528
            self.qualifiedTableName()
            self.state = 531
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.AS:
                self.state = 529
                self.match(SqlSmallParser.AS)
                self.state = 530
                localctx.alias = self.identifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QualifiedTableNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def QN3(self):
            return self.getToken(SqlSmallParser.QN3, 0)

        def QN2(self):
            return self.getToken(SqlSmallParser.QN2, 0)

        def IDENT(self):
            return self.getToken(SqlSmallParser.IDENT, 0)

        def getRuleIndex(self):
            return SqlSmallParser.RULE_qualifiedTableName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterQualifiedTableName&#34; ):
                listener.enterQualifiedTableName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitQualifiedTableName&#34; ):
                listener.exitQualifiedTableName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitQualifiedTableName&#34; ):
                return visitor.visitQualifiedTableName(self)
            else:
                return visitor.visitChildren(self)




    def qualifiedTableName(self):

        localctx = SqlSmallParser.QualifiedTableNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_qualifiedTableName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 533
            _la = self._input.LA(1)
            if not(((((_la - 115)) &amp; ~0x3f) == 0 and ((1 &lt;&lt; (_la - 115)) &amp; ((1 &lt;&lt; (SqlSmallParser.QN2 - 115)) | (1 &lt;&lt; (SqlSmallParser.QN3 - 115)) | (1 &lt;&lt; (SqlSmallParser.IDENT - 115)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QualifiedColumnNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def QN2(self):
            return self.getToken(SqlSmallParser.QN2, 0)

        def IDENT(self):
            return self.getToken(SqlSmallParser.IDENT, 0)

        def getRuleIndex(self):
            return SqlSmallParser.RULE_qualifiedColumnName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterQualifiedColumnName&#34; ):
                listener.enterQualifiedColumnName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitQualifiedColumnName&#34; ):
                listener.exitQualifiedColumnName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitQualifiedColumnName&#34; ):
                return visitor.visitQualifiedColumnName(self)
            else:
                return visitor.visitChildren(self)




    def qualifiedColumnName(self):

        localctx = SqlSmallParser.QualifiedColumnNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_qualifiedColumnName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 535
            _la = self._input.LA(1)
            if not(_la==SqlSmallParser.QN2 or _la==SqlSmallParser.IDENT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENT(self):
            return self.getToken(SqlSmallParser.IDENT, 0)

        def getRuleIndex(self):
            return SqlSmallParser.RULE_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterIdentifier&#34; ):
                listener.enterIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitIdentifier&#34; ):
                listener.exitIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitIdentifier&#34; ):
                return visitor.visitIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def identifier(self):

        localctx = SqlSmallParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_identifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 537
            self.match(SqlSmallParser.IDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlSmallParser.RULE_number

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class DecimalLiteralContext(NumberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.NumberContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DECIMAL_VALUE(self):
            return self.getToken(SqlSmallParser.DECIMAL_VALUE, 0)
        def MINUS(self):
            return self.getToken(SqlSmallParser.MINUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterDecimalLiteral&#34; ):
                listener.enterDecimalLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitDecimalLiteral&#34; ):
                listener.exitDecimalLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitDecimalLiteral&#34; ):
                return visitor.visitDecimalLiteral(self)
            else:
                return visitor.visitChildren(self)


    class IntegerLiteralContext(NumberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.NumberContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def INTEGER_VALUE(self):
            return self.getToken(SqlSmallParser.INTEGER_VALUE, 0)
        def MINUS(self):
            return self.getToken(SqlSmallParser.MINUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterIntegerLiteral&#34; ):
                listener.enterIntegerLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitIntegerLiteral&#34; ):
                listener.exitIntegerLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitIntegerLiteral&#34; ):
                return visitor.visitIntegerLiteral(self)
            else:
                return visitor.visitChildren(self)



    def number(self):

        localctx = SqlSmallParser.NumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_number)
        self._la = 0 # Token type
        try:
            self.state = 547
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,64,self._ctx)
            if la_ == 1:
                localctx = SqlSmallParser.DecimalLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 540
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlSmallParser.MINUS:
                    self.state = 539
                    self.match(SqlSmallParser.MINUS)


                self.state = 542
                self.match(SqlSmallParser.DECIMAL_VALUE)
                pass

            elif la_ == 2:
                localctx = SqlSmallParser.IntegerLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 544
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlSmallParser.MINUS:
                    self.state = 543
                    self.match(SqlSmallParser.MINUS)


                self.state = 546
                self.match(SqlSmallParser.INTEGER_VALUE)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[23] = self.expression_sempred
        self._predicates[26] = self.booleanExpression_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception(&#34;No predicate with index:&#34; + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def expression_sempred(self, localctx:ExpressionContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 12)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 11)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 10)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 9)
         

            if predIndex == 4:
                return self.precpred(self._ctx, 8)
         

    def booleanExpression_sempred(self, localctx:BooleanExpressionContext, predIndex:int):
            if predIndex == 5:
                return self.precpred(self._ctx, 4)
         

            if predIndex == 6:
                return self.precpred(self._ctx, 3)
         </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="burdock.sql.parser.SqlSmallParser.serializedATN"><code class="name flex">
<span>def <span class="ident">serializedATN</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serializedATN():
    with StringIO() as buf:
        buf.write(&#34;\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\177&#34;)
        buf.write(&#34;\u0228\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7&#34;)
        buf.write(&#34;\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16&#34;)
        buf.write(&#34;\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23&#34;)
        buf.write(&#34;\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31&#34;)
        buf.write(&#34;\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36&#34;)
        buf.write(&#34;\4\37\t\37\4 \t \4!\t!\4\&#34;\t\&#34;\4#\t#\4$\t$\4%\t%\4&amp;\t&#34;)
        buf.write(&#34;&amp;\4\&#39;\t\&#39;\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4&#34;)
        buf.write(&#34;/\t/\4\60\t\60\4\61\t\61\3\2\3\2\3\2\7\2f\n\2\f\2\16\2&#34;)
        buf.write(&#34;i\13\2\3\2\5\2l\n\2\3\2\3\2\3\3\3\3\3\3\5\3s\n\3\3\3\5&#34;)
        buf.write(&#34;\3v\n\3\3\3\5\3y\n\3\3\3\5\3|\n\3\3\3\5\3\177\n\3\3\4&#34;)
        buf.write(&#34;\3\4\3\4\3\4\5\4\u0085\n\4\3\4\5\4\u0088\n\4\3\4\5\4\u008b&#34;)
        buf.write(&#34;\n\4\3\4\5\4\u008e\n\4\3\4\3\4\3\5\3\5\3\6\3\6\5\6\u0096&#34;)
        buf.write(&#34;\n\6\3\6\3\6\3\7\3\7\3\7\3\7\7\7\u009e\n\7\f\7\16\7\u00a1&#34;)
        buf.write(&#34;\13\7\3\b\3\b\3\b\3\t\3\t\3\t\3\t\3\t\7\t\u00ab\n\t\f&#34;)
        buf.write(&#34;\t\16\t\u00ae\13\t\3\n\3\n\3\n\3\13\3\13\3\13\3\13\3\13&#34;)
        buf.write(&#34;\7\13\u00b8\n\13\f\13\16\13\u00bb\13\13\3\f\3\f\3\f\3&#34;)
        buf.write(&#34;\r\3\r\3\r\3\16\3\16\3\16\3\16\5\16\u00c7\n\16\3\17\5&#34;)
        buf.write(&#34;\17\u00ca\n\17\3\17\3\17\3\17\5\17\u00cf\n\17\3\17\5\17&#34;)
        buf.write(&#34;\u00d2\n\17\3\17\3\17\3\17\5\17\u00d7\n\17\3\17\3\17\5&#34;)
        buf.write(&#34;\17\u00db\n\17\3\17\5\17\u00de\n\17\3\17\5\17\u00e1\n&#34;)
        buf.write(&#34;\17\3\20\3\20\3\20\3\20\3\20\3\20\3\20\7\20\u00ea\n\20&#34;)
        buf.write(&#34;\f\20\16\20\u00ed\13\20\3\20\3\20\5\20\u00f1\n\20\3\21&#34;)
        buf.write(&#34;\3\21\5\21\u00f5\n\21\3\22\3\22\3\22\5\22\u00fa\n\22\3&#34;)
        buf.write(&#34;\23\3\23\7\23\u00fe\n\23\f\23\16\23\u0101\13\23\3\24\3&#34;)
        buf.write(&#34;\24\3\24\5\24\u0106\n\24\3\24\3\24\3\24\5\24\u010b\n\24&#34;)
        buf.write(&#34;\3\24\3\24\3\24\3\24\3\24\5\24\u0112\n\24\5\24\u0114\n&#34;)
        buf.write(&#34;\24\3\25\3\25\5\25\u0118\n\25\3\25\6\25\u011b\n\25\r\25&#34;)
        buf.write(&#34;\16\25\u011c\3\25\3\25\5\25\u0121\n\25\3\25\3\25\3\26&#34;)
        buf.write(&#34;\3\26\3\26\5\26\u0128\n\26\3\27\3\27\3\27\7\27\u012d\n&#34;)
        buf.write(&#34;\27\f\27\16\27\u0130\13\27\3\30\3\30\3\30\5\30\u0135\n&#34;)
        buf.write(&#34;\30\3\30\3\30\3\30\3\31\3\31\3\31\3\31\3\31\3\31\3\31&#34;)
        buf.write(&#34;\3\31\3\31\3\31\3\31\3\31\5\31\u0146\n\31\3\31\3\31\3&#34;)
        buf.write(&#34;\31\3\31\3\31\3\31\3\31\3\31\3\31\3\31\3\31\3\31\3\31&#34;)
        buf.write(&#34;\3\31\3\31\7\31\u0157\n\31\f\31\16\31\u015a\13\31\3\32&#34;)
        buf.write(&#34;\3\32\3\32\3\32\3\32\5\32\u0161\n\32\3\33\3\33\3\33\3&#34;)
        buf.write(&#34;\33\3\33\5\33\u0168\n\33\3\34\3\34\3\34\3\34\3\34\3\34&#34;)
        buf.write(&#34;\3\34\3\34\3\34\3\34\3\34\3\34\3\34\3\34\5\34\u0178\n&#34;)
        buf.write(&#34;\34\3\34\3\34\3\34\3\34\3\34\3\34\7\34\u0180\n\34\f\34&#34;)
        buf.write(&#34;\16\34\u0183\13\34\3\35\5\35\u0186\n\35\3\35\3\35\3\35&#34;)
        buf.write(&#34;\3\35\3\35\3\35\5\35\u018e\n\35\3\35\3\35\3\35\3\35\3&#34;)
        buf.write(&#34;\35\7\35\u0195\n\35\f\35\16\35\u0198\13\35\3\35\3\35\3&#34;)
        buf.write(&#34;\35\3\35\5\35\u019e\n\35\3\35\5\35\u01a1\n\35\3\36\3\36&#34;)
        buf.write(&#34;\3\37\3\37\3 \3 \3 \3 \3 \3 \5 \u01ad\n \3 \3 \3 \3 \3&#34;)
        buf.write(&#34; \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \6&#34;)
        buf.write(&#34; \u01c5\n \r \16 \u01c6\3 \3 \5 \u01cb\n \3!\3!\3!\3!&#34;)
        buf.write(&#34;\3\&#34;\3\&#34;\3\&#34;\3\&#34;\3\&#34;\3#\3#\3#\3#\3#\3#\3#\3$\3$\3$\3$&#34;)
        buf.write(&#34;\3$\3$\3$\3%\3%\3&amp;\3&amp;\3\&#39;\3\&#39;\3(\3(\3)\3)\3)\3)\3)\5)&#34;)
        buf.write(&#34;\u01f1\n)\3)\5)\u01f4\n)\3)\3)\3*\3*\3*\5*\u01fb\n*\3&#34;)
        buf.write(&#34;+\3+\5+\u01ff\n+\3+\3+\3+\5+\u0204\n+\7+\u0206\n+\f+\16&#34;)
        buf.write(&#34;+\u0209\13+\3,\3,\3,\7,\u020e\n,\f,\16,\u0211\13,\3-\3&#34;)
        buf.write(&#34;-\3-\5-\u0216\n-\3.\3.\3/\3/\3\60\3\60\3\61\5\61\u021f&#34;)
        buf.write(&#34;\n\61\3\61\3\61\5\61\u0223\n\61\3\61\5\61\u0226\n\61\3&#34;)
        buf.write(&#34;\61\2\4\60\66\62\2\4\6\b\n\f\16\20\22\24\26\30\32\34\36&#34;)
        buf.write(&#34; \&#34;$&amp;(*,.\60\62\64\668:&lt;&gt;@BDFHJLNPRTVXZ\\^`\2\f\4\2\16&#34;)
        buf.write(&#34;\16\35\35\5\2##88YY\3\2`g\4\2##YY\5\2\34\34FFII\b\2\21&#34;)
        buf.write(&#34;\21\31\31\64\65@ASU\\]\r\2\b\t\17\20\25\25\27\27\33\33&#34;)
        buf.write(&#34;\&#34;\&#34;$$\62\63MNQRVV\5\2\66\66BBDE\3\2uw\4\2uuww\2\u0253&#34;)
        buf.write(&#34;\2b\3\2\2\2\4o\3\2\2\2\6\u0080\3\2\2\2\b\u0091\3\2\2\2&#34;)
        buf.write(&#34;\n\u0093\3\2\2\2\f\u0099\3\2\2\2\16\u00a2\3\2\2\2\20\u00a5&#34;)
        buf.write(&#34;\3\2\2\2\22\u00af\3\2\2\2\24\u00b2\3\2\2\2\26\u00bc\3&#34;)
        buf.write(&#34;\2\2\2\30\u00bf\3\2\2\2\32\u00c2\3\2\2\2\34\u00e0\3\2&#34;)
        buf.write(&#34;\2\2\36\u00f0\3\2\2\2 \u00f2\3\2\2\2\&#34;\u00f9\3\2\2\2$&#34;)
        buf.write(&#34;\u00fb\3\2\2\2&amp;\u0113\3\2\2\2(\u0115\3\2\2\2*\u0124\3&#34;)
        buf.write(&#34;\2\2\2,\u0129\3\2\2\2.\u0131\3\2\2\2\60\u0145\3\2\2\2&#34;)
        buf.write(&#34;\62\u0160\3\2\2\2\64\u0167\3\2\2\2\66\u0177\3\2\2\28\u01a0&#34;)
        buf.write(&#34;\3\2\2\2:\u01a2\3\2\2\2&lt;\u01a4\3\2\2\2&gt;\u01ca\3\2\2\2&#34;)
        buf.write(&#34;@\u01cc\3\2\2\2B\u01d0\3\2\2\2D\u01d5\3\2\2\2F\u01dc\3&#34;)
        buf.write(&#34;\2\2\2H\u01e3\3\2\2\2J\u01e5\3\2\2\2L\u01e7\3\2\2\2N\u01e9&#34;)
        buf.write(&#34;\3\2\2\2P\u01eb\3\2\2\2R\u01f7\3\2\2\2T\u01fe\3\2\2\2&#34;)
        buf.write(&#34;V\u020a\3\2\2\2X\u0212\3\2\2\2Z\u0217\3\2\2\2\\\u0219&#34;)
        buf.write(&#34;\3\2\2\2^\u021b\3\2\2\2`\u0225\3\2\2\2bg\5\4\3\2cd\7\3&#34;)
        buf.write(&#34;\2\2df\5\4\3\2ec\3\2\2\2fi\3\2\2\2ge\3\2\2\2gh\3\2\2\2&#34;)
        buf.write(&#34;hk\3\2\2\2ig\3\2\2\2jl\7\3\2\2kj\3\2\2\2kl\3\2\2\2lm\3&#34;)
        buf.write(&#34;\2\2\2mn\7\2\2\3n\3\3\2\2\2op\5\n\6\2pr\5\f\7\2qs\5\16&#34;)
        buf.write(&#34;\b\2rq\3\2\2\2rs\3\2\2\2su\3\2\2\2tv\5\20\t\2ut\3\2\2&#34;)
        buf.write(&#34;\2uv\3\2\2\2vx\3\2\2\2wy\5\22\n\2xw\3\2\2\2xy\3\2\2\2&#34;)
        buf.write(&#34;y{\3\2\2\2z|\5\24\13\2{z\3\2\2\2{|\3\2\2\2|~\3\2\2\2}&#34;)
        buf.write(&#34;\177\5\26\f\2~}\3\2\2\2~\177\3\2\2\2\177\5\3\2\2\2\u0080&#34;)
        buf.write(&#34;\u0081\7\4\2\2\u0081\u0082\5\n\6\2\u0082\u0084\5\f\7\2&#34;)
        buf.write(&#34;\u0083\u0085\5\16\b\2\u0084\u0083\3\2\2\2\u0084\u0085&#34;)
        buf.write(&#34;\3\2\2\2\u0085\u0087\3\2\2\2\u0086\u0088\5\20\t\2\u0087&#34;)
        buf.write(&#34;\u0086\3\2\2\2\u0087\u0088\3\2\2\2\u0088\u008a\3\2\2\2&#34;)
        buf.write(&#34;\u0089\u008b\5\22\n\2\u008a\u0089\3\2\2\2\u008a\u008b&#34;)
        buf.write(&#34;\3\2\2\2\u008b\u008d\3\2\2\2\u008c\u008e\5\24\13\2\u008d&#34;)
        buf.write(&#34;\u008c\3\2\2\2\u008d\u008e\3\2\2\2\u008e\u008f\3\2\2\2&#34;)
        buf.write(&#34;\u008f\u0090\7\5\2\2\u0090\7\3\2\2\2\u0091\u0092\5\6\4&#34;)
        buf.write(&#34;\2\u0092\t\3\2\2\2\u0093\u0095\7K\2\2\u0094\u0096\5\&#34;&#34;)
        buf.write(&#34;\22\2\u0095\u0094\3\2\2\2\u0095\u0096\3\2\2\2\u0096\u0097&#34;)
        buf.write(&#34;\3\2\2\2\u0097\u0098\5,\27\2\u0098\13\3\2\2\2\u0099\u009a&#34;)
        buf.write(&#34;\7%\2\2\u009a\u009f\5$\23\2\u009b\u009c\7\6\2\2\u009c&#34;)
        buf.write(&#34;\u009e\5$\23\2\u009d\u009b\3\2\2\2\u009e\u00a1\3\2\2\2&#34;)
        buf.write(&#34;\u009f\u009d\3\2\2\2\u009f\u00a0\3\2\2\2\u00a0\r\3\2\2&#34;)
        buf.write(&#34;\2\u00a1\u009f\3\2\2\2\u00a2\u00a3\7_\2\2\u00a3\u00a4&#34;)
        buf.write(&#34;\5\66\34\2\u00a4\17\3\2\2\2\u00a5\u00a6\7\&#39;\2\2\u00a6&#34;)
        buf.write(&#34;\u00a7\7\23\2\2\u00a7\u00ac\5\60\31\2\u00a8\u00a9\7\6&#34;)
        buf.write(&#34;\2\2\u00a9\u00ab\5\60\31\2\u00aa\u00a8\3\2\2\2\u00ab\u00ae&#34;)
        buf.write(&#34;\3\2\2\2\u00ac\u00aa\3\2\2\2\u00ac\u00ad\3\2\2\2\u00ad&#34;)
        buf.write(&#34;\21\3\2\2\2\u00ae\u00ac\3\2\2\2\u00af\u00b0\7(\2\2\u00b0&#34;)
        buf.write(&#34;\u00b1\5\66\34\2\u00b1\23\3\2\2\2\u00b2\u00b3\7&lt;\2\2\u00b3&#34;)
        buf.write(&#34;\u00b4\7\23\2\2\u00b4\u00b9\5 \21\2\u00b5\u00b6\7\6\2&#34;)
        buf.write(&#34;\2\u00b6\u00b8\5 \21\2\u00b7\u00b5\3\2\2\2\u00b8\u00bb&#34;)
        buf.write(&#34;\3\2\2\2\u00b9\u00b7\3\2\2\2\u00b9\u00ba\3\2\2\2\u00ba&#34;)
        buf.write(&#34;\25\3\2\2\2\u00bb\u00b9\3\2\2\2\u00bc\u00bd\7\61\2\2\u00bd&#34;)
        buf.write(&#34;\u00be\5`\61\2\u00be\27\3\2\2\2\u00bf\u00c0\7X\2\2\u00c0&#34;)
        buf.write(&#34;\u00c1\5`\61\2\u00c1\31\3\2\2\2\u00c2\u00c3\5\34\17\2&#34;)
        buf.write(&#34;\u00c3\u00c4\7/\2\2\u00c4\u00c6\5&amp;\24\2\u00c5\u00c7\5&#34;)
        buf.write(&#34;\36\20\2\u00c6\u00c5\3\2\2\2\u00c6\u00c7\3\2\2\2\u00c7&#34;)
        buf.write(&#34;\33\3\2\2\2\u00c8\u00ca\7,\2\2\u00c9\u00c8\3\2\2\2\u00c9&#34;)
        buf.write(&#34;\u00ca\3\2\2\2\u00ca\u00e1\3\2\2\2\u00cb\u00e1\7\32\2&#34;)
        buf.write(&#34;\2\u00cc\u00ce\7\60\2\2\u00cd\u00cf\7=\2\2\u00ce\u00cd&#34;)
        buf.write(&#34;\3\2\2\2\u00ce\u00cf\3\2\2\2\u00cf\u00e1\3\2\2\2\u00d0&#34;)
        buf.write(&#34;\u00d2\7\60\2\2\u00d1\u00d0\3\2\2\2\u00d1\u00d2\3\2\2&#34;)
        buf.write(&#34;\2\u00d2\u00d3\3\2\2\2\u00d3\u00e1\7L\2\2\u00d4\u00d6&#34;)
        buf.write(&#34;\7G\2\2\u00d5\u00d7\7=\2\2\u00d6\u00d5\3\2\2\2\u00d6\u00d7&#34;)
        buf.write(&#34;\3\2\2\2\u00d7\u00e1\3\2\2\2\u00d8\u00da\7&amp;\2\2\u00d9&#34;)
        buf.write(&#34;\u00db\7=\2\2\u00da\u00d9\3\2\2\2\u00da\u00db\3\2\2\2&#34;)
        buf.write(&#34;\u00db\u00e1\3\2\2\2\u00dc\u00de\7\60\2\2\u00dd\u00dc&#34;)
        buf.write(&#34;\3\2\2\2\u00dd\u00de\3\2\2\2\u00de\u00df\3\2\2\2\u00df&#34;)
        buf.write(&#34;\u00e1\7\f\2\2\u00e0\u00c9\3\2\2\2\u00e0\u00cb\3\2\2\2&#34;)
        buf.write(&#34;\u00e0\u00cc\3\2\2\2\u00e0\u00d1\3\2\2\2\u00e0\u00d4\3&#34;)
        buf.write(&#34;\2\2\2\u00e0\u00d8\3\2\2\2\u00e0\u00dd\3\2\2\2\u00e1\35&#34;)
        buf.write(&#34;\3\2\2\2\u00e2\u00e3\7:\2\2\u00e3\u00f1\5\66\34\2\u00e4&#34;)
        buf.write(&#34;\u00e5\7[\2\2\u00e5\u00e6\7\4\2\2\u00e6\u00eb\5^\60\2&#34;)
        buf.write(&#34;\u00e7\u00e8\7\6\2\2\u00e8\u00ea\5^\60\2\u00e9\u00e7\3&#34;)
        buf.write(&#34;\2\2\2\u00ea\u00ed\3\2\2\2\u00eb\u00e9\3\2\2\2\u00eb\u00ec&#34;)
        buf.write(&#34;\3\2\2\2\u00ec\u00ee\3\2\2\2\u00ed\u00eb\3\2\2\2\u00ee&#34;)
        buf.write(&#34;\u00ef\7\5\2\2\u00ef\u00f1\3\2\2\2\u00f0\u00e2\3\2\2\2&#34;)
        buf.write(&#34;\u00f0\u00e4\3\2\2\2\u00f1\37\3\2\2\2\u00f2\u00f4\5\60&#34;)
        buf.write(&#34;\31\2\u00f3\u00f5\t\2\2\2\u00f4\u00f3\3\2\2\2\u00f4\u00f5&#34;)
        buf.write(&#34;\3\2\2\2\u00f5!\3\2\2\2\u00f6\u00fa\7\36\2\2\u00f7\u00fa&#34;)
        buf.write(&#34;\7\n\2\2\u00f8\u00fa\5\30\r\2\u00f9\u00f6\3\2\2\2\u00f9&#34;)
        buf.write(&#34;\u00f7\3\2\2\2\u00f9\u00f8\3\2\2\2\u00fa#\3\2\2\2\u00fb&#34;)
        buf.write(&#34;\u00ff\5&amp;\24\2\u00fc\u00fe\5\32\16\2\u00fd\u00fc\3\2\2&#34;)
        buf.write(&#34;\2\u00fe\u0101\3\2\2\2\u00ff\u00fd\3\2\2\2\u00ff\u0100&#34;)
        buf.write(&#34;\3\2\2\2\u0100%\3\2\2\2\u0101\u00ff\3\2\2\2\u0102\u0105&#34;)
        buf.write(&#34;\5Z.\2\u0103\u0104\7\r\2\2\u0104\u0106\5^\60\2\u0105\u0103&#34;)
        buf.write(&#34;\3\2\2\2\u0105\u0106\3\2\2\2\u0106\u0114\3\2\2\2\u0107&#34;)
        buf.write(&#34;\u010a\5\6\4\2\u0108\u0109\7\r\2\2\u0109\u010b\5^\60\2&#34;)
        buf.write(&#34;\u010a\u0108\3\2\2\2\u010a\u010b\3\2\2\2\u010b\u0114\3&#34;)
        buf.write(&#34;\2\2\2\u010c\u010d\7\4\2\2\u010d\u010e\5$\23\2\u010e\u0111&#34;)
        buf.write(&#34;\7\5\2\2\u010f\u0110\7\r\2\2\u0110\u0112\5^\60\2\u0111&#34;)
        buf.write(&#34;\u010f\3\2\2\2\u0111\u0112\3\2\2\2\u0112\u0114\3\2\2\2&#34;)
        buf.write(&#34;\u0113\u0102\3\2\2\2\u0113\u0107\3\2\2\2\u0113\u010c\3&#34;)
        buf.write(&#34;\2\2\2\u0114\&#39;\3\2\2\2\u0115\u0117\7\24\2\2\u0116\u0118&#34;)
        buf.write(&#34;\5\60\31\2\u0117\u0116\3\2\2\2\u0117\u0118\3\2\2\2\u0118&#34;)
        buf.write(&#34;\u011a\3\2\2\2\u0119\u011b\5.\30\2\u011a\u0119\3\2\2\2&#34;)
        buf.write(&#34;\u011b\u011c\3\2\2\2\u011c\u011a\3\2\2\2\u011c\u011d\3&#34;)
        buf.write(&#34;\2\2\2\u011d\u0120\3\2\2\2\u011e\u011f\7 \2\2\u011f\u0121&#34;)
        buf.write(&#34;\5\60\31\2\u0120\u011e\3\2\2\2\u0120\u0121\3\2\2\2\u0121&#34;)
        buf.write(&#34;\u0122\3\2\2\2\u0122\u0123\7!\2\2\u0123)\3\2\2\2\u0124&#34;)
        buf.write(&#34;\u0127\5\60\31\2\u0125\u0126\7\r\2\2\u0126\u0128\5^\60&#34;)
        buf.write(&#34;\2\u0127\u0125\3\2\2\2\u0127\u0128\3\2\2\2\u0128+\3\2&#34;)
        buf.write(&#34;\2\2\u0129\u012e\5*\26\2\u012a\u012b\7\6\2\2\u012b\u012d&#34;)
        buf.write(&#34;\5*\26\2\u012c\u012a\3\2\2\2\u012d\u0130\3\2\2\2\u012e&#34;)
        buf.write(&#34;\u012c\3\2\2\2\u012e\u012f\3\2\2\2\u012f-\3\2\2\2\u0130&#34;)
        buf.write(&#34;\u012e\3\2\2\2\u0131\u0134\7^\2\2\u0132\u0135\5\66\34&#34;)
        buf.write(&#34;\2\u0133\u0135\5\60\31\2\u0134\u0132\3\2\2\2\u0134\u0133&#34;)
        buf.write(&#34;\3\2\2\2\u0135\u0136\3\2\2\2\u0136\u0137\7W\2\2\u0137&#34;)
        buf.write(&#34;\u0138\5\60\31\2\u0138/\3\2\2\2\u0139\u013a\b\31\1\2\u013a&#34;)
        buf.write(&#34;\u0146\5\\/\2\u013b\u0146\5(\25\2\u013c\u0146\5\62\32&#34;)
        buf.write(&#34;\2\u013d\u0146\5\64\33\2\u013e\u0146\5B\&#34;\2\u013f\u0146&#34;)
        buf.write(&#34;\5&gt; \2\u0140\u0146\5\b\5\2\u0141\u0142\7\4\2\2\u0142\u0143&#34;)
        buf.write(&#34;\5\60\31\2\u0143\u0144\7\5\2\2\u0144\u0146\3\2\2\2\u0145&#34;)
        buf.write(&#34;\u0139\3\2\2\2\u0145\u013b\3\2\2\2\u0145\u013c\3\2\2\2&#34;)
        buf.write(&#34;\u0145\u013d\3\2\2\2\u0145\u013e\3\2\2\2\u0145\u013f\3&#34;)
        buf.write(&#34;\2\2\2\u0145\u0140\3\2\2\2\u0145\u0141\3\2\2\2\u0146\u0158&#34;)
        buf.write(&#34;\3\2\2\2\u0147\u0148\f\16\2\2\u0148\u0149\7j\2\2\u0149&#34;)
        buf.write(&#34;\u0157\5\60\31\17\u014a\u014b\f\r\2\2\u014b\u014c\7k\2&#34;)
        buf.write(&#34;\2\u014c\u0157\5\60\31\16\u014d\u014e\f\f\2\2\u014e\u014f&#34;)
        buf.write(&#34;\7l\2\2\u014f\u0157\5\60\31\r\u0150\u0151\f\13\2\2\u0151&#34;)
        buf.write(&#34;\u0152\7h\2\2\u0152\u0157\5\60\31\f\u0153\u0154\f\n\2&#34;)
        buf.write(&#34;\2\u0154\u0155\7i\2\2\u0155\u0157\5\60\31\13\u0156\u0147&#34;)
        buf.write(&#34;\3\2\2\2\u0156\u014a\3\2\2\2\u0156\u014d\3\2\2\2\u0156&#34;)
        buf.write(&#34;\u0150\3\2\2\2\u0156\u0153\3\2\2\2\u0157\u015a\3\2\2\2&#34;)
        buf.write(&#34;\u0158\u0156\3\2\2\2\u0158\u0159\3\2\2\2\u0159\61\3\2&#34;)
        buf.write(&#34;\2\2\u015a\u0158\3\2\2\2\u015b\u0161\7j\2\2\u015c\u015d&#34;)
        buf.write(&#34;\5^\60\2\u015d\u015e\7\7\2\2\u015e\u015f\7j\2\2\u015f&#34;)
        buf.write(&#34;\u0161\3\2\2\2\u0160\u015b\3\2\2\2\u0160\u015c\3\2\2\2&#34;)
        buf.write(&#34;\u0161\63\3\2\2\2\u0162\u0168\7r\2\2\u0163\u0168\5`\61&#34;)
        buf.write(&#34;\2\u0164\u0168\7Y\2\2\u0165\u0168\7#\2\2\u0166\u0168\7&#34;)
        buf.write(&#34;8\2\2\u0167\u0162\3\2\2\2\u0167\u0163\3\2\2\2\u0167\u0164&#34;)
        buf.write(&#34;\3\2\2\2\u0167\u0165\3\2\2\2\u0167\u0166\3\2\2\2\u0168&#34;)
        buf.write(&#34;\65\3\2\2\2\u0169\u016a\b\34\1\2\u016a\u016b\7\67\2\2&#34;)
        buf.write(&#34;\u016b\u0178\5\66\34\b\u016c\u016d\5\60\31\2\u016d\u016e&#34;)
        buf.write(&#34;\5:\36\2\u016e\u016f\5\60\31\2\u016f\u0178\3\2\2\2\u0170&#34;)
        buf.write(&#34;\u0171\7\4\2\2\u0171\u0172\5\66\34\2\u0172\u0173\7\5\2&#34;)
        buf.write(&#34;\2\u0173\u0178\3\2\2\2\u0174\u0175\5\60\31\2\u0175\u0176&#34;)
        buf.write(&#34;\58\35\2\u0176\u0178\3\2\2\2\u0177\u0169\3\2\2\2\u0177&#34;)
        buf.write(&#34;\u016c\3\2\2\2\u0177\u0170\3\2\2\2\u0177\u0174\3\2\2\2&#34;)
        buf.write(&#34;\u0178\u0181\3\2\2\2\u0179\u017a\f\6\2\2\u017a\u017b\7&#34;)
        buf.write(&#34;\13\2\2\u017b\u0180\5\66\34\7\u017c\u017d\f\5\2\2\u017d&#34;)
        buf.write(&#34;\u017e\7;\2\2\u017e\u0180\5\66\34\6\u017f\u0179\3\2\2&#34;)
        buf.write(&#34;\2\u017f\u017c\3\2\2\2\u0180\u0183\3\2\2\2\u0181\u017f&#34;)
        buf.write(&#34;\3\2\2\2\u0181\u0182\3\2\2\2\u0182\67\3\2\2\2\u0183\u0181&#34;)
        buf.write(&#34;\3\2\2\2\u0184\u0186\7\67\2\2\u0185\u0184\3\2\2\2\u0185&#34;)
        buf.write(&#34;\u0186\3\2\2\2\u0186\u0187\3\2\2\2\u0187\u0188\7\22\2&#34;)
        buf.write(&#34;\2\u0188\u0189\5\60\31\2\u0189\u018a\7\13\2\2\u018a\u018b&#34;)
        buf.write(&#34;\5\60\31\2\u018b\u01a1\3\2\2\2\u018c\u018e\7\67\2\2\u018d&#34;)
        buf.write(&#34;\u018c\3\2\2\2\u018d\u018e\3\2\2\2\u018e\u018f\3\2\2\2&#34;)
        buf.write(&#34;\u018f\u0190\7+\2\2\u0190\u0191\7\4\2\2\u0191\u0196\5&#34;)
        buf.write(&#34;\60\31\2\u0192\u0193\7\6\2\2\u0193\u0195\5\60\31\2\u0194&#34;)
        buf.write(&#34;\u0192\3\2\2\2\u0195\u0198\3\2\2\2\u0196\u0194\3\2\2\2&#34;)
        buf.write(&#34;\u0196\u0197\3\2\2\2\u0197\u0199\3\2\2\2\u0198\u0196\3&#34;)
        buf.write(&#34;\2\2\2\u0199\u019a\7\5\2\2\u019a\u01a1\3\2\2\2\u019b\u019d&#34;)
        buf.write(&#34;\7.\2\2\u019c\u019e\7\67\2\2\u019d\u019c\3\2\2\2\u019d&#34;)
        buf.write(&#34;\u019e\3\2\2\2\u019e\u019f\3\2\2\2\u019f\u01a1\t\3\2\2&#34;)
        buf.write(&#34;\u01a0\u0185\3\2\2\2\u01a0\u018d\3\2\2\2\u01a0\u019b\3&#34;)
        buf.write(&#34;\2\2\2\u01a19\3\2\2\2\u01a2\u01a3\t\4\2\2\u01a3;\3\2\2&#34;)
        buf.write(&#34;\2\u01a4\u01a5\t\5\2\2\u01a5=\3\2\2\2\u01a6\u01cb\5@!&#34;)
        buf.write(&#34;\2\u01a7\u01cb\5D#\2\u01a8\u01cb\5F$\2\u01a9\u01aa\5J&#34;)
        buf.write(&#34;&amp;\2\u01aa\u01ac\7\4\2\2\u01ab\u01ad\5\&#34;\22\2\u01ac\u01ab&#34;)
        buf.write(&#34;\3\2\2\2\u01ac\u01ad\3\2\2\2\u01ad\u01ae\3\2\2\2\u01ae&#34;)
        buf.write(&#34;\u01af\5\60\31\2\u01af\u01b0\7\5\2\2\u01b0\u01cb\3\2\2&#34;)
        buf.write(&#34;\2\u01b1\u01b2\5L\&#39;\2\u01b2\u01b3\7\4\2\2\u01b3\u01b4&#34;)
        buf.write(&#34;\5\60\31\2\u01b4\u01b5\7\5\2\2\u01b5\u01cb\3\2\2\2\u01b6&#34;)
        buf.write(&#34;\u01b7\7*\2\2\u01b7\u01b8\7\4\2\2\u01b8\u01b9\5\66\34&#34;)
        buf.write(&#34;\2\u01b9\u01ba\7\6\2\2\u01ba\u01bb\5\60\31\2\u01bb\u01bc&#34;)
        buf.write(&#34;\7\6\2\2\u01bc\u01bd\5\60\31\2\u01bd\u01be\7\5\2\2\u01be&#34;)
        buf.write(&#34;\u01cb\3\2\2\2\u01bf\u01c0\7\26\2\2\u01c0\u01c1\7\4\2&#34;)
        buf.write(&#34;\2\u01c1\u01c4\5\60\31\2\u01c2\u01c3\7\6\2\2\u01c3\u01c5&#34;)
        buf.write(&#34;\5\64\33\2\u01c4\u01c2\3\2\2\2\u01c5\u01c6\3\2\2\2\u01c6&#34;)
        buf.write(&#34;\u01c4\3\2\2\2\u01c6\u01c7\3\2\2\2\u01c7\u01c8\3\2\2\2&#34;)
        buf.write(&#34;\u01c8\u01c9\7\5\2\2\u01c9\u01cb\3\2\2\2\u01ca\u01a6\3&#34;)
        buf.write(&#34;\2\2\2\u01ca\u01a7\3\2\2\2\u01ca\u01a8\3\2\2\2\u01ca\u01a9&#34;)
        buf.write(&#34;\3\2\2\2\u01ca\u01b1\3\2\2\2\u01ca\u01b6\3\2\2\2\u01ca&#34;)
        buf.write(&#34;\u01bf\3\2\2\2\u01cb?\3\2\2\2\u01cc\u01cd\5N(\2\u01cd&#34;)
        buf.write(&#34;\u01ce\7\4\2\2\u01ce\u01cf\7\5\2\2\u01cfA\3\2\2\2\u01d0&#34;)
        buf.write(&#34;\u01d1\5H%\2\u01d1\u01d2\7\4\2\2\u01d2\u01d3\7\5\2\2\u01d3&#34;)
        buf.write(&#34;\u01d4\5P)\2\u01d4C\3\2\2\2\u01d5\u01d6\7H\2\2\u01d6\u01d7&#34;)
        buf.write(&#34;\7\4\2\2\u01d7\u01d8\5\60\31\2\u01d8\u01d9\7\6\2\2\u01d9&#34;)
        buf.write(&#34;\u01da\5`\61\2\u01da\u01db\7\5\2\2\u01dbE\3\2\2\2\u01dc&#34;)
        buf.write(&#34;\u01dd\7C\2\2\u01dd\u01de\7\4\2\2\u01de\u01df\5\60\31&#34;)
        buf.write(&#34;\2\u01df\u01e0\7\6\2\2\u01e0\u01e1\5`\61\2\u01e1\u01e2&#34;)
        buf.write(&#34;\7\5\2\2\u01e2G\3\2\2\2\u01e3\u01e4\t\6\2\2\u01e4I\3\2&#34;)
        buf.write(&#34;\2\2\u01e5\u01e6\t\7\2\2\u01e6K\3\2\2\2\u01e7\u01e8\t&#34;)
        buf.write(&#34;\b\2\2\u01e8M\3\2\2\2\u01e9\u01ea\t\t\2\2\u01eaO\3\2\2&#34;)
        buf.write(&#34;\2\u01eb\u01ec\7&gt;\2\2\u01ec\u01f0\7\4\2\2\u01ed\u01ee&#34;)
        buf.write(&#34;\7?\2\2\u01ee\u01ef\7\23\2\2\u01ef\u01f1\5\60\31\2\u01f0&#34;)
        buf.write(&#34;\u01ed\3\2\2\2\u01f0\u01f1\3\2\2\2\u01f1\u01f3\3\2\2\2&#34;)
        buf.write(&#34;\u01f2\u01f4\5\24\13\2\u01f3\u01f2\3\2\2\2\u01f3\u01f4&#34;)
        buf.write(&#34;\3\2\2\2\u01f4\u01f5\3\2\2\2\u01f5\u01f6\7\5\2\2\u01f6&#34;)
        buf.write(&#34;Q\3\2\2\2\u01f7\u01fa\5\6\4\2\u01f8\u01f9\7\r\2\2\u01f9&#34;)
        buf.write(&#34;\u01fb\5^\60\2\u01fa\u01f8\3\2\2\2\u01fa\u01fb\3\2\2\2&#34;)
        buf.write(&#34;\u01fbS\3\2\2\2\u01fc\u01ff\5X-\2\u01fd\u01ff\5R*\2\u01fe&#34;)
        buf.write(&#34;\u01fc\3\2\2\2\u01fe\u01fd\3\2\2\2\u01ff\u0207\3\2\2\2&#34;)
        buf.write(&#34;\u0200\u0203\7\6\2\2\u0201\u0204\5X-\2\u0202\u0204\5R&#34;)
        buf.write(&#34;*\2\u0203\u0201\3\2\2\2\u0203\u0202\3\2\2\2\u0204\u0206&#34;)
        buf.write(&#34;\3\2\2\2\u0205\u0200\3\2\2\2\u0206\u0209\3\2\2\2\u0207&#34;)
        buf.write(&#34;\u0205\3\2\2\2\u0207\u0208\3\2\2\2\u0208U\3\2\2\2\u0209&#34;)
        buf.write(&#34;\u0207\3\2\2\2\u020a\u020f\5X-\2\u020b\u020c\7\6\2\2\u020c&#34;)
        buf.write(&#34;\u020e\5X-\2\u020d\u020b\3\2\2\2\u020e\u0211\3\2\2\2\u020f&#34;)
        buf.write(&#34;\u020d\3\2\2\2\u020f\u0210\3\2\2\2\u0210W\3\2\2\2\u0211&#34;)
        buf.write(&#34;\u020f\3\2\2\2\u0212\u0215\5Z.\2\u0213\u0214\7\r\2\2\u0214&#34;)
        buf.write(&#34;\u0216\5^\60\2\u0215\u0213\3\2\2\2\u0215\u0216\3\2\2\2&#34;)
        buf.write(&#34;\u0216Y\3\2\2\2\u0217\u0218\t\n\2\2\u0218[\3\2\2\2\u0219&#34;)
        buf.write(&#34;\u021a\t\13\2\2\u021a]\3\2\2\2\u021b\u021c\7w\2\2\u021c&#34;)
        buf.write(&#34;_\3\2\2\2\u021d\u021f\7i\2\2\u021e\u021d\3\2\2\2\u021e&#34;)
        buf.write(&#34;\u021f\3\2\2\2\u021f\u0220\3\2\2\2\u0220\u0226\7t\2\2&#34;)
        buf.write(&#34;\u0221\u0223\7i\2\2\u0222\u0221\3\2\2\2\u0222\u0223\3&#34;)
        buf.write(&#34;\2\2\2\u0223\u0224\3\2\2\2\u0224\u0226\7s\2\2\u0225\u021e&#34;)
        buf.write(&#34;\3\2\2\2\u0225\u0222\3\2\2\2\u0226a\3\2\2\2Cgkrux{~\u0084&#34;)
        buf.write(&#34;\u0087\u008a\u008d\u0095\u009f\u00ac\u00b9\u00c6\u00c9&#34;)
        buf.write(&#34;\u00ce\u00d1\u00d6\u00da\u00dd\u00e0\u00eb\u00f0\u00f4&#34;)
        buf.write(&#34;\u00f9\u00ff\u0105\u010a\u0111\u0113\u0117\u011c\u0120&#34;)
        buf.write(&#34;\u0127\u012e\u0134\u0145\u0156\u0158\u0160\u0167\u0177&#34;)
        buf.write(&#34;\u017f\u0181\u0185\u018d\u0196\u019d\u01a0\u01ac\u01c6&#34;)
        buf.write(&#34;\u01ca\u01f0\u01f3\u01fa\u01fe\u0203\u0207\u020f\u0215&#34;)
        buf.write(&#34;\u021e\u0222\u0225&#34;)
        return buf.getvalue()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser"><code class="flex name class">
<span>class <span class="ident">SqlSmallParser</span></span>
<span>(</span><span>input, output=sys.stdout)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SqlSmallParser ( Parser ):

    grammarFileName = &#34;SqlSmall.g4&#34;

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ &#34;&lt;INVALID&gt;&#34;, &#34;&#39;;&#39;&#34;, &#34;&#39;(&#39;&#34;, &#34;&#39;)&#39;&#34;, &#34;&#39;,&#39;&#34;, &#34;&#39;.&#39;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&#39;&lt;=&gt;&#39;&#34;, &#34;&#39;&lt;&gt;&#39;&#34;, &#34;&#39;!=&#39;&#34;, &#34;&#39;&lt;&#39;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&#39;&gt;&#39;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&#39;+&#39;&#34;, &#34;&#39;-&#39;&#34;, &#34;&#39;*&#39;&#34;, &#34;&#39;/&#39;&#34;, &#34;&#39;%&#39;&#34;, &#34;&#39;~&#39;&#34;, 
                     &#34;&#39;&amp;&#39;&#34;, &#34;&#39;|&#39;&#34;, &#34;&#39;||&#39;&#34;, &#34;&#39;^&#39;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                     &#34;&#39;/**/&#39;&#34; ]

    symbolicNames = [ &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, 
                      &#34;&lt;INVALID&gt;&#34;, &#34;&lt;INVALID&gt;&#34;, &#34;ABS&#34;, &#34;ACOS&#34;, &#34;ALL&#34;, &#34;AND&#34;, 
                      &#34;ANTI&#34;, &#34;AS&#34;, &#34;ASC&#34;, &#34;ASIN&#34;, &#34;ATAN&#34;, &#34;AVG&#34;, &#34;BETWEEN&#34;, 
                      &#34;BY&#34;, &#34;CASE&#34;, &#34;CEILING&#34;, &#34;CHOOSE&#34;, &#34;COS&#34;, &#34;COT&#34;, &#34;COUNT&#34;, 
                      &#34;CROSS&#34;, &#34;DEGREES&#34;, &#34;DENSE_RANK&#34;, &#34;DESC&#34;, &#34;DISTINCT&#34;, 
                      &#34;DIV&#34;, &#34;ELSE&#34;, &#34;END&#34;, &#34;EXP&#34;, &#34;FALSE&#34;, &#34;FLOOR&#34;, &#34;FROM&#34;, 
                      &#34;FULL&#34;, &#34;GROUP&#34;, &#34;HAVING&#34;, &#34;IF&#34;, &#34;IIF&#34;, &#34;IN&#34;, &#34;INNER&#34;, 
                      &#34;INTERSECT&#34;, &#34;IS&#34;, &#34;JOIN&#34;, &#34;LEFT&#34;, &#34;LIMIT&#34;, &#34;LOG&#34;, 
                      &#34;LOG10&#34;, &#34;MAX&#34;, &#34;MIN&#34;, &#34;NEWID&#34;, &#34;NOT&#34;, &#34;NULL&#34;, &#34;NUMERIC&#34;, 
                      &#34;ON&#34;, &#34;OR&#34;, &#34;ORDER&#34;, &#34;OUTER&#34;, &#34;OVER&#34;, &#34;PARTITION&#34;, 
                      &#34;PERCENTILE_CONT&#34;, &#34;PERCENTILE_DISC&#34;, &#34;PI&#34;, &#34;POWER&#34;, 
                      &#34;RAND&#34;, &#34;RANDOM&#34;, &#34;RANK&#34;, &#34;RIGHT&#34;, &#34;ROUND&#34;, &#34;ROW_NUMBER&#34;, 
                      &#34;ROWNUM&#34;, &#34;SELECT&#34;, &#34;SEMI&#34;, &#34;SIGN&#34;, &#34;SIN&#34;, &#34;SORT&#34;, 
                      &#34;SQL&#34;, &#34;SQRT&#34;, &#34;SQUARE&#34;, &#34;STD&#34;, &#34;STDDEV&#34;, &#34;SUM&#34;, &#34;TAN&#34;, 
                      &#34;THEN&#34;, &#34;TOP&#34;, &#34;TRUE&#34;, &#34;UNION&#34;, &#34;USING&#34;, &#34;VAR&#34;, &#34;VARIANCE&#34;, 
                      &#34;WHEN&#34;, &#34;WHERE&#34;, &#34;EQ&#34;, &#34;NSEQ&#34;, &#34;NEQ&#34;, &#34;NEQJ&#34;, &#34;LT&#34;, 
                      &#34;LTE&#34;, &#34;GT&#34;, &#34;GTE&#34;, &#34;PLUS&#34;, &#34;MINUS&#34;, &#34;ASTERISK&#34;, &#34;SLASH&#34;, 
                      &#34;PERCENT&#34;, &#34;TILDE&#34;, &#34;AMPERSAND&#34;, &#34;PIPE&#34;, &#34;CONCAT_PIPE&#34;, 
                      &#34;HAT&#34;, &#34;STRING&#34;, &#34;INTEGER_VALUE&#34;, &#34;DECIMAL_VALUE&#34;, 
                      &#34;QN2&#34;, &#34;QN3&#34;, &#34;IDENT&#34;, &#34;IDENTIFIER&#34;, &#34;ESCAPED_IDENTIFIER&#34;, 
                      &#34;LETTER&#34;, &#34;SIMPLE_COMMENT&#34;, &#34;BRACKETED_EMPTY_COMMENT&#34;, 
                      &#34;BRACKETED_COMMENT&#34;, &#34;WS&#34;, &#34;SPACE&#34; ]

    RULE_batch = 0
    RULE_query = 1
    RULE_subquery = 2
    RULE_expressionSubquery = 3
    RULE_selectClause = 4
    RULE_fromClause = 5
    RULE_whereClause = 6
    RULE_aggregationClause = 7
    RULE_havingClause = 8
    RULE_orderClause = 9
    RULE_limitClause = 10
    RULE_topClause = 11
    RULE_joinRelation = 12
    RULE_joinType = 13
    RULE_joinCriteria = 14
    RULE_sortItem = 15
    RULE_setQuantifier = 16
    RULE_relation = 17
    RULE_relationPrimary = 18
    RULE_caseExpression = 19
    RULE_namedExpression = 20
    RULE_namedExpressionSeq = 21
    RULE_whenExpression = 22
    RULE_expression = 23
    RULE_allExpression = 24
    RULE_literal = 25
    RULE_booleanExpression = 26
    RULE_predicate = 27
    RULE_comparisonOperator = 28
    RULE_booleanValue = 29
    RULE_functionExpression = 30
    RULE_bareFunction = 31
    RULE_rankingFunction = 32
    RULE_roundFunction = 33
    RULE_powerFunction = 34
    RULE_rankingFunctionName = 35
    RULE_aggregateFunctionName = 36
    RULE_mathFunctionName = 37
    RULE_bareFunctionName = 38
    RULE_overClause = 39
    RULE_aliasedSubquery = 40
    RULE_aliasedTableOrSubquerySeq = 41
    RULE_aliasedTableSeq = 42
    RULE_aliasedTableName = 43
    RULE_qualifiedTableName = 44
    RULE_qualifiedColumnName = 45
    RULE_identifier = 46
    RULE_number = 47

    ruleNames =  [ &#34;batch&#34;, &#34;query&#34;, &#34;subquery&#34;, &#34;expressionSubquery&#34;, &#34;selectClause&#34;, 
                   &#34;fromClause&#34;, &#34;whereClause&#34;, &#34;aggregationClause&#34;, &#34;havingClause&#34;, 
                   &#34;orderClause&#34;, &#34;limitClause&#34;, &#34;topClause&#34;, &#34;joinRelation&#34;, 
                   &#34;joinType&#34;, &#34;joinCriteria&#34;, &#34;sortItem&#34;, &#34;setQuantifier&#34;, 
                   &#34;relation&#34;, &#34;relationPrimary&#34;, &#34;caseExpression&#34;, &#34;namedExpression&#34;, 
                   &#34;namedExpressionSeq&#34;, &#34;whenExpression&#34;, &#34;expression&#34;, 
                   &#34;allExpression&#34;, &#34;literal&#34;, &#34;booleanExpression&#34;, &#34;predicate&#34;, 
                   &#34;comparisonOperator&#34;, &#34;booleanValue&#34;, &#34;functionExpression&#34;, 
                   &#34;bareFunction&#34;, &#34;rankingFunction&#34;, &#34;roundFunction&#34;, &#34;powerFunction&#34;, 
                   &#34;rankingFunctionName&#34;, &#34;aggregateFunctionName&#34;, &#34;mathFunctionName&#34;, 
                   &#34;bareFunctionName&#34;, &#34;overClause&#34;, &#34;aliasedSubquery&#34;, 
                   &#34;aliasedTableOrSubquerySeq&#34;, &#34;aliasedTableSeq&#34;, &#34;aliasedTableName&#34;, 
                   &#34;qualifiedTableName&#34;, &#34;qualifiedColumnName&#34;, &#34;identifier&#34;, 
                   &#34;number&#34; ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    ABS=6
    ACOS=7
    ALL=8
    AND=9
    ANTI=10
    AS=11
    ASC=12
    ASIN=13
    ATAN=14
    AVG=15
    BETWEEN=16
    BY=17
    CASE=18
    CEILING=19
    CHOOSE=20
    COS=21
    COT=22
    COUNT=23
    CROSS=24
    DEGREES=25
    DENSE_RANK=26
    DESC=27
    DISTINCT=28
    DIV=29
    ELSE=30
    END=31
    EXP=32
    FALSE=33
    FLOOR=34
    FROM=35
    FULL=36
    GROUP=37
    HAVING=38
    IF=39
    IIF=40
    IN=41
    INNER=42
    INTERSECT=43
    IS=44
    JOIN=45
    LEFT=46
    LIMIT=47
    LOG=48
    LOG10=49
    MAX=50
    MIN=51
    NEWID=52
    NOT=53
    NULL=54
    NUMERIC=55
    ON=56
    OR=57
    ORDER=58
    OUTER=59
    OVER=60
    PARTITION=61
    PERCENTILE_CONT=62
    PERCENTILE_DISC=63
    PI=64
    POWER=65
    RAND=66
    RANDOM=67
    RANK=68
    RIGHT=69
    ROUND=70
    ROW_NUMBER=71
    ROWNUM=72
    SELECT=73
    SEMI=74
    SIGN=75
    SIN=76
    SORT=77
    SQL=78
    SQRT=79
    SQUARE=80
    STD=81
    STDDEV=82
    SUM=83
    TAN=84
    THEN=85
    TOP=86
    TRUE=87
    UNION=88
    USING=89
    VAR=90
    VARIANCE=91
    WHEN=92
    WHERE=93
    EQ=94
    NSEQ=95
    NEQ=96
    NEQJ=97
    LT=98
    LTE=99
    GT=100
    GTE=101
    PLUS=102
    MINUS=103
    ASTERISK=104
    SLASH=105
    PERCENT=106
    TILDE=107
    AMPERSAND=108
    PIPE=109
    CONCAT_PIPE=110
    HAT=111
    STRING=112
    INTEGER_VALUE=113
    DECIMAL_VALUE=114
    QN2=115
    QN3=116
    IDENT=117
    IDENTIFIER=118
    ESCAPED_IDENTIFIER=119
    LETTER=120
    SIMPLE_COMMENT=121
    BRACKETED_EMPTY_COMMENT=122
    BRACKETED_COMMENT=123
    WS=124
    SPACE=125

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion(&#34;4.8&#34;)
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class BatchContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def query(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.QueryContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.QueryContext,i)


        def EOF(self):
            return self.getToken(SqlSmallParser.EOF, 0)

        def getRuleIndex(self):
            return SqlSmallParser.RULE_batch

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterBatch&#34; ):
                listener.enterBatch(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitBatch&#34; ):
                listener.exitBatch(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitBatch&#34; ):
                return visitor.visitBatch(self)
            else:
                return visitor.visitChildren(self)




    def batch(self):

        localctx = SqlSmallParser.BatchContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_batch)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 96
            self.query()
            self.state = 101
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,0,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 97
                    self.match(SqlSmallParser.T__0)
                    self.state = 98
                    self.query() 
                self.state = 103
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,0,self._ctx)

            self.state = 105
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.T__0:
                self.state = 104
                self.match(SqlSmallParser.T__0)


            self.state = 107
            self.match(SqlSmallParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QueryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def selectClause(self):
            return self.getTypedRuleContext(SqlSmallParser.SelectClauseContext,0)


        def fromClause(self):
            return self.getTypedRuleContext(SqlSmallParser.FromClauseContext,0)


        def whereClause(self):
            return self.getTypedRuleContext(SqlSmallParser.WhereClauseContext,0)


        def aggregationClause(self):
            return self.getTypedRuleContext(SqlSmallParser.AggregationClauseContext,0)


        def havingClause(self):
            return self.getTypedRuleContext(SqlSmallParser.HavingClauseContext,0)


        def orderClause(self):
            return self.getTypedRuleContext(SqlSmallParser.OrderClauseContext,0)


        def limitClause(self):
            return self.getTypedRuleContext(SqlSmallParser.LimitClauseContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_query

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterQuery&#34; ):
                listener.enterQuery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitQuery&#34; ):
                listener.exitQuery(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitQuery&#34; ):
                return visitor.visitQuery(self)
            else:
                return visitor.visitChildren(self)




    def query(self):

        localctx = SqlSmallParser.QueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_query)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 109
            self.selectClause()
            self.state = 110
            self.fromClause()
            self.state = 112
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.WHERE:
                self.state = 111
                self.whereClause()


            self.state = 115
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.GROUP:
                self.state = 114
                self.aggregationClause()


            self.state = 118
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.HAVING:
                self.state = 117
                self.havingClause()


            self.state = 121
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.ORDER:
                self.state = 120
                self.orderClause()


            self.state = 124
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.LIMIT:
                self.state = 123
                self.limitClause()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SubqueryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def selectClause(self):
            return self.getTypedRuleContext(SqlSmallParser.SelectClauseContext,0)


        def fromClause(self):
            return self.getTypedRuleContext(SqlSmallParser.FromClauseContext,0)


        def whereClause(self):
            return self.getTypedRuleContext(SqlSmallParser.WhereClauseContext,0)


        def aggregationClause(self):
            return self.getTypedRuleContext(SqlSmallParser.AggregationClauseContext,0)


        def havingClause(self):
            return self.getTypedRuleContext(SqlSmallParser.HavingClauseContext,0)


        def orderClause(self):
            return self.getTypedRuleContext(SqlSmallParser.OrderClauseContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_subquery

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterSubquery&#34; ):
                listener.enterSubquery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitSubquery&#34; ):
                listener.exitSubquery(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitSubquery&#34; ):
                return visitor.visitSubquery(self)
            else:
                return visitor.visitChildren(self)




    def subquery(self):

        localctx = SqlSmallParser.SubqueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_subquery)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 126
            self.match(SqlSmallParser.T__1)
            self.state = 127
            self.selectClause()
            self.state = 128
            self.fromClause()
            self.state = 130
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.WHERE:
                self.state = 129
                self.whereClause()


            self.state = 133
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.GROUP:
                self.state = 132
                self.aggregationClause()


            self.state = 136
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.HAVING:
                self.state = 135
                self.havingClause()


            self.state = 139
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.ORDER:
                self.state = 138
                self.orderClause()


            self.state = 141
            self.match(SqlSmallParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionSubqueryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def subquery(self):
            return self.getTypedRuleContext(SqlSmallParser.SubqueryContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_expressionSubquery

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterExpressionSubquery&#34; ):
                listener.enterExpressionSubquery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitExpressionSubquery&#34; ):
                listener.exitExpressionSubquery(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitExpressionSubquery&#34; ):
                return visitor.visitExpressionSubquery(self)
            else:
                return visitor.visitChildren(self)




    def expressionSubquery(self):

        localctx = SqlSmallParser.ExpressionSubqueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_expressionSubquery)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 143
            self.subquery()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SelectClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SELECT(self):
            return self.getToken(SqlSmallParser.SELECT, 0)

        def namedExpressionSeq(self):
            return self.getTypedRuleContext(SqlSmallParser.NamedExpressionSeqContext,0)


        def setQuantifier(self):
            return self.getTypedRuleContext(SqlSmallParser.SetQuantifierContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_selectClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterSelectClause&#34; ):
                listener.enterSelectClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitSelectClause&#34; ):
                listener.exitSelectClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitSelectClause&#34; ):
                return visitor.visitSelectClause(self)
            else:
                return visitor.visitChildren(self)




    def selectClause(self):

        localctx = SqlSmallParser.SelectClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_selectClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 145
            self.match(SqlSmallParser.SELECT)
            self.state = 147
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.ALL or _la==SqlSmallParser.DISTINCT or _la==SqlSmallParser.TOP:
                self.state = 146
                self.setQuantifier()


            self.state = 149
            self.namedExpressionSeq()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FromClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FROM(self):
            return self.getToken(SqlSmallParser.FROM, 0)

        def relation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.RelationContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.RelationContext,i)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_fromClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterFromClause&#34; ):
                listener.enterFromClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitFromClause&#34; ):
                listener.exitFromClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitFromClause&#34; ):
                return visitor.visitFromClause(self)
            else:
                return visitor.visitChildren(self)




    def fromClause(self):

        localctx = SqlSmallParser.FromClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_fromClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 151
            self.match(SqlSmallParser.FROM)
            self.state = 152
            self.relation()
            self.state = 157
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SqlSmallParser.T__3:
                self.state = 153
                self.match(SqlSmallParser.T__3)
                self.state = 154
                self.relation()
                self.state = 159
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhereClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHERE(self):
            return self.getToken(SqlSmallParser.WHERE, 0)

        def booleanExpression(self):
            return self.getTypedRuleContext(SqlSmallParser.BooleanExpressionContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_whereClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterWhereClause&#34; ):
                listener.enterWhereClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitWhereClause&#34; ):
                listener.exitWhereClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitWhereClause&#34; ):
                return visitor.visitWhereClause(self)
            else:
                return visitor.visitChildren(self)




    def whereClause(self):

        localctx = SqlSmallParser.WhereClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_whereClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 160
            self.match(SqlSmallParser.WHERE)
            self.state = 161
            self.booleanExpression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregationClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._expression = None # ExpressionContext
            self.groupingExpressions = list() # of ExpressionContexts

        def GROUP(self):
            return self.getToken(SqlSmallParser.GROUP, 0)

        def BY(self):
            return self.getToken(SqlSmallParser.BY, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,i)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_aggregationClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterAggregationClause&#34; ):
                listener.enterAggregationClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitAggregationClause&#34; ):
                listener.exitAggregationClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitAggregationClause&#34; ):
                return visitor.visitAggregationClause(self)
            else:
                return visitor.visitChildren(self)




    def aggregationClause(self):

        localctx = SqlSmallParser.AggregationClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_aggregationClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 163
            self.match(SqlSmallParser.GROUP)
            self.state = 164
            self.match(SqlSmallParser.BY)
            self.state = 165
            localctx._expression = self.expression(0)
            localctx.groupingExpressions.append(localctx._expression)
            self.state = 170
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SqlSmallParser.T__3:
                self.state = 166
                self.match(SqlSmallParser.T__3)
                self.state = 167
                localctx._expression = self.expression(0)
                localctx.groupingExpressions.append(localctx._expression)
                self.state = 172
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class HavingClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HAVING(self):
            return self.getToken(SqlSmallParser.HAVING, 0)

        def booleanExpression(self):
            return self.getTypedRuleContext(SqlSmallParser.BooleanExpressionContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_havingClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterHavingClause&#34; ):
                listener.enterHavingClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitHavingClause&#34; ):
                listener.exitHavingClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitHavingClause&#34; ):
                return visitor.visitHavingClause(self)
            else:
                return visitor.visitChildren(self)




    def havingClause(self):

        localctx = SqlSmallParser.HavingClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_havingClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 173
            self.match(SqlSmallParser.HAVING)
            self.state = 174
            self.booleanExpression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OrderClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._sortItem = None # SortItemContext
            self.order = list() # of SortItemContexts

        def ORDER(self):
            return self.getToken(SqlSmallParser.ORDER, 0)

        def BY(self):
            return self.getToken(SqlSmallParser.BY, 0)

        def sortItem(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.SortItemContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.SortItemContext,i)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_orderClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterOrderClause&#34; ):
                listener.enterOrderClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitOrderClause&#34; ):
                listener.exitOrderClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitOrderClause&#34; ):
                return visitor.visitOrderClause(self)
            else:
                return visitor.visitChildren(self)




    def orderClause(self):

        localctx = SqlSmallParser.OrderClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_orderClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 176
            self.match(SqlSmallParser.ORDER)
            self.state = 177
            self.match(SqlSmallParser.BY)
            self.state = 178
            localctx._sortItem = self.sortItem()
            localctx.order.append(localctx._sortItem)
            self.state = 183
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SqlSmallParser.T__3:
                self.state = 179
                self.match(SqlSmallParser.T__3)
                self.state = 180
                localctx._sortItem = self.sortItem()
                localctx.order.append(localctx._sortItem)
                self.state = 185
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LimitClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.n = None # NumberContext

        def LIMIT(self):
            return self.getToken(SqlSmallParser.LIMIT, 0)

        def number(self):
            return self.getTypedRuleContext(SqlSmallParser.NumberContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_limitClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterLimitClause&#34; ):
                listener.enterLimitClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitLimitClause&#34; ):
                listener.exitLimitClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitLimitClause&#34; ):
                return visitor.visitLimitClause(self)
            else:
                return visitor.visitChildren(self)




    def limitClause(self):

        localctx = SqlSmallParser.LimitClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_limitClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 186
            self.match(SqlSmallParser.LIMIT)
            self.state = 187
            localctx.n = self.number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TopClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.n = None # NumberContext

        def TOP(self):
            return self.getToken(SqlSmallParser.TOP, 0)

        def number(self):
            return self.getTypedRuleContext(SqlSmallParser.NumberContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_topClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterTopClause&#34; ):
                listener.enterTopClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitTopClause&#34; ):
                listener.exitTopClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitTopClause&#34; ):
                return visitor.visitTopClause(self)
            else:
                return visitor.visitChildren(self)




    def topClause(self):

        localctx = SqlSmallParser.TopClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_topClause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 189
            self.match(SqlSmallParser.TOP)
            self.state = 190
            localctx.n = self.number()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class JoinRelationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.right = None # RelationPrimaryContext

        def JOIN(self):
            return self.getToken(SqlSmallParser.JOIN, 0)

        def relationPrimary(self):
            return self.getTypedRuleContext(SqlSmallParser.RelationPrimaryContext,0)


        def joinType(self):
            return self.getTypedRuleContext(SqlSmallParser.JoinTypeContext,0)


        def joinCriteria(self):
            return self.getTypedRuleContext(SqlSmallParser.JoinCriteriaContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_joinRelation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterJoinRelation&#34; ):
                listener.enterJoinRelation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitJoinRelation&#34; ):
                listener.exitJoinRelation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitJoinRelation&#34; ):
                return visitor.visitJoinRelation(self)
            else:
                return visitor.visitChildren(self)




    def joinRelation(self):

        localctx = SqlSmallParser.JoinRelationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_joinRelation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 192
            self.joinType()
            self.state = 193
            self.match(SqlSmallParser.JOIN)
            self.state = 194
            localctx.right = self.relationPrimary()
            self.state = 196
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.ON or _la==SqlSmallParser.USING:
                self.state = 195
                self.joinCriteria()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class JoinTypeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INNER(self):
            return self.getToken(SqlSmallParser.INNER, 0)

        def CROSS(self):
            return self.getToken(SqlSmallParser.CROSS, 0)

        def LEFT(self):
            return self.getToken(SqlSmallParser.LEFT, 0)

        def OUTER(self):
            return self.getToken(SqlSmallParser.OUTER, 0)

        def SEMI(self):
            return self.getToken(SqlSmallParser.SEMI, 0)

        def RIGHT(self):
            return self.getToken(SqlSmallParser.RIGHT, 0)

        def FULL(self):
            return self.getToken(SqlSmallParser.FULL, 0)

        def ANTI(self):
            return self.getToken(SqlSmallParser.ANTI, 0)

        def getRuleIndex(self):
            return SqlSmallParser.RULE_joinType

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterJoinType&#34; ):
                listener.enterJoinType(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitJoinType&#34; ):
                listener.exitJoinType(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitJoinType&#34; ):
                return visitor.visitJoinType(self)
            else:
                return visitor.visitChildren(self)




    def joinType(self):

        localctx = SqlSmallParser.JoinTypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_joinType)
        self._la = 0 # Token type
        try:
            self.state = 222
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 199
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlSmallParser.INNER:
                    self.state = 198
                    self.match(SqlSmallParser.INNER)


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 201
                self.match(SqlSmallParser.CROSS)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 202
                self.match(SqlSmallParser.LEFT)
                self.state = 204
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlSmallParser.OUTER:
                    self.state = 203
                    self.match(SqlSmallParser.OUTER)


                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 207
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlSmallParser.LEFT:
                    self.state = 206
                    self.match(SqlSmallParser.LEFT)


                self.state = 209
                self.match(SqlSmallParser.SEMI)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 210
                self.match(SqlSmallParser.RIGHT)
                self.state = 212
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlSmallParser.OUTER:
                    self.state = 211
                    self.match(SqlSmallParser.OUTER)


                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 214
                self.match(SqlSmallParser.FULL)
                self.state = 216
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlSmallParser.OUTER:
                    self.state = 215
                    self.match(SqlSmallParser.OUTER)


                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 219
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlSmallParser.LEFT:
                    self.state = 218
                    self.match(SqlSmallParser.LEFT)


                self.state = 221
                self.match(SqlSmallParser.ANTI)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class JoinCriteriaContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlSmallParser.RULE_joinCriteria

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class BooleanJoinContext(JoinCriteriaContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.JoinCriteriaContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ON(self):
            return self.getToken(SqlSmallParser.ON, 0)
        def booleanExpression(self):
            return self.getTypedRuleContext(SqlSmallParser.BooleanExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterBooleanJoin&#34; ):
                listener.enterBooleanJoin(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitBooleanJoin&#34; ):
                listener.exitBooleanJoin(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitBooleanJoin&#34; ):
                return visitor.visitBooleanJoin(self)
            else:
                return visitor.visitChildren(self)


    class UsingJoinContext(JoinCriteriaContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.JoinCriteriaContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def USING(self):
            return self.getToken(SqlSmallParser.USING, 0)
        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.IdentifierContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterUsingJoin&#34; ):
                listener.enterUsingJoin(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitUsingJoin&#34; ):
                listener.exitUsingJoin(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitUsingJoin&#34; ):
                return visitor.visitUsingJoin(self)
            else:
                return visitor.visitChildren(self)



    def joinCriteria(self):

        localctx = SqlSmallParser.JoinCriteriaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_joinCriteria)
        self._la = 0 # Token type
        try:
            self.state = 238
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlSmallParser.ON]:
                localctx = SqlSmallParser.BooleanJoinContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 224
                self.match(SqlSmallParser.ON)
                self.state = 225
                self.booleanExpression(0)
                pass
            elif token in [SqlSmallParser.USING]:
                localctx = SqlSmallParser.UsingJoinContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 226
                self.match(SqlSmallParser.USING)
                self.state = 227
                self.match(SqlSmallParser.T__1)
                self.state = 228
                self.identifier()
                self.state = 233
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==SqlSmallParser.T__3:
                    self.state = 229
                    self.match(SqlSmallParser.T__3)
                    self.state = 230
                    self.identifier()
                    self.state = 235
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 236
                self.match(SqlSmallParser.T__2)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SortItemContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.ordering = None # Token

        def expression(self):
            return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,0)


        def ASC(self):
            return self.getToken(SqlSmallParser.ASC, 0)

        def DESC(self):
            return self.getToken(SqlSmallParser.DESC, 0)

        def getRuleIndex(self):
            return SqlSmallParser.RULE_sortItem

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterSortItem&#34; ):
                listener.enterSortItem(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitSortItem&#34; ):
                listener.exitSortItem(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitSortItem&#34; ):
                return visitor.visitSortItem(self)
            else:
                return visitor.visitChildren(self)




    def sortItem(self):

        localctx = SqlSmallParser.SortItemContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_sortItem)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 240
            self.expression(0)
            self.state = 242
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.ASC or _la==SqlSmallParser.DESC:
                self.state = 241
                localctx.ordering = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==SqlSmallParser.ASC or _la==SqlSmallParser.DESC):
                    localctx.ordering = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SetQuantifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DISTINCT(self):
            return self.getToken(SqlSmallParser.DISTINCT, 0)

        def ALL(self):
            return self.getToken(SqlSmallParser.ALL, 0)

        def topClause(self):
            return self.getTypedRuleContext(SqlSmallParser.TopClauseContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_setQuantifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterSetQuantifier&#34; ):
                listener.enterSetQuantifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitSetQuantifier&#34; ):
                listener.exitSetQuantifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitSetQuantifier&#34; ):
                return visitor.visitSetQuantifier(self)
            else:
                return visitor.visitChildren(self)




    def setQuantifier(self):

        localctx = SqlSmallParser.SetQuantifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_setQuantifier)
        try:
            self.state = 247
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlSmallParser.DISTINCT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 244
                self.match(SqlSmallParser.DISTINCT)
                pass
            elif token in [SqlSmallParser.ALL]:
                self.enterOuterAlt(localctx, 2)
                self.state = 245
                self.match(SqlSmallParser.ALL)
                pass
            elif token in [SqlSmallParser.TOP]:
                self.enterOuterAlt(localctx, 3)
                self.state = 246
                self.topClause()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RelationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def relationPrimary(self):
            return self.getTypedRuleContext(SqlSmallParser.RelationPrimaryContext,0)


        def joinRelation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.JoinRelationContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.JoinRelationContext,i)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_relation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterRelation&#34; ):
                listener.enterRelation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitRelation&#34; ):
                listener.exitRelation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitRelation&#34; ):
                return visitor.visitRelation(self)
            else:
                return visitor.visitChildren(self)




    def relation(self):

        localctx = SqlSmallParser.RelationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_relation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 249
            self.relationPrimary()
            self.state = 253
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) &amp; ~0x3f) == 0 and ((1 &lt;&lt; _la) &amp; ((1 &lt;&lt; SqlSmallParser.ANTI) | (1 &lt;&lt; SqlSmallParser.CROSS) | (1 &lt;&lt; SqlSmallParser.FULL) | (1 &lt;&lt; SqlSmallParser.INNER) | (1 &lt;&lt; SqlSmallParser.JOIN) | (1 &lt;&lt; SqlSmallParser.LEFT))) != 0) or _la==SqlSmallParser.RIGHT or _la==SqlSmallParser.SEMI:
                self.state = 250
                self.joinRelation()
                self.state = 255
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RelationPrimaryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlSmallParser.RULE_relationPrimary

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class AliasedRelationContext(RelationPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.RelationPrimaryContext
            super().__init__(parser)
            self.alias = None # IdentifierContext
            self.copyFrom(ctx)

        def relation(self):
            return self.getTypedRuleContext(SqlSmallParser.RelationContext,0)

        def AS(self):
            return self.getToken(SqlSmallParser.AS, 0)
        def identifier(self):
            return self.getTypedRuleContext(SqlSmallParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterAliasedRelation&#34; ):
                listener.enterAliasedRelation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitAliasedRelation&#34; ):
                listener.exitAliasedRelation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitAliasedRelation&#34; ):
                return visitor.visitAliasedRelation(self)
            else:
                return visitor.visitChildren(self)


    class AliasedQueryContext(RelationPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.RelationPrimaryContext
            super().__init__(parser)
            self.alias = None # IdentifierContext
            self.copyFrom(ctx)

        def subquery(self):
            return self.getTypedRuleContext(SqlSmallParser.SubqueryContext,0)

        def AS(self):
            return self.getToken(SqlSmallParser.AS, 0)
        def identifier(self):
            return self.getTypedRuleContext(SqlSmallParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterAliasedQuery&#34; ):
                listener.enterAliasedQuery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitAliasedQuery&#34; ):
                listener.exitAliasedQuery(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitAliasedQuery&#34; ):
                return visitor.visitAliasedQuery(self)
            else:
                return visitor.visitChildren(self)


    class TableContext(RelationPrimaryContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.RelationPrimaryContext
            super().__init__(parser)
            self.alias = None # IdentifierContext
            self.copyFrom(ctx)

        def qualifiedTableName(self):
            return self.getTypedRuleContext(SqlSmallParser.QualifiedTableNameContext,0)

        def AS(self):
            return self.getToken(SqlSmallParser.AS, 0)
        def identifier(self):
            return self.getTypedRuleContext(SqlSmallParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterTable&#34; ):
                listener.enterTable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitTable&#34; ):
                listener.exitTable(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitTable&#34; ):
                return visitor.visitTable(self)
            else:
                return visitor.visitChildren(self)



    def relationPrimary(self):

        localctx = SqlSmallParser.RelationPrimaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_relationPrimary)
        self._la = 0 # Token type
        try:
            self.state = 273
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,31,self._ctx)
            if la_ == 1:
                localctx = SqlSmallParser.TableContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 256
                self.qualifiedTableName()
                self.state = 259
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlSmallParser.AS:
                    self.state = 257
                    self.match(SqlSmallParser.AS)
                    self.state = 258
                    localctx.alias = self.identifier()


                pass

            elif la_ == 2:
                localctx = SqlSmallParser.AliasedQueryContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 261
                self.subquery()
                self.state = 264
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlSmallParser.AS:
                    self.state = 262
                    self.match(SqlSmallParser.AS)
                    self.state = 263
                    localctx.alias = self.identifier()


                pass

            elif la_ == 3:
                localctx = SqlSmallParser.AliasedRelationContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 266
                self.match(SqlSmallParser.T__1)
                self.state = 267
                self.relation()
                self.state = 268
                self.match(SqlSmallParser.T__2)
                self.state = 271
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlSmallParser.AS:
                    self.state = 269
                    self.match(SqlSmallParser.AS)
                    self.state = 270
                    localctx.alias = self.identifier()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class CaseExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.baseCaseExpr = None # ExpressionContext
            self.elseExpr = None # ExpressionContext

        def CASE(self):
            return self.getToken(SqlSmallParser.CASE, 0)

        def END(self):
            return self.getToken(SqlSmallParser.END, 0)

        def whenExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.WhenExpressionContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.WhenExpressionContext,i)


        def ELSE(self):
            return self.getToken(SqlSmallParser.ELSE, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,i)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_caseExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterCaseExpression&#34; ):
                listener.enterCaseExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitCaseExpression&#34; ):
                listener.exitCaseExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitCaseExpression&#34; ):
                return visitor.visitCaseExpression(self)
            else:
                return visitor.visitChildren(self)




    def caseExpression(self):

        localctx = SqlSmallParser.CaseExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_caseExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 275
            self.match(SqlSmallParser.CASE)
            self.state = 277
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) &amp; ~0x3f) == 0 and ((1 &lt;&lt; _la) &amp; ((1 &lt;&lt; SqlSmallParser.T__1) | (1 &lt;&lt; SqlSmallParser.ABS) | (1 &lt;&lt; SqlSmallParser.ACOS) | (1 &lt;&lt; SqlSmallParser.ASIN) | (1 &lt;&lt; SqlSmallParser.ATAN) | (1 &lt;&lt; SqlSmallParser.AVG) | (1 &lt;&lt; SqlSmallParser.CASE) | (1 &lt;&lt; SqlSmallParser.CEILING) | (1 &lt;&lt; SqlSmallParser.CHOOSE) | (1 &lt;&lt; SqlSmallParser.COS) | (1 &lt;&lt; SqlSmallParser.COUNT) | (1 &lt;&lt; SqlSmallParser.DEGREES) | (1 &lt;&lt; SqlSmallParser.DENSE_RANK) | (1 &lt;&lt; SqlSmallParser.EXP) | (1 &lt;&lt; SqlSmallParser.FALSE) | (1 &lt;&lt; SqlSmallParser.FLOOR) | (1 &lt;&lt; SqlSmallParser.IIF) | (1 &lt;&lt; SqlSmallParser.LOG) | (1 &lt;&lt; SqlSmallParser.LOG10) | (1 &lt;&lt; SqlSmallParser.MAX) | (1 &lt;&lt; SqlSmallParser.MIN) | (1 &lt;&lt; SqlSmallParser.NEWID) | (1 &lt;&lt; SqlSmallParser.NULL) | (1 &lt;&lt; SqlSmallParser.PERCENTILE_CONT) | (1 &lt;&lt; SqlSmallParser.PERCENTILE_DISC))) != 0) or ((((_la - 64)) &amp; ~0x3f) == 0 and ((1 &lt;&lt; (_la - 64)) &amp; ((1 &lt;&lt; (SqlSmallParser.PI - 64)) | (1 &lt;&lt; (SqlSmallParser.POWER - 64)) | (1 &lt;&lt; (SqlSmallParser.RAND - 64)) | (1 &lt;&lt; (SqlSmallParser.RANDOM - 64)) | (1 &lt;&lt; (SqlSmallParser.RANK - 64)) | (1 &lt;&lt; (SqlSmallParser.ROUND - 64)) | (1 &lt;&lt; (SqlSmallParser.ROW_NUMBER - 64)) | (1 &lt;&lt; (SqlSmallParser.SIGN - 64)) | (1 &lt;&lt; (SqlSmallParser.SIN - 64)) | (1 &lt;&lt; (SqlSmallParser.SQRT - 64)) | (1 &lt;&lt; (SqlSmallParser.SQUARE - 64)) | (1 &lt;&lt; (SqlSmallParser.STD - 64)) | (1 &lt;&lt; (SqlSmallParser.STDDEV - 64)) | (1 &lt;&lt; (SqlSmallParser.SUM - 64)) | (1 &lt;&lt; (SqlSmallParser.TAN - 64)) | (1 &lt;&lt; (SqlSmallParser.TRUE - 64)) | (1 &lt;&lt; (SqlSmallParser.VAR - 64)) | (1 &lt;&lt; (SqlSmallParser.VARIANCE - 64)) | (1 &lt;&lt; (SqlSmallParser.MINUS - 64)) | (1 &lt;&lt; (SqlSmallParser.ASTERISK - 64)) | (1 &lt;&lt; (SqlSmallParser.STRING - 64)) | (1 &lt;&lt; (SqlSmallParser.INTEGER_VALUE - 64)) | (1 &lt;&lt; (SqlSmallParser.DECIMAL_VALUE - 64)) | (1 &lt;&lt; (SqlSmallParser.QN2 - 64)) | (1 &lt;&lt; (SqlSmallParser.IDENT - 64)))) != 0):
                self.state = 276
                localctx.baseCaseExpr = self.expression(0)


            self.state = 280 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 279
                self.whenExpression()
                self.state = 282 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==SqlSmallParser.WHEN):
                    break

            self.state = 286
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.ELSE:
                self.state = 284
                self.match(SqlSmallParser.ELSE)
                self.state = 285
                localctx.elseExpr = self.expression(0)


            self.state = 288
            self.match(SqlSmallParser.END)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NamedExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext

        def expression(self):
            return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,0)


        def AS(self):
            return self.getToken(SqlSmallParser.AS, 0)

        def identifier(self):
            return self.getTypedRuleContext(SqlSmallParser.IdentifierContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_namedExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterNamedExpression&#34; ):
                listener.enterNamedExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitNamedExpression&#34; ):
                listener.exitNamedExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitNamedExpression&#34; ):
                return visitor.visitNamedExpression(self)
            else:
                return visitor.visitChildren(self)




    def namedExpression(self):

        localctx = SqlSmallParser.NamedExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_namedExpression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 290
            self.expression(0)
            self.state = 293
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.AS:
                self.state = 291
                self.match(SqlSmallParser.AS)
                self.state = 292
                localctx.name = self.identifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NamedExpressionSeqContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def namedExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.NamedExpressionContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.NamedExpressionContext,i)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_namedExpressionSeq

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterNamedExpressionSeq&#34; ):
                listener.enterNamedExpressionSeq(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitNamedExpressionSeq&#34; ):
                listener.exitNamedExpressionSeq(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitNamedExpressionSeq&#34; ):
                return visitor.visitNamedExpressionSeq(self)
            else:
                return visitor.visitChildren(self)




    def namedExpressionSeq(self):

        localctx = SqlSmallParser.NamedExpressionSeqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_namedExpressionSeq)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 295
            self.namedExpression()
            self.state = 300
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SqlSmallParser.T__3:
                self.state = 296
                self.match(SqlSmallParser.T__3)
                self.state = 297
                self.namedExpression()
                self.state = 302
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class WhenExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.baseBoolExpr = None # BooleanExpressionContext
            self.baseWhenExpr = None # ExpressionContext
            self.thenExpr = None # ExpressionContext

        def WHEN(self):
            return self.getToken(SqlSmallParser.WHEN, 0)

        def THEN(self):
            return self.getToken(SqlSmallParser.THEN, 0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,i)


        def booleanExpression(self):
            return self.getTypedRuleContext(SqlSmallParser.BooleanExpressionContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_whenExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterWhenExpression&#34; ):
                listener.enterWhenExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitWhenExpression&#34; ):
                listener.exitWhenExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitWhenExpression&#34; ):
                return visitor.visitWhenExpression(self)
            else:
                return visitor.visitChildren(self)




    def whenExpression(self):

        localctx = SqlSmallParser.WhenExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_whenExpression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 303
            self.match(SqlSmallParser.WHEN)
            self.state = 306
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,37,self._ctx)
            if la_ == 1:
                self.state = 304
                localctx.baseBoolExpr = self.booleanExpression(0)
                pass

            elif la_ == 2:
                self.state = 305
                localctx.baseWhenExpr = self.expression(0)
                pass


            self.state = 308
            self.match(SqlSmallParser.THEN)
            self.state = 309
            localctx.thenExpr = self.expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlSmallParser.RULE_expression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class AddContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.ExpressionContext
            super().__init__(parser)
            self.left = None # ExpressionContext
            self.op = None # Token
            self.right = None # ExpressionContext
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,i)

        def PLUS(self):
            return self.getToken(SqlSmallParser.PLUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterAdd&#34; ):
                listener.enterAdd(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitAdd&#34; ):
                listener.exitAdd(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitAdd&#34; ):
                return visitor.visitAdd(self)
            else:
                return visitor.visitChildren(self)


    class SubtractContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.ExpressionContext
            super().__init__(parser)
            self.left = None # ExpressionContext
            self.op = None # Token
            self.right = None # ExpressionContext
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,i)

        def MINUS(self):
            return self.getToken(SqlSmallParser.MINUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterSubtract&#34; ):
                listener.enterSubtract(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitSubtract&#34; ):
                listener.exitSubtract(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitSubtract&#34; ):
                return visitor.visitSubtract(self)
            else:
                return visitor.visitChildren(self)


    class NestedExprContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterNestedExpr&#34; ):
                listener.enterNestedExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitNestedExpr&#34; ):
                listener.exitNestedExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitNestedExpr&#34; ):
                return visitor.visitNestedExpr(self)
            else:
                return visitor.visitChildren(self)


    class SubqueryExprContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expressionSubquery(self):
            return self.getTypedRuleContext(SqlSmallParser.ExpressionSubqueryContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterSubqueryExpr&#34; ):
                listener.enterSubqueryExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitSubqueryExpr&#34; ):
                listener.exitSubqueryExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitSubqueryExpr&#34; ):
                return visitor.visitSubqueryExpr(self)
            else:
                return visitor.visitChildren(self)


    class AllExprContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def allExpression(self):
            return self.getTypedRuleContext(SqlSmallParser.AllExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterAllExpr&#34; ):
                listener.enterAllExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitAllExpr&#34; ):
                listener.exitAllExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitAllExpr&#34; ):
                return visitor.visitAllExpr(self)
            else:
                return visitor.visitChildren(self)


    class FunctionExprContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def functionExpression(self):
            return self.getTypedRuleContext(SqlSmallParser.FunctionExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterFunctionExpr&#34; ):
                listener.enterFunctionExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitFunctionExpr&#34; ):
                listener.exitFunctionExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitFunctionExpr&#34; ):
                return visitor.visitFunctionExpr(self)
            else:
                return visitor.visitChildren(self)


    class RankFunctionContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def rankingFunction(self):
            return self.getTypedRuleContext(SqlSmallParser.RankingFunctionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterRankFunction&#34; ):
                listener.enterRankFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitRankFunction&#34; ):
                listener.exitRankFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitRankFunction&#34; ):
                return visitor.visitRankFunction(self)
            else:
                return visitor.visitChildren(self)


    class LiteralExprContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def literal(self):
            return self.getTypedRuleContext(SqlSmallParser.LiteralContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterLiteralExpr&#34; ):
                listener.enterLiteralExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitLiteralExpr&#34; ):
                listener.exitLiteralExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitLiteralExpr&#34; ):
                return visitor.visitLiteralExpr(self)
            else:
                return visitor.visitChildren(self)


    class DivideContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.ExpressionContext
            super().__init__(parser)
            self.left = None # ExpressionContext
            self.op = None # Token
            self.right = None # ExpressionContext
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,i)

        def SLASH(self):
            return self.getToken(SqlSmallParser.SLASH, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterDivide&#34; ):
                listener.enterDivide(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitDivide&#34; ):
                listener.exitDivide(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitDivide&#34; ):
                return visitor.visitDivide(self)
            else:
                return visitor.visitChildren(self)


    class CaseExprContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.ExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def caseExpression(self):
            return self.getTypedRuleContext(SqlSmallParser.CaseExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterCaseExpr&#34; ):
                listener.enterCaseExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitCaseExpr&#34; ):
                listener.exitCaseExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitCaseExpr&#34; ):
                return visitor.visitCaseExpr(self)
            else:
                return visitor.visitChildren(self)


    class MultiplyContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.ExpressionContext
            super().__init__(parser)
            self.left = None # ExpressionContext
            self.op = None # Token
            self.right = None # ExpressionContext
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,i)

        def ASTERISK(self):
            return self.getToken(SqlSmallParser.ASTERISK, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterMultiply&#34; ):
                listener.enterMultiply(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitMultiply&#34; ):
                listener.exitMultiply(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitMultiply&#34; ):
                return visitor.visitMultiply(self)
            else:
                return visitor.visitChildren(self)


    class ModuloContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.ExpressionContext
            super().__init__(parser)
            self.left = None # ExpressionContext
            self.op = None # Token
            self.right = None # ExpressionContext
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,i)

        def PERCENT(self):
            return self.getToken(SqlSmallParser.PERCENT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterModulo&#34; ):
                listener.enterModulo(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitModulo&#34; ):
                listener.exitModulo(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitModulo&#34; ):
                return visitor.visitModulo(self)
            else:
                return visitor.visitChildren(self)


    class ColumnNameContext(ExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.ExpressionContext
            super().__init__(parser)
            self.name = None # QualifiedColumnNameContext
            self.copyFrom(ctx)

        def qualifiedColumnName(self):
            return self.getTypedRuleContext(SqlSmallParser.QualifiedColumnNameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterColumnName&#34; ):
                listener.enterColumnName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitColumnName&#34; ):
                listener.exitColumnName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitColumnName&#34; ):
                return visitor.visitColumnName(self)
            else:
                return visitor.visitChildren(self)



    def expression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = SqlSmallParser.ExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 46
        self.enterRecursionRule(localctx, 46, self.RULE_expression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 323
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,38,self._ctx)
            if la_ == 1:
                localctx = SqlSmallParser.ColumnNameContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 312
                localctx.name = self.qualifiedColumnName()
                pass

            elif la_ == 2:
                localctx = SqlSmallParser.CaseExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 313
                self.caseExpression()
                pass

            elif la_ == 3:
                localctx = SqlSmallParser.AllExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 314
                self.allExpression()
                pass

            elif la_ == 4:
                localctx = SqlSmallParser.LiteralExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 315
                self.literal()
                pass

            elif la_ == 5:
                localctx = SqlSmallParser.RankFunctionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 316
                self.rankingFunction()
                pass

            elif la_ == 6:
                localctx = SqlSmallParser.FunctionExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 317
                self.functionExpression()
                pass

            elif la_ == 7:
                localctx = SqlSmallParser.SubqueryExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 318
                self.expressionSubquery()
                pass

            elif la_ == 8:
                localctx = SqlSmallParser.NestedExprContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 319
                self.match(SqlSmallParser.T__1)
                self.state = 320
                self.expression(0)
                self.state = 321
                self.match(SqlSmallParser.T__2)
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 342
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,40,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 340
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,39,self._ctx)
                    if la_ == 1:
                        localctx = SqlSmallParser.MultiplyContext(self, SqlSmallParser.ExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 325
                        if not self.precpred(self._ctx, 12):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, &#34;self.precpred(self._ctx, 12)&#34;)
                        self.state = 326
                        localctx.op = self.match(SqlSmallParser.ASTERISK)
                        self.state = 327
                        localctx.right = self.expression(13)
                        pass

                    elif la_ == 2:
                        localctx = SqlSmallParser.DivideContext(self, SqlSmallParser.ExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 328
                        if not self.precpred(self._ctx, 11):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, &#34;self.precpred(self._ctx, 11)&#34;)
                        self.state = 329
                        localctx.op = self.match(SqlSmallParser.SLASH)
                        self.state = 330
                        localctx.right = self.expression(12)
                        pass

                    elif la_ == 3:
                        localctx = SqlSmallParser.ModuloContext(self, SqlSmallParser.ExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 331
                        if not self.precpred(self._ctx, 10):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, &#34;self.precpred(self._ctx, 10)&#34;)
                        self.state = 332
                        localctx.op = self.match(SqlSmallParser.PERCENT)
                        self.state = 333
                        localctx.right = self.expression(11)
                        pass

                    elif la_ == 4:
                        localctx = SqlSmallParser.AddContext(self, SqlSmallParser.ExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 334
                        if not self.precpred(self._ctx, 9):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, &#34;self.precpred(self._ctx, 9)&#34;)
                        self.state = 335
                        localctx.op = self.match(SqlSmallParser.PLUS)
                        self.state = 336
                        localctx.right = self.expression(10)
                        pass

                    elif la_ == 5:
                        localctx = SqlSmallParser.SubtractContext(self, SqlSmallParser.ExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                        self.state = 337
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, &#34;self.precpred(self._ctx, 8)&#34;)
                        self.state = 338
                        localctx.op = self.match(SqlSmallParser.MINUS)
                        self.state = 339
                        localctx.right = self.expression(9)
                        pass

             
                self.state = 344
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,40,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class AllExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASTERISK(self):
            return self.getToken(SqlSmallParser.ASTERISK, 0)

        def identifier(self):
            return self.getTypedRuleContext(SqlSmallParser.IdentifierContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_allExpression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterAllExpression&#34; ):
                listener.enterAllExpression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitAllExpression&#34; ):
                listener.exitAllExpression(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitAllExpression&#34; ):
                return visitor.visitAllExpression(self)
            else:
                return visitor.visitChildren(self)




    def allExpression(self):

        localctx = SqlSmallParser.AllExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_allExpression)
        try:
            self.state = 350
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlSmallParser.ASTERISK]:
                self.enterOuterAlt(localctx, 1)
                self.state = 345
                self.match(SqlSmallParser.ASTERISK)
                pass
            elif token in [SqlSmallParser.IDENT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 346
                self.identifier()
                self.state = 347
                self.match(SqlSmallParser.T__4)
                self.state = 348
                self.match(SqlSmallParser.ASTERISK)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class LiteralContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlSmallParser.RULE_literal

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class NullLiteralContext(LiteralContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.LiteralContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NULL(self):
            return self.getToken(SqlSmallParser.NULL, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterNullLiteral&#34; ):
                listener.enterNullLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitNullLiteral&#34; ):
                listener.exitNullLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitNullLiteral&#34; ):
                return visitor.visitNullLiteral(self)
            else:
                return visitor.visitChildren(self)


    class FalseLiteralContext(LiteralContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.LiteralContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def FALSE(self):
            return self.getToken(SqlSmallParser.FALSE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterFalseLiteral&#34; ):
                listener.enterFalseLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitFalseLiteral&#34; ):
                listener.exitFalseLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitFalseLiteral&#34; ):
                return visitor.visitFalseLiteral(self)
            else:
                return visitor.visitChildren(self)


    class StringLiteralContext(LiteralContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.LiteralContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def STRING(self):
            return self.getToken(SqlSmallParser.STRING, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterStringLiteral&#34; ):
                listener.enterStringLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitStringLiteral&#34; ):
                listener.exitStringLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitStringLiteral&#34; ):
                return visitor.visitStringLiteral(self)
            else:
                return visitor.visitChildren(self)


    class TrueLiteralContext(LiteralContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.LiteralContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def TRUE(self):
            return self.getToken(SqlSmallParser.TRUE, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterTrueLiteral&#34; ):
                listener.enterTrueLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitTrueLiteral&#34; ):
                listener.exitTrueLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitTrueLiteral&#34; ):
                return visitor.visitTrueLiteral(self)
            else:
                return visitor.visitChildren(self)


    class NumberLiteralContext(LiteralContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.LiteralContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def number(self):
            return self.getTypedRuleContext(SqlSmallParser.NumberContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterNumberLiteral&#34; ):
                listener.enterNumberLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitNumberLiteral&#34; ):
                listener.exitNumberLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitNumberLiteral&#34; ):
                return visitor.visitNumberLiteral(self)
            else:
                return visitor.visitChildren(self)



    def literal(self):

        localctx = SqlSmallParser.LiteralContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_literal)
        try:
            self.state = 357
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlSmallParser.STRING]:
                localctx = SqlSmallParser.StringLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 352
                self.match(SqlSmallParser.STRING)
                pass
            elif token in [SqlSmallParser.MINUS, SqlSmallParser.INTEGER_VALUE, SqlSmallParser.DECIMAL_VALUE]:
                localctx = SqlSmallParser.NumberLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 353
                self.number()
                pass
            elif token in [SqlSmallParser.TRUE]:
                localctx = SqlSmallParser.TrueLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 354
                self.match(SqlSmallParser.TRUE)
                pass
            elif token in [SqlSmallParser.FALSE]:
                localctx = SqlSmallParser.FalseLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 355
                self.match(SqlSmallParser.FALSE)
                pass
            elif token in [SqlSmallParser.NULL]:
                localctx = SqlSmallParser.NullLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 356
                self.match(SqlSmallParser.NULL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlSmallParser.RULE_booleanExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class LogicalNotContext(BooleanExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.BooleanExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NOT(self):
            return self.getToken(SqlSmallParser.NOT, 0)
        def booleanExpression(self):
            return self.getTypedRuleContext(SqlSmallParser.BooleanExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterLogicalNot&#34; ):
                listener.enterLogicalNot(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitLogicalNot&#34; ):
                listener.exitLogicalNot(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitLogicalNot&#34; ):
                return visitor.visitLogicalNot(self)
            else:
                return visitor.visitChildren(self)


    class ComparisonContext(BooleanExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.BooleanExpressionContext
            super().__init__(parser)
            self.left = None # ExpressionContext
            self.op = None # ComparisonOperatorContext
            self.right = None # ExpressionContext
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,i)

        def comparisonOperator(self):
            return self.getTypedRuleContext(SqlSmallParser.ComparisonOperatorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterComparison&#34; ):
                listener.enterComparison(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitComparison&#34; ):
                listener.exitComparison(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitComparison&#34; ):
                return visitor.visitComparison(self)
            else:
                return visitor.visitChildren(self)


    class PredicatedContext(BooleanExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.BooleanExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,0)

        def predicate(self):
            return self.getTypedRuleContext(SqlSmallParser.PredicateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterPredicated&#34; ):
                listener.enterPredicated(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitPredicated&#34; ):
                listener.exitPredicated(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitPredicated&#34; ):
                return visitor.visitPredicated(self)
            else:
                return visitor.visitChildren(self)


    class ConjunctionContext(BooleanExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.BooleanExpressionContext
            super().__init__(parser)
            self.left = None # BooleanExpressionContext
            self.right = None # BooleanExpressionContext
            self.copyFrom(ctx)

        def AND(self):
            return self.getToken(SqlSmallParser.AND, 0)
        def booleanExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.BooleanExpressionContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.BooleanExpressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterConjunction&#34; ):
                listener.enterConjunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitConjunction&#34; ):
                listener.exitConjunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitConjunction&#34; ):
                return visitor.visitConjunction(self)
            else:
                return visitor.visitChildren(self)


    class DisjunctionContext(BooleanExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.BooleanExpressionContext
            super().__init__(parser)
            self.left = None # BooleanExpressionContext
            self.right = None # BooleanExpressionContext
            self.copyFrom(ctx)

        def OR(self):
            return self.getToken(SqlSmallParser.OR, 0)
        def booleanExpression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.BooleanExpressionContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.BooleanExpressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterDisjunction&#34; ):
                listener.enterDisjunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitDisjunction&#34; ):
                listener.exitDisjunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitDisjunction&#34; ):
                return visitor.visitDisjunction(self)
            else:
                return visitor.visitChildren(self)


    class NestedBooleanContext(BooleanExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.BooleanExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def booleanExpression(self):
            return self.getTypedRuleContext(SqlSmallParser.BooleanExpressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterNestedBoolean&#34; ):
                listener.enterNestedBoolean(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitNestedBoolean&#34; ):
                listener.exitNestedBoolean(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitNestedBoolean&#34; ):
                return visitor.visitNestedBoolean(self)
            else:
                return visitor.visitChildren(self)



    def booleanExpression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = SqlSmallParser.BooleanExpressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 52
        self.enterRecursionRule(localctx, 52, self.RULE_booleanExpression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 373
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,43,self._ctx)
            if la_ == 1:
                localctx = SqlSmallParser.LogicalNotContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 360
                self.match(SqlSmallParser.NOT)
                self.state = 361
                self.booleanExpression(6)
                pass

            elif la_ == 2:
                localctx = SqlSmallParser.ComparisonContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 362
                localctx.left = self.expression(0)
                self.state = 363
                localctx.op = self.comparisonOperator()
                self.state = 364
                localctx.right = self.expression(0)
                pass

            elif la_ == 3:
                localctx = SqlSmallParser.NestedBooleanContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 366
                self.match(SqlSmallParser.T__1)
                self.state = 367
                self.booleanExpression(0)
                self.state = 368
                self.match(SqlSmallParser.T__2)
                pass

            elif la_ == 4:
                localctx = SqlSmallParser.PredicatedContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 370
                self.expression(0)
                self.state = 371
                self.predicate()
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 383
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,45,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 381
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,44,self._ctx)
                    if la_ == 1:
                        localctx = SqlSmallParser.ConjunctionContext(self, SqlSmallParser.BooleanExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_booleanExpression)
                        self.state = 375
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, &#34;self.precpred(self._ctx, 4)&#34;)
                        self.state = 376
                        self.match(SqlSmallParser.AND)
                        self.state = 377
                        localctx.right = self.booleanExpression(5)
                        pass

                    elif la_ == 2:
                        localctx = SqlSmallParser.DisjunctionContext(self, SqlSmallParser.BooleanExpressionContext(self, _parentctx, _parentState))
                        localctx.left = _prevctx
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_booleanExpression)
                        self.state = 378
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, &#34;self.precpred(self._ctx, 3)&#34;)
                        self.state = 379
                        self.match(SqlSmallParser.OR)
                        self.state = 380
                        localctx.right = self.booleanExpression(4)
                        pass

             
                self.state = 385
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,45,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class PredicateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlSmallParser.RULE_predicate

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class InConditionContext(PredicateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.PredicateContext
            super().__init__(parser)
            self.kind = None # Token
            self.copyFrom(ctx)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,i)

        def IN(self):
            return self.getToken(SqlSmallParser.IN, 0)
        def NOT(self):
            return self.getToken(SqlSmallParser.NOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterInCondition&#34; ):
                listener.enterInCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitInCondition&#34; ):
                listener.exitInCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitInCondition&#34; ):
                return visitor.visitInCondition(self)
            else:
                return visitor.visitChildren(self)


    class IsConditionContext(PredicateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.PredicateContext
            super().__init__(parser)
            self.kind = None # Token
            self.copyFrom(ctx)

        def IS(self):
            return self.getToken(SqlSmallParser.IS, 0)
        def NULL(self):
            return self.getToken(SqlSmallParser.NULL, 0)
        def TRUE(self):
            return self.getToken(SqlSmallParser.TRUE, 0)
        def FALSE(self):
            return self.getToken(SqlSmallParser.FALSE, 0)
        def NOT(self):
            return self.getToken(SqlSmallParser.NOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterIsCondition&#34; ):
                listener.enterIsCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitIsCondition&#34; ):
                listener.exitIsCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitIsCondition&#34; ):
                return visitor.visitIsCondition(self)
            else:
                return visitor.visitChildren(self)


    class BetweenConditionContext(PredicateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.PredicateContext
            super().__init__(parser)
            self.kind = None # Token
            self.lower = None # ExpressionContext
            self.upper = None # ExpressionContext
            self.copyFrom(ctx)

        def AND(self):
            return self.getToken(SqlSmallParser.AND, 0)
        def BETWEEN(self):
            return self.getToken(SqlSmallParser.BETWEEN, 0)
        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,i)

        def NOT(self):
            return self.getToken(SqlSmallParser.NOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterBetweenCondition&#34; ):
                listener.enterBetweenCondition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitBetweenCondition&#34; ):
                listener.exitBetweenCondition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitBetweenCondition&#34; ):
                return visitor.visitBetweenCondition(self)
            else:
                return visitor.visitChildren(self)



    def predicate(self):

        localctx = SqlSmallParser.PredicateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_predicate)
        self._la = 0 # Token type
        try:
            self.state = 414
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,50,self._ctx)
            if la_ == 1:
                localctx = SqlSmallParser.BetweenConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 387
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlSmallParser.NOT:
                    self.state = 386
                    self.match(SqlSmallParser.NOT)


                self.state = 389
                localctx.kind = self.match(SqlSmallParser.BETWEEN)
                self.state = 390
                localctx.lower = self.expression(0)
                self.state = 391
                self.match(SqlSmallParser.AND)
                self.state = 392
                localctx.upper = self.expression(0)
                pass

            elif la_ == 2:
                localctx = SqlSmallParser.InConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 395
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlSmallParser.NOT:
                    self.state = 394
                    self.match(SqlSmallParser.NOT)


                self.state = 397
                localctx.kind = self.match(SqlSmallParser.IN)
                self.state = 398
                self.match(SqlSmallParser.T__1)
                self.state = 399
                self.expression(0)
                self.state = 404
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==SqlSmallParser.T__3:
                    self.state = 400
                    self.match(SqlSmallParser.T__3)
                    self.state = 401
                    self.expression(0)
                    self.state = 406
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 407
                self.match(SqlSmallParser.T__2)
                pass

            elif la_ == 3:
                localctx = SqlSmallParser.IsConditionContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 409
                self.match(SqlSmallParser.IS)
                self.state = 411
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlSmallParser.NOT:
                    self.state = 410
                    self.match(SqlSmallParser.NOT)


                self.state = 413
                localctx.kind = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 33)) &amp; ~0x3f) == 0 and ((1 &lt;&lt; (_la - 33)) &amp; ((1 &lt;&lt; (SqlSmallParser.FALSE - 33)) | (1 &lt;&lt; (SqlSmallParser.NULL - 33)) | (1 &lt;&lt; (SqlSmallParser.TRUE - 33)))) != 0)):
                    localctx.kind = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ComparisonOperatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQ(self):
            return self.getToken(SqlSmallParser.EQ, 0)

        def NEQ(self):
            return self.getToken(SqlSmallParser.NEQ, 0)

        def NEQJ(self):
            return self.getToken(SqlSmallParser.NEQJ, 0)

        def LT(self):
            return self.getToken(SqlSmallParser.LT, 0)

        def LTE(self):
            return self.getToken(SqlSmallParser.LTE, 0)

        def GT(self):
            return self.getToken(SqlSmallParser.GT, 0)

        def GTE(self):
            return self.getToken(SqlSmallParser.GTE, 0)

        def NSEQ(self):
            return self.getToken(SqlSmallParser.NSEQ, 0)

        def getRuleIndex(self):
            return SqlSmallParser.RULE_comparisonOperator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterComparisonOperator&#34; ):
                listener.enterComparisonOperator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitComparisonOperator&#34; ):
                listener.exitComparisonOperator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitComparisonOperator&#34; ):
                return visitor.visitComparisonOperator(self)
            else:
                return visitor.visitChildren(self)




    def comparisonOperator(self):

        localctx = SqlSmallParser.ComparisonOperatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_comparisonOperator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 416
            _la = self._input.LA(1)
            if not(((((_la - 94)) &amp; ~0x3f) == 0 and ((1 &lt;&lt; (_la - 94)) &amp; ((1 &lt;&lt; (SqlSmallParser.EQ - 94)) | (1 &lt;&lt; (SqlSmallParser.NSEQ - 94)) | (1 &lt;&lt; (SqlSmallParser.NEQ - 94)) | (1 &lt;&lt; (SqlSmallParser.NEQJ - 94)) | (1 &lt;&lt; (SqlSmallParser.LT - 94)) | (1 &lt;&lt; (SqlSmallParser.LTE - 94)) | (1 &lt;&lt; (SqlSmallParser.GT - 94)) | (1 &lt;&lt; (SqlSmallParser.GTE - 94)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BooleanValueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUE(self):
            return self.getToken(SqlSmallParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(SqlSmallParser.FALSE, 0)

        def getRuleIndex(self):
            return SqlSmallParser.RULE_booleanValue

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterBooleanValue&#34; ):
                listener.enterBooleanValue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitBooleanValue&#34; ):
                listener.exitBooleanValue(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitBooleanValue&#34; ):
                return visitor.visitBooleanValue(self)
            else:
                return visitor.visitChildren(self)




    def booleanValue(self):

        localctx = SqlSmallParser.BooleanValueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_booleanValue)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 418
            _la = self._input.LA(1)
            if not(_la==SqlSmallParser.FALSE or _la==SqlSmallParser.TRUE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class FunctionExpressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlSmallParser.RULE_functionExpression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class IifFuncContext(FunctionExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.FunctionExpressionContext
            super().__init__(parser)
            self.test = None # BooleanExpressionContext
            self.yes = None # ExpressionContext
            self.no = None # ExpressionContext
            self.copyFrom(ctx)

        def IIF(self):
            return self.getToken(SqlSmallParser.IIF, 0)
        def booleanExpression(self):
            return self.getTypedRuleContext(SqlSmallParser.BooleanExpressionContext,0)

        def expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.ExpressionContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterIifFunc&#34; ):
                listener.enterIifFunc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitIifFunc&#34; ):
                listener.exitIifFunc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitIifFunc&#34; ):
                return visitor.visitIifFunc(self)
            else:
                return visitor.visitChildren(self)


    class PowerFuncContext(FunctionExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.FunctionExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def powerFunction(self):
            return self.getTypedRuleContext(SqlSmallParser.PowerFunctionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterPowerFunc&#34; ):
                listener.enterPowerFunc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitPowerFunc&#34; ):
                listener.exitPowerFunc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitPowerFunc&#34; ):
                return visitor.visitPowerFunc(self)
            else:
                return visitor.visitChildren(self)


    class ChooseFuncContext(FunctionExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.FunctionExpressionContext
            super().__init__(parser)
            self.index = None # ExpressionContext
            self.copyFrom(ctx)

        def CHOOSE(self):
            return self.getToken(SqlSmallParser.CHOOSE, 0)
        def expression(self):
            return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,0)

        def literal(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.LiteralContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.LiteralContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterChooseFunc&#34; ):
                listener.enterChooseFunc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitChooseFunc&#34; ):
                listener.exitChooseFunc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitChooseFunc&#34; ):
                return visitor.visitChooseFunc(self)
            else:
                return visitor.visitChildren(self)


    class MathFuncContext(FunctionExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.FunctionExpressionContext
            super().__init__(parser)
            self.function = None # MathFunctionNameContext
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,0)

        def mathFunctionName(self):
            return self.getTypedRuleContext(SqlSmallParser.MathFunctionNameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterMathFunc&#34; ):
                listener.enterMathFunc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitMathFunc&#34; ):
                listener.exitMathFunc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitMathFunc&#34; ):
                return visitor.visitMathFunc(self)
            else:
                return visitor.visitChildren(self)


    class AggFuncContext(FunctionExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.FunctionExpressionContext
            super().__init__(parser)
            self.function = None # AggregateFunctionNameContext
            self.copyFrom(ctx)

        def expression(self):
            return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,0)

        def aggregateFunctionName(self):
            return self.getTypedRuleContext(SqlSmallParser.AggregateFunctionNameContext,0)

        def setQuantifier(self):
            return self.getTypedRuleContext(SqlSmallParser.SetQuantifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterAggFunc&#34; ):
                listener.enterAggFunc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitAggFunc&#34; ):
                listener.exitAggFunc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitAggFunc&#34; ):
                return visitor.visitAggFunc(self)
            else:
                return visitor.visitChildren(self)


    class BareFuncContext(FunctionExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.FunctionExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def bareFunction(self):
            return self.getTypedRuleContext(SqlSmallParser.BareFunctionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterBareFunc&#34; ):
                listener.enterBareFunc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitBareFunc&#34; ):
                listener.exitBareFunc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitBareFunc&#34; ):
                return visitor.visitBareFunc(self)
            else:
                return visitor.visitChildren(self)


    class RoundFuncContext(FunctionExpressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.FunctionExpressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def roundFunction(self):
            return self.getTypedRuleContext(SqlSmallParser.RoundFunctionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterRoundFunc&#34; ):
                listener.enterRoundFunc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitRoundFunc&#34; ):
                listener.exitRoundFunc(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitRoundFunc&#34; ):
                return visitor.visitRoundFunc(self)
            else:
                return visitor.visitChildren(self)



    def functionExpression(self):

        localctx = SqlSmallParser.FunctionExpressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_functionExpression)
        self._la = 0 # Token type
        try:
            self.state = 456
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlSmallParser.NEWID, SqlSmallParser.PI, SqlSmallParser.RAND, SqlSmallParser.RANDOM]:
                localctx = SqlSmallParser.BareFuncContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 420
                self.bareFunction()
                pass
            elif token in [SqlSmallParser.ROUND]:
                localctx = SqlSmallParser.RoundFuncContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 421
                self.roundFunction()
                pass
            elif token in [SqlSmallParser.POWER]:
                localctx = SqlSmallParser.PowerFuncContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 422
                self.powerFunction()
                pass
            elif token in [SqlSmallParser.AVG, SqlSmallParser.COUNT, SqlSmallParser.MAX, SqlSmallParser.MIN, SqlSmallParser.PERCENTILE_CONT, SqlSmallParser.PERCENTILE_DISC, SqlSmallParser.STD, SqlSmallParser.STDDEV, SqlSmallParser.SUM, SqlSmallParser.VAR, SqlSmallParser.VARIANCE]:
                localctx = SqlSmallParser.AggFuncContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 423
                localctx.function = self.aggregateFunctionName()
                self.state = 424
                self.match(SqlSmallParser.T__1)
                self.state = 426
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlSmallParser.ALL or _la==SqlSmallParser.DISTINCT or _la==SqlSmallParser.TOP:
                    self.state = 425
                    self.setQuantifier()


                self.state = 428
                self.expression(0)
                self.state = 429
                self.match(SqlSmallParser.T__2)
                pass
            elif token in [SqlSmallParser.ABS, SqlSmallParser.ACOS, SqlSmallParser.ASIN, SqlSmallParser.ATAN, SqlSmallParser.CEILING, SqlSmallParser.COS, SqlSmallParser.DEGREES, SqlSmallParser.EXP, SqlSmallParser.FLOOR, SqlSmallParser.LOG, SqlSmallParser.LOG10, SqlSmallParser.SIGN, SqlSmallParser.SIN, SqlSmallParser.SQRT, SqlSmallParser.SQUARE, SqlSmallParser.TAN]:
                localctx = SqlSmallParser.MathFuncContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 431
                localctx.function = self.mathFunctionName()
                self.state = 432
                self.match(SqlSmallParser.T__1)
                self.state = 433
                self.expression(0)
                self.state = 434
                self.match(SqlSmallParser.T__2)
                pass
            elif token in [SqlSmallParser.IIF]:
                localctx = SqlSmallParser.IifFuncContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 436
                self.match(SqlSmallParser.IIF)
                self.state = 437
                self.match(SqlSmallParser.T__1)
                self.state = 438
                localctx.test = self.booleanExpression(0)
                self.state = 439
                self.match(SqlSmallParser.T__3)
                self.state = 440
                localctx.yes = self.expression(0)
                self.state = 441
                self.match(SqlSmallParser.T__3)
                self.state = 442
                localctx.no = self.expression(0)
                self.state = 443
                self.match(SqlSmallParser.T__2)
                pass
            elif token in [SqlSmallParser.CHOOSE]:
                localctx = SqlSmallParser.ChooseFuncContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 445
                self.match(SqlSmallParser.CHOOSE)
                self.state = 446
                self.match(SqlSmallParser.T__1)
                self.state = 447
                localctx.index = self.expression(0)
                self.state = 450 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 448
                    self.match(SqlSmallParser.T__3)
                    self.state = 449
                    self.literal()
                    self.state = 452 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==SqlSmallParser.T__3):
                        break

                self.state = 454
                self.match(SqlSmallParser.T__2)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BareFunctionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.function = None # BareFunctionNameContext

        def bareFunctionName(self):
            return self.getTypedRuleContext(SqlSmallParser.BareFunctionNameContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_bareFunction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterBareFunction&#34; ):
                listener.enterBareFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitBareFunction&#34; ):
                listener.exitBareFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitBareFunction&#34; ):
                return visitor.visitBareFunction(self)
            else:
                return visitor.visitChildren(self)




    def bareFunction(self):

        localctx = SqlSmallParser.BareFunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_bareFunction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 458
            localctx.function = self.bareFunctionName()
            self.state = 459
            self.match(SqlSmallParser.T__1)
            self.state = 460
            self.match(SqlSmallParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RankingFunctionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.function = None # RankingFunctionNameContext

        def overClause(self):
            return self.getTypedRuleContext(SqlSmallParser.OverClauseContext,0)


        def rankingFunctionName(self):
            return self.getTypedRuleContext(SqlSmallParser.RankingFunctionNameContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_rankingFunction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterRankingFunction&#34; ):
                listener.enterRankingFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitRankingFunction&#34; ):
                listener.exitRankingFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitRankingFunction&#34; ):
                return visitor.visitRankingFunction(self)
            else:
                return visitor.visitChildren(self)




    def rankingFunction(self):

        localctx = SqlSmallParser.RankingFunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_rankingFunction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 462
            localctx.function = self.rankingFunctionName()
            self.state = 463
            self.match(SqlSmallParser.T__1)
            self.state = 464
            self.match(SqlSmallParser.T__2)
            self.state = 465
            self.overClause()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RoundFunctionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.digits = None # NumberContext

        def ROUND(self):
            return self.getToken(SqlSmallParser.ROUND, 0)

        def expression(self):
            return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,0)


        def number(self):
            return self.getTypedRuleContext(SqlSmallParser.NumberContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_roundFunction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterRoundFunction&#34; ):
                listener.enterRoundFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitRoundFunction&#34; ):
                listener.exitRoundFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitRoundFunction&#34; ):
                return visitor.visitRoundFunction(self)
            else:
                return visitor.visitChildren(self)




    def roundFunction(self):

        localctx = SqlSmallParser.RoundFunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_roundFunction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 467
            self.match(SqlSmallParser.ROUND)
            self.state = 468
            self.match(SqlSmallParser.T__1)
            self.state = 469
            self.expression(0)
            self.state = 470
            self.match(SqlSmallParser.T__3)
            self.state = 471
            localctx.digits = self.number()
            self.state = 472
            self.match(SqlSmallParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PowerFunctionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def POWER(self):
            return self.getToken(SqlSmallParser.POWER, 0)

        def expression(self):
            return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,0)


        def number(self):
            return self.getTypedRuleContext(SqlSmallParser.NumberContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_powerFunction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterPowerFunction&#34; ):
                listener.enterPowerFunction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitPowerFunction&#34; ):
                listener.exitPowerFunction(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitPowerFunction&#34; ):
                return visitor.visitPowerFunction(self)
            else:
                return visitor.visitChildren(self)




    def powerFunction(self):

        localctx = SqlSmallParser.PowerFunctionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_powerFunction)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 474
            self.match(SqlSmallParser.POWER)
            self.state = 475
            self.match(SqlSmallParser.T__1)
            self.state = 476
            self.expression(0)
            self.state = 477
            self.match(SqlSmallParser.T__3)
            self.state = 478
            self.number()
            self.state = 479
            self.match(SqlSmallParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class RankingFunctionNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ROW_NUMBER(self):
            return self.getToken(SqlSmallParser.ROW_NUMBER, 0)

        def RANK(self):
            return self.getToken(SqlSmallParser.RANK, 0)

        def DENSE_RANK(self):
            return self.getToken(SqlSmallParser.DENSE_RANK, 0)

        def getRuleIndex(self):
            return SqlSmallParser.RULE_rankingFunctionName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterRankingFunctionName&#34; ):
                listener.enterRankingFunctionName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitRankingFunctionName&#34; ):
                listener.exitRankingFunctionName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitRankingFunctionName&#34; ):
                return visitor.visitRankingFunctionName(self)
            else:
                return visitor.visitChildren(self)




    def rankingFunctionName(self):

        localctx = SqlSmallParser.RankingFunctionNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_rankingFunctionName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 481
            _la = self._input.LA(1)
            if not(((((_la - 26)) &amp; ~0x3f) == 0 and ((1 &lt;&lt; (_la - 26)) &amp; ((1 &lt;&lt; (SqlSmallParser.DENSE_RANK - 26)) | (1 &lt;&lt; (SqlSmallParser.RANK - 26)) | (1 &lt;&lt; (SqlSmallParser.ROW_NUMBER - 26)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AggregateFunctionNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COUNT(self):
            return self.getToken(SqlSmallParser.COUNT, 0)

        def SUM(self):
            return self.getToken(SqlSmallParser.SUM, 0)

        def AVG(self):
            return self.getToken(SqlSmallParser.AVG, 0)

        def VAR(self):
            return self.getToken(SqlSmallParser.VAR, 0)

        def VARIANCE(self):
            return self.getToken(SqlSmallParser.VARIANCE, 0)

        def STD(self):
            return self.getToken(SqlSmallParser.STD, 0)

        def STDDEV(self):
            return self.getToken(SqlSmallParser.STDDEV, 0)

        def MIN(self):
            return self.getToken(SqlSmallParser.MIN, 0)

        def MAX(self):
            return self.getToken(SqlSmallParser.MAX, 0)

        def PERCENTILE_DISC(self):
            return self.getToken(SqlSmallParser.PERCENTILE_DISC, 0)

        def PERCENTILE_CONT(self):
            return self.getToken(SqlSmallParser.PERCENTILE_CONT, 0)

        def getRuleIndex(self):
            return SqlSmallParser.RULE_aggregateFunctionName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterAggregateFunctionName&#34; ):
                listener.enterAggregateFunctionName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitAggregateFunctionName&#34; ):
                listener.exitAggregateFunctionName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitAggregateFunctionName&#34; ):
                return visitor.visitAggregateFunctionName(self)
            else:
                return visitor.visitChildren(self)




    def aggregateFunctionName(self):

        localctx = SqlSmallParser.AggregateFunctionNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_aggregateFunctionName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 483
            _la = self._input.LA(1)
            if not((((_la) &amp; ~0x3f) == 0 and ((1 &lt;&lt; _la) &amp; ((1 &lt;&lt; SqlSmallParser.AVG) | (1 &lt;&lt; SqlSmallParser.COUNT) | (1 &lt;&lt; SqlSmallParser.MAX) | (1 &lt;&lt; SqlSmallParser.MIN) | (1 &lt;&lt; SqlSmallParser.PERCENTILE_CONT) | (1 &lt;&lt; SqlSmallParser.PERCENTILE_DISC))) != 0) or ((((_la - 81)) &amp; ~0x3f) == 0 and ((1 &lt;&lt; (_la - 81)) &amp; ((1 &lt;&lt; (SqlSmallParser.STD - 81)) | (1 &lt;&lt; (SqlSmallParser.STDDEV - 81)) | (1 &lt;&lt; (SqlSmallParser.SUM - 81)) | (1 &lt;&lt; (SqlSmallParser.VAR - 81)) | (1 &lt;&lt; (SqlSmallParser.VARIANCE - 81)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MathFunctionNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ABS(self):
            return self.getToken(SqlSmallParser.ABS, 0)

        def CEILING(self):
            return self.getToken(SqlSmallParser.CEILING, 0)

        def FLOOR(self):
            return self.getToken(SqlSmallParser.FLOOR, 0)

        def SIGN(self):
            return self.getToken(SqlSmallParser.SIGN, 0)

        def SQRT(self):
            return self.getToken(SqlSmallParser.SQRT, 0)

        def SQUARE(self):
            return self.getToken(SqlSmallParser.SQUARE, 0)

        def EXP(self):
            return self.getToken(SqlSmallParser.EXP, 0)

        def LOG(self):
            return self.getToken(SqlSmallParser.LOG, 0)

        def LOG10(self):
            return self.getToken(SqlSmallParser.LOG10, 0)

        def SIN(self):
            return self.getToken(SqlSmallParser.SIN, 0)

        def COS(self):
            return self.getToken(SqlSmallParser.COS, 0)

        def TAN(self):
            return self.getToken(SqlSmallParser.TAN, 0)

        def ASIN(self):
            return self.getToken(SqlSmallParser.ASIN, 0)

        def ACOS(self):
            return self.getToken(SqlSmallParser.ACOS, 0)

        def ATAN(self):
            return self.getToken(SqlSmallParser.ATAN, 0)

        def DEGREES(self):
            return self.getToken(SqlSmallParser.DEGREES, 0)

        def getRuleIndex(self):
            return SqlSmallParser.RULE_mathFunctionName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterMathFunctionName&#34; ):
                listener.enterMathFunctionName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitMathFunctionName&#34; ):
                listener.exitMathFunctionName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitMathFunctionName&#34; ):
                return visitor.visitMathFunctionName(self)
            else:
                return visitor.visitChildren(self)




    def mathFunctionName(self):

        localctx = SqlSmallParser.MathFunctionNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_mathFunctionName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 485
            _la = self._input.LA(1)
            if not((((_la) &amp; ~0x3f) == 0 and ((1 &lt;&lt; _la) &amp; ((1 &lt;&lt; SqlSmallParser.ABS) | (1 &lt;&lt; SqlSmallParser.ACOS) | (1 &lt;&lt; SqlSmallParser.ASIN) | (1 &lt;&lt; SqlSmallParser.ATAN) | (1 &lt;&lt; SqlSmallParser.CEILING) | (1 &lt;&lt; SqlSmallParser.COS) | (1 &lt;&lt; SqlSmallParser.DEGREES) | (1 &lt;&lt; SqlSmallParser.EXP) | (1 &lt;&lt; SqlSmallParser.FLOOR) | (1 &lt;&lt; SqlSmallParser.LOG) | (1 &lt;&lt; SqlSmallParser.LOG10))) != 0) or ((((_la - 75)) &amp; ~0x3f) == 0 and ((1 &lt;&lt; (_la - 75)) &amp; ((1 &lt;&lt; (SqlSmallParser.SIGN - 75)) | (1 &lt;&lt; (SqlSmallParser.SIN - 75)) | (1 &lt;&lt; (SqlSmallParser.SQRT - 75)) | (1 &lt;&lt; (SqlSmallParser.SQUARE - 75)) | (1 &lt;&lt; (SqlSmallParser.TAN - 75)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class BareFunctionNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PI(self):
            return self.getToken(SqlSmallParser.PI, 0)

        def RANDOM(self):
            return self.getToken(SqlSmallParser.RANDOM, 0)

        def RAND(self):
            return self.getToken(SqlSmallParser.RAND, 0)

        def NEWID(self):
            return self.getToken(SqlSmallParser.NEWID, 0)

        def getRuleIndex(self):
            return SqlSmallParser.RULE_bareFunctionName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterBareFunctionName&#34; ):
                listener.enterBareFunctionName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitBareFunctionName&#34; ):
                listener.exitBareFunctionName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitBareFunctionName&#34; ):
                return visitor.visitBareFunctionName(self)
            else:
                return visitor.visitChildren(self)




    def bareFunctionName(self):

        localctx = SqlSmallParser.BareFunctionNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_bareFunctionName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 487
            _la = self._input.LA(1)
            if not(((((_la - 52)) &amp; ~0x3f) == 0 and ((1 &lt;&lt; (_la - 52)) &amp; ((1 &lt;&lt; (SqlSmallParser.NEWID - 52)) | (1 &lt;&lt; (SqlSmallParser.PI - 52)) | (1 &lt;&lt; (SqlSmallParser.RAND - 52)) | (1 &lt;&lt; (SqlSmallParser.RANDOM - 52)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OverClauseContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OVER(self):
            return self.getToken(SqlSmallParser.OVER, 0)

        def PARTITION(self):
            return self.getToken(SqlSmallParser.PARTITION, 0)

        def BY(self):
            return self.getToken(SqlSmallParser.BY, 0)

        def expression(self):
            return self.getTypedRuleContext(SqlSmallParser.ExpressionContext,0)


        def orderClause(self):
            return self.getTypedRuleContext(SqlSmallParser.OrderClauseContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_overClause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterOverClause&#34; ):
                listener.enterOverClause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitOverClause&#34; ):
                listener.exitOverClause(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitOverClause&#34; ):
                return visitor.visitOverClause(self)
            else:
                return visitor.visitChildren(self)




    def overClause(self):

        localctx = SqlSmallParser.OverClauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_overClause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 489
            self.match(SqlSmallParser.OVER)
            self.state = 490
            self.match(SqlSmallParser.T__1)
            self.state = 494
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.PARTITION:
                self.state = 491
                self.match(SqlSmallParser.PARTITION)
                self.state = 492
                self.match(SqlSmallParser.BY)
                self.state = 493
                self.expression(0)


            self.state = 497
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.ORDER:
                self.state = 496
                self.orderClause()


            self.state = 499
            self.match(SqlSmallParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AliasedSubqueryContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.alias = None # IdentifierContext

        def subquery(self):
            return self.getTypedRuleContext(SqlSmallParser.SubqueryContext,0)


        def AS(self):
            return self.getToken(SqlSmallParser.AS, 0)

        def identifier(self):
            return self.getTypedRuleContext(SqlSmallParser.IdentifierContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_aliasedSubquery

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterAliasedSubquery&#34; ):
                listener.enterAliasedSubquery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitAliasedSubquery&#34; ):
                listener.exitAliasedSubquery(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitAliasedSubquery&#34; ):
                return visitor.visitAliasedSubquery(self)
            else:
                return visitor.visitChildren(self)




    def aliasedSubquery(self):

        localctx = SqlSmallParser.AliasedSubqueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_aliasedSubquery)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 501
            self.subquery()
            self.state = 504
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.AS:
                self.state = 502
                self.match(SqlSmallParser.AS)
                self.state = 503
                localctx.alias = self.identifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AliasedTableOrSubquerySeqContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def aliasedTableName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.AliasedTableNameContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.AliasedTableNameContext,i)


        def aliasedSubquery(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.AliasedSubqueryContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.AliasedSubqueryContext,i)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_aliasedTableOrSubquerySeq

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterAliasedTableOrSubquerySeq&#34; ):
                listener.enterAliasedTableOrSubquerySeq(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitAliasedTableOrSubquerySeq&#34; ):
                listener.exitAliasedTableOrSubquerySeq(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitAliasedTableOrSubquerySeq&#34; ):
                return visitor.visitAliasedTableOrSubquerySeq(self)
            else:
                return visitor.visitChildren(self)




    def aliasedTableOrSubquerySeq(self):

        localctx = SqlSmallParser.AliasedTableOrSubquerySeqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_aliasedTableOrSubquerySeq)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 508
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlSmallParser.QN2, SqlSmallParser.QN3, SqlSmallParser.IDENT]:
                self.state = 506
                self.aliasedTableName()
                pass
            elif token in [SqlSmallParser.T__1]:
                self.state = 507
                self.aliasedSubquery()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 517
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SqlSmallParser.T__3:
                self.state = 510
                self.match(SqlSmallParser.T__3)
                self.state = 513
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [SqlSmallParser.QN2, SqlSmallParser.QN3, SqlSmallParser.IDENT]:
                    self.state = 511
                    self.aliasedTableName()
                    pass
                elif token in [SqlSmallParser.T__1]:
                    self.state = 512
                    self.aliasedSubquery()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 519
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AliasedTableSeqContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def aliasedTableName(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(SqlSmallParser.AliasedTableNameContext)
            else:
                return self.getTypedRuleContext(SqlSmallParser.AliasedTableNameContext,i)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_aliasedTableSeq

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterAliasedTableSeq&#34; ):
                listener.enterAliasedTableSeq(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitAliasedTableSeq&#34; ):
                listener.exitAliasedTableSeq(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitAliasedTableSeq&#34; ):
                return visitor.visitAliasedTableSeq(self)
            else:
                return visitor.visitChildren(self)




    def aliasedTableSeq(self):

        localctx = SqlSmallParser.AliasedTableSeqContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_aliasedTableSeq)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 520
            self.aliasedTableName()
            self.state = 525
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SqlSmallParser.T__3:
                self.state = 521
                self.match(SqlSmallParser.T__3)
                self.state = 522
                self.aliasedTableName()
                self.state = 527
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AliasedTableNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.alias = None # IdentifierContext

        def qualifiedTableName(self):
            return self.getTypedRuleContext(SqlSmallParser.QualifiedTableNameContext,0)


        def AS(self):
            return self.getToken(SqlSmallParser.AS, 0)

        def identifier(self):
            return self.getTypedRuleContext(SqlSmallParser.IdentifierContext,0)


        def getRuleIndex(self):
            return SqlSmallParser.RULE_aliasedTableName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterAliasedTableName&#34; ):
                listener.enterAliasedTableName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitAliasedTableName&#34; ):
                listener.exitAliasedTableName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitAliasedTableName&#34; ):
                return visitor.visitAliasedTableName(self)
            else:
                return visitor.visitChildren(self)




    def aliasedTableName(self):

        localctx = SqlSmallParser.AliasedTableNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_aliasedTableName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 528
            self.qualifiedTableName()
            self.state = 531
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.AS:
                self.state = 529
                self.match(SqlSmallParser.AS)
                self.state = 530
                localctx.alias = self.identifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QualifiedTableNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def QN3(self):
            return self.getToken(SqlSmallParser.QN3, 0)

        def QN2(self):
            return self.getToken(SqlSmallParser.QN2, 0)

        def IDENT(self):
            return self.getToken(SqlSmallParser.IDENT, 0)

        def getRuleIndex(self):
            return SqlSmallParser.RULE_qualifiedTableName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterQualifiedTableName&#34; ):
                listener.enterQualifiedTableName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitQualifiedTableName&#34; ):
                listener.exitQualifiedTableName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitQualifiedTableName&#34; ):
                return visitor.visitQualifiedTableName(self)
            else:
                return visitor.visitChildren(self)




    def qualifiedTableName(self):

        localctx = SqlSmallParser.QualifiedTableNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_qualifiedTableName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 533
            _la = self._input.LA(1)
            if not(((((_la - 115)) &amp; ~0x3f) == 0 and ((1 &lt;&lt; (_la - 115)) &amp; ((1 &lt;&lt; (SqlSmallParser.QN2 - 115)) | (1 &lt;&lt; (SqlSmallParser.QN3 - 115)) | (1 &lt;&lt; (SqlSmallParser.IDENT - 115)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class QualifiedColumnNameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def QN2(self):
            return self.getToken(SqlSmallParser.QN2, 0)

        def IDENT(self):
            return self.getToken(SqlSmallParser.IDENT, 0)

        def getRuleIndex(self):
            return SqlSmallParser.RULE_qualifiedColumnName

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterQualifiedColumnName&#34; ):
                listener.enterQualifiedColumnName(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitQualifiedColumnName&#34; ):
                listener.exitQualifiedColumnName(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitQualifiedColumnName&#34; ):
                return visitor.visitQualifiedColumnName(self)
            else:
                return visitor.visitChildren(self)




    def qualifiedColumnName(self):

        localctx = SqlSmallParser.QualifiedColumnNameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_qualifiedColumnName)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 535
            _la = self._input.LA(1)
            if not(_la==SqlSmallParser.QN2 or _la==SqlSmallParser.IDENT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IDENT(self):
            return self.getToken(SqlSmallParser.IDENT, 0)

        def getRuleIndex(self):
            return SqlSmallParser.RULE_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterIdentifier&#34; ):
                listener.enterIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitIdentifier&#34; ):
                listener.exitIdentifier(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitIdentifier&#34; ):
                return visitor.visitIdentifier(self)
            else:
                return visitor.visitChildren(self)




    def identifier(self):

        localctx = SqlSmallParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_identifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 537
            self.match(SqlSmallParser.IDENT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NumberContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return SqlSmallParser.RULE_number

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class DecimalLiteralContext(NumberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.NumberContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def DECIMAL_VALUE(self):
            return self.getToken(SqlSmallParser.DECIMAL_VALUE, 0)
        def MINUS(self):
            return self.getToken(SqlSmallParser.MINUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterDecimalLiteral&#34; ):
                listener.enterDecimalLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitDecimalLiteral&#34; ):
                listener.exitDecimalLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitDecimalLiteral&#34; ):
                return visitor.visitDecimalLiteral(self)
            else:
                return visitor.visitChildren(self)


    class IntegerLiteralContext(NumberContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a SqlSmallParser.NumberContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def INTEGER_VALUE(self):
            return self.getToken(SqlSmallParser.INTEGER_VALUE, 0)
        def MINUS(self):
            return self.getToken(SqlSmallParser.MINUS, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;enterIntegerLiteral&#34; ):
                listener.enterIntegerLiteral(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, &#34;exitIntegerLiteral&#34; ):
                listener.exitIntegerLiteral(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, &#34;visitIntegerLiteral&#34; ):
                return visitor.visitIntegerLiteral(self)
            else:
                return visitor.visitChildren(self)



    def number(self):

        localctx = SqlSmallParser.NumberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_number)
        self._la = 0 # Token type
        try:
            self.state = 547
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,64,self._ctx)
            if la_ == 1:
                localctx = SqlSmallParser.DecimalLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 540
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlSmallParser.MINUS:
                    self.state = 539
                    self.match(SqlSmallParser.MINUS)


                self.state = 542
                self.match(SqlSmallParser.DECIMAL_VALUE)
                pass

            elif la_ == 2:
                localctx = SqlSmallParser.IntegerLiteralContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 544
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==SqlSmallParser.MINUS:
                    self.state = 543
                    self.match(SqlSmallParser.MINUS)


                self.state = 546
                self.match(SqlSmallParser.INTEGER_VALUE)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[23] = self.expression_sempred
        self._predicates[26] = self.booleanExpression_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception(&#34;No predicate with index:&#34; + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def expression_sempred(self, localctx:ExpressionContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 12)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 11)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 10)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 9)
         

            if predIndex == 4:
                return self.precpred(self._ctx, 8)
         

    def booleanExpression_sempred(self, localctx:BooleanExpressionContext, predIndex:int):
            if predIndex == 5:
                return self.precpred(self._ctx, 4)
         

            if predIndex == 6:
                return self.precpred(self._ctx, 3)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>antlr4.Parser.Parser</li>
<li>antlr4.Recognizer.Recognizer</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ABS"><code class="name">var <span class="ident">ABS</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ACOS"><code class="name">var <span class="ident">ACOS</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ALL"><code class="name">var <span class="ident">ALL</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.AMPERSAND"><code class="name">var <span class="ident">AMPERSAND</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.AND"><code class="name">var <span class="ident">AND</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ANTI"><code class="name">var <span class="ident">ANTI</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.AS"><code class="name">var <span class="ident">AS</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ASC"><code class="name">var <span class="ident">ASC</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ASIN"><code class="name">var <span class="ident">ASIN</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ASTERISK"><code class="name">var <span class="ident">ASTERISK</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ATAN"><code class="name">var <span class="ident">ATAN</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.AVG"><code class="name">var <span class="ident">AVG</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.AddContext"><code class="name">var <span class="ident">AddContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.AggFuncContext"><code class="name">var <span class="ident">AggFuncContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.AggregateFunctionNameContext"><code class="name">var <span class="ident">AggregateFunctionNameContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.AggregationClauseContext"><code class="name">var <span class="ident">AggregationClauseContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.AliasedQueryContext"><code class="name">var <span class="ident">AliasedQueryContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.AliasedRelationContext"><code class="name">var <span class="ident">AliasedRelationContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.AliasedSubqueryContext"><code class="name">var <span class="ident">AliasedSubqueryContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.AliasedTableNameContext"><code class="name">var <span class="ident">AliasedTableNameContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.AliasedTableOrSubquerySeqContext"><code class="name">var <span class="ident">AliasedTableOrSubquerySeqContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.AliasedTableSeqContext"><code class="name">var <span class="ident">AliasedTableSeqContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.AllExprContext"><code class="name">var <span class="ident">AllExprContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.AllExpressionContext"><code class="name">var <span class="ident">AllExpressionContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.BETWEEN"><code class="name">var <span class="ident">BETWEEN</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.BRACKETED_COMMENT"><code class="name">var <span class="ident">BRACKETED_COMMENT</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.BRACKETED_EMPTY_COMMENT"><code class="name">var <span class="ident">BRACKETED_EMPTY_COMMENT</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.BY"><code class="name">var <span class="ident">BY</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.BareFuncContext"><code class="name">var <span class="ident">BareFuncContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.BareFunctionContext"><code class="name">var <span class="ident">BareFunctionContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.BareFunctionNameContext"><code class="name">var <span class="ident">BareFunctionNameContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.BatchContext"><code class="name">var <span class="ident">BatchContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.BetweenConditionContext"><code class="name">var <span class="ident">BetweenConditionContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.BooleanExpressionContext"><code class="name">var <span class="ident">BooleanExpressionContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.BooleanJoinContext"><code class="name">var <span class="ident">BooleanJoinContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.BooleanValueContext"><code class="name">var <span class="ident">BooleanValueContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.CASE"><code class="name">var <span class="ident">CASE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.CEILING"><code class="name">var <span class="ident">CEILING</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.CHOOSE"><code class="name">var <span class="ident">CHOOSE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.CONCAT_PIPE"><code class="name">var <span class="ident">CONCAT_PIPE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.COS"><code class="name">var <span class="ident">COS</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.COT"><code class="name">var <span class="ident">COT</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.COUNT"><code class="name">var <span class="ident">COUNT</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.CROSS"><code class="name">var <span class="ident">CROSS</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.CaseExprContext"><code class="name">var <span class="ident">CaseExprContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.CaseExpressionContext"><code class="name">var <span class="ident">CaseExpressionContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ChooseFuncContext"><code class="name">var <span class="ident">ChooseFuncContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ColumnNameContext"><code class="name">var <span class="ident">ColumnNameContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ComparisonContext"><code class="name">var <span class="ident">ComparisonContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ComparisonOperatorContext"><code class="name">var <span class="ident">ComparisonOperatorContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ConjunctionContext"><code class="name">var <span class="ident">ConjunctionContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.DECIMAL_VALUE"><code class="name">var <span class="ident">DECIMAL_VALUE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.DEGREES"><code class="name">var <span class="ident">DEGREES</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.DENSE_RANK"><code class="name">var <span class="ident">DENSE_RANK</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.DESC"><code class="name">var <span class="ident">DESC</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.DISTINCT"><code class="name">var <span class="ident">DISTINCT</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.DIV"><code class="name">var <span class="ident">DIV</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.DecimalLiteralContext"><code class="name">var <span class="ident">DecimalLiteralContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.DisjunctionContext"><code class="name">var <span class="ident">DisjunctionContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.DivideContext"><code class="name">var <span class="ident">DivideContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ELSE"><code class="name">var <span class="ident">ELSE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.END"><code class="name">var <span class="ident">END</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.EOF"><code class="name">var <span class="ident">EOF</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.EQ"><code class="name">var <span class="ident">EQ</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ESCAPED_IDENTIFIER"><code class="name">var <span class="ident">ESCAPED_IDENTIFIER</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.EXP"><code class="name">var <span class="ident">EXP</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ExpressionContext"><code class="name">var <span class="ident">ExpressionContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ExpressionSubqueryContext"><code class="name">var <span class="ident">ExpressionSubqueryContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.FALSE"><code class="name">var <span class="ident">FALSE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.FLOOR"><code class="name">var <span class="ident">FLOOR</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.FROM"><code class="name">var <span class="ident">FROM</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.FULL"><code class="name">var <span class="ident">FULL</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.FalseLiteralContext"><code class="name">var <span class="ident">FalseLiteralContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.FromClauseContext"><code class="name">var <span class="ident">FromClauseContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.FunctionExprContext"><code class="name">var <span class="ident">FunctionExprContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.FunctionExpressionContext"><code class="name">var <span class="ident">FunctionExpressionContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.GROUP"><code class="name">var <span class="ident">GROUP</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.GT"><code class="name">var <span class="ident">GT</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.GTE"><code class="name">var <span class="ident">GTE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.HAT"><code class="name">var <span class="ident">HAT</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.HAVING"><code class="name">var <span class="ident">HAVING</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.HavingClauseContext"><code class="name">var <span class="ident">HavingClauseContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.IDENT"><code class="name">var <span class="ident">IDENT</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.IDENTIFIER"><code class="name">var <span class="ident">IDENTIFIER</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.IF"><code class="name">var <span class="ident">IF</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.IIF"><code class="name">var <span class="ident">IIF</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.IN"><code class="name">var <span class="ident">IN</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.INNER"><code class="name">var <span class="ident">INNER</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.INTEGER_VALUE"><code class="name">var <span class="ident">INTEGER_VALUE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.INTERSECT"><code class="name">var <span class="ident">INTERSECT</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.IS"><code class="name">var <span class="ident">IS</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.IdentifierContext"><code class="name">var <span class="ident">IdentifierContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.IifFuncContext"><code class="name">var <span class="ident">IifFuncContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.InConditionContext"><code class="name">var <span class="ident">InConditionContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.IntegerLiteralContext"><code class="name">var <span class="ident">IntegerLiteralContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.IsConditionContext"><code class="name">var <span class="ident">IsConditionContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.JOIN"><code class="name">var <span class="ident">JOIN</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.JoinCriteriaContext"><code class="name">var <span class="ident">JoinCriteriaContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.JoinRelationContext"><code class="name">var <span class="ident">JoinRelationContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.JoinTypeContext"><code class="name">var <span class="ident">JoinTypeContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.LEFT"><code class="name">var <span class="ident">LEFT</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.LETTER"><code class="name">var <span class="ident">LETTER</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.LIMIT"><code class="name">var <span class="ident">LIMIT</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.LOG"><code class="name">var <span class="ident">LOG</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.LOG10"><code class="name">var <span class="ident">LOG10</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.LT"><code class="name">var <span class="ident">LT</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.LTE"><code class="name">var <span class="ident">LTE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.LimitClauseContext"><code class="name">var <span class="ident">LimitClauseContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.LiteralContext"><code class="name">var <span class="ident">LiteralContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.LiteralExprContext"><code class="name">var <span class="ident">LiteralExprContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.LogicalNotContext"><code class="name">var <span class="ident">LogicalNotContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.MAX"><code class="name">var <span class="ident">MAX</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.MIN"><code class="name">var <span class="ident">MIN</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.MINUS"><code class="name">var <span class="ident">MINUS</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.MathFuncContext"><code class="name">var <span class="ident">MathFuncContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.MathFunctionNameContext"><code class="name">var <span class="ident">MathFunctionNameContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ModuloContext"><code class="name">var <span class="ident">ModuloContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.MultiplyContext"><code class="name">var <span class="ident">MultiplyContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.NEQ"><code class="name">var <span class="ident">NEQ</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.NEQJ"><code class="name">var <span class="ident">NEQJ</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.NEWID"><code class="name">var <span class="ident">NEWID</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.NOT"><code class="name">var <span class="ident">NOT</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.NSEQ"><code class="name">var <span class="ident">NSEQ</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.NULL"><code class="name">var <span class="ident">NULL</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.NUMERIC"><code class="name">var <span class="ident">NUMERIC</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.NamedExpressionContext"><code class="name">var <span class="ident">NamedExpressionContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.NamedExpressionSeqContext"><code class="name">var <span class="ident">NamedExpressionSeqContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.NestedBooleanContext"><code class="name">var <span class="ident">NestedBooleanContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.NestedExprContext"><code class="name">var <span class="ident">NestedExprContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.NullLiteralContext"><code class="name">var <span class="ident">NullLiteralContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.NumberContext"><code class="name">var <span class="ident">NumberContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.NumberLiteralContext"><code class="name">var <span class="ident">NumberLiteralContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ON"><code class="name">var <span class="ident">ON</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.OR"><code class="name">var <span class="ident">OR</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ORDER"><code class="name">var <span class="ident">ORDER</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.OUTER"><code class="name">var <span class="ident">OUTER</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.OVER"><code class="name">var <span class="ident">OVER</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.OrderClauseContext"><code class="name">var <span class="ident">OrderClauseContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.OverClauseContext"><code class="name">var <span class="ident">OverClauseContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.PARTITION"><code class="name">var <span class="ident">PARTITION</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.PERCENT"><code class="name">var <span class="ident">PERCENT</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.PERCENTILE_CONT"><code class="name">var <span class="ident">PERCENTILE_CONT</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.PERCENTILE_DISC"><code class="name">var <span class="ident">PERCENTILE_DISC</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.PI"><code class="name">var <span class="ident">PI</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.PIPE"><code class="name">var <span class="ident">PIPE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.PLUS"><code class="name">var <span class="ident">PLUS</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.POWER"><code class="name">var <span class="ident">POWER</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.PowerFuncContext"><code class="name">var <span class="ident">PowerFuncContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.PowerFunctionContext"><code class="name">var <span class="ident">PowerFunctionContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.PredicateContext"><code class="name">var <span class="ident">PredicateContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.PredicatedContext"><code class="name">var <span class="ident">PredicatedContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.QN2"><code class="name">var <span class="ident">QN2</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.QN3"><code class="name">var <span class="ident">QN3</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.QualifiedColumnNameContext"><code class="name">var <span class="ident">QualifiedColumnNameContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.QualifiedTableNameContext"><code class="name">var <span class="ident">QualifiedTableNameContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.QueryContext"><code class="name">var <span class="ident">QueryContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RAND"><code class="name">var <span class="ident">RAND</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RANDOM"><code class="name">var <span class="ident">RANDOM</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RANK"><code class="name">var <span class="ident">RANK</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RIGHT"><code class="name">var <span class="ident">RIGHT</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ROUND"><code class="name">var <span class="ident">ROUND</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ROWNUM"><code class="name">var <span class="ident">ROWNUM</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ROW_NUMBER"><code class="name">var <span class="ident">ROW_NUMBER</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_aggregateFunctionName"><code class="name">var <span class="ident">RULE_aggregateFunctionName</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_aggregationClause"><code class="name">var <span class="ident">RULE_aggregationClause</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_aliasedSubquery"><code class="name">var <span class="ident">RULE_aliasedSubquery</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_aliasedTableName"><code class="name">var <span class="ident">RULE_aliasedTableName</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_aliasedTableOrSubquerySeq"><code class="name">var <span class="ident">RULE_aliasedTableOrSubquerySeq</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_aliasedTableSeq"><code class="name">var <span class="ident">RULE_aliasedTableSeq</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_allExpression"><code class="name">var <span class="ident">RULE_allExpression</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_bareFunction"><code class="name">var <span class="ident">RULE_bareFunction</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_bareFunctionName"><code class="name">var <span class="ident">RULE_bareFunctionName</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_batch"><code class="name">var <span class="ident">RULE_batch</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_booleanExpression"><code class="name">var <span class="ident">RULE_booleanExpression</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_booleanValue"><code class="name">var <span class="ident">RULE_booleanValue</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_caseExpression"><code class="name">var <span class="ident">RULE_caseExpression</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_comparisonOperator"><code class="name">var <span class="ident">RULE_comparisonOperator</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_expression"><code class="name">var <span class="ident">RULE_expression</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_expressionSubquery"><code class="name">var <span class="ident">RULE_expressionSubquery</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_fromClause"><code class="name">var <span class="ident">RULE_fromClause</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_functionExpression"><code class="name">var <span class="ident">RULE_functionExpression</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_havingClause"><code class="name">var <span class="ident">RULE_havingClause</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_identifier"><code class="name">var <span class="ident">RULE_identifier</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_joinCriteria"><code class="name">var <span class="ident">RULE_joinCriteria</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_joinRelation"><code class="name">var <span class="ident">RULE_joinRelation</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_joinType"><code class="name">var <span class="ident">RULE_joinType</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_limitClause"><code class="name">var <span class="ident">RULE_limitClause</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_literal"><code class="name">var <span class="ident">RULE_literal</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_mathFunctionName"><code class="name">var <span class="ident">RULE_mathFunctionName</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_namedExpression"><code class="name">var <span class="ident">RULE_namedExpression</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_namedExpressionSeq"><code class="name">var <span class="ident">RULE_namedExpressionSeq</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_number"><code class="name">var <span class="ident">RULE_number</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_orderClause"><code class="name">var <span class="ident">RULE_orderClause</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_overClause"><code class="name">var <span class="ident">RULE_overClause</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_powerFunction"><code class="name">var <span class="ident">RULE_powerFunction</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_predicate"><code class="name">var <span class="ident">RULE_predicate</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_qualifiedColumnName"><code class="name">var <span class="ident">RULE_qualifiedColumnName</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_qualifiedTableName"><code class="name">var <span class="ident">RULE_qualifiedTableName</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_query"><code class="name">var <span class="ident">RULE_query</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_rankingFunction"><code class="name">var <span class="ident">RULE_rankingFunction</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_rankingFunctionName"><code class="name">var <span class="ident">RULE_rankingFunctionName</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_relation"><code class="name">var <span class="ident">RULE_relation</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_relationPrimary"><code class="name">var <span class="ident">RULE_relationPrimary</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_roundFunction"><code class="name">var <span class="ident">RULE_roundFunction</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_selectClause"><code class="name">var <span class="ident">RULE_selectClause</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_setQuantifier"><code class="name">var <span class="ident">RULE_setQuantifier</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_sortItem"><code class="name">var <span class="ident">RULE_sortItem</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_subquery"><code class="name">var <span class="ident">RULE_subquery</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_topClause"><code class="name">var <span class="ident">RULE_topClause</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_whenExpression"><code class="name">var <span class="ident">RULE_whenExpression</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_whereClause"><code class="name">var <span class="ident">RULE_whereClause</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RankFunctionContext"><code class="name">var <span class="ident">RankFunctionContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RankingFunctionContext"><code class="name">var <span class="ident">RankingFunctionContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RankingFunctionNameContext"><code class="name">var <span class="ident">RankingFunctionNameContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RelationContext"><code class="name">var <span class="ident">RelationContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RelationPrimaryContext"><code class="name">var <span class="ident">RelationPrimaryContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RoundFuncContext"><code class="name">var <span class="ident">RoundFuncContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RoundFunctionContext"><code class="name">var <span class="ident">RoundFunctionContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SELECT"><code class="name">var <span class="ident">SELECT</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SEMI"><code class="name">var <span class="ident">SEMI</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SIGN"><code class="name">var <span class="ident">SIGN</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SIMPLE_COMMENT"><code class="name">var <span class="ident">SIMPLE_COMMENT</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SIN"><code class="name">var <span class="ident">SIN</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SLASH"><code class="name">var <span class="ident">SLASH</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SORT"><code class="name">var <span class="ident">SORT</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SPACE"><code class="name">var <span class="ident">SPACE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SQL"><code class="name">var <span class="ident">SQL</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SQRT"><code class="name">var <span class="ident">SQRT</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SQUARE"><code class="name">var <span class="ident">SQUARE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.STD"><code class="name">var <span class="ident">STD</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.STDDEV"><code class="name">var <span class="ident">STDDEV</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.STRING"><code class="name">var <span class="ident">STRING</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SUM"><code class="name">var <span class="ident">SUM</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SelectClauseContext"><code class="name">var <span class="ident">SelectClauseContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SetQuantifierContext"><code class="name">var <span class="ident">SetQuantifierContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SortItemContext"><code class="name">var <span class="ident">SortItemContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.StringLiteralContext"><code class="name">var <span class="ident">StringLiteralContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SubqueryContext"><code class="name">var <span class="ident">SubqueryContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SubqueryExprContext"><code class="name">var <span class="ident">SubqueryExprContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SubtractContext"><code class="name">var <span class="ident">SubtractContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.TAN"><code class="name">var <span class="ident">TAN</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.THEN"><code class="name">var <span class="ident">THEN</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.TILDE"><code class="name">var <span class="ident">TILDE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.TOP"><code class="name">var <span class="ident">TOP</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.TRUE"><code class="name">var <span class="ident">TRUE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.T__0"><code class="name">var <span class="ident">T__0</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.T__1"><code class="name">var <span class="ident">T__1</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.T__2"><code class="name">var <span class="ident">T__2</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.T__3"><code class="name">var <span class="ident">T__3</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.T__4"><code class="name">var <span class="ident">T__4</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.TableContext"><code class="name">var <span class="ident">TableContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.TopClauseContext"><code class="name">var <span class="ident">TopClauseContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.TrueLiteralContext"><code class="name">var <span class="ident">TrueLiteralContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.UNION"><code class="name">var <span class="ident">UNION</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.USING"><code class="name">var <span class="ident">USING</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.UsingJoinContext"><code class="name">var <span class="ident">UsingJoinContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.VAR"><code class="name">var <span class="ident">VAR</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.VARIANCE"><code class="name">var <span class="ident">VARIANCE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.WHEN"><code class="name">var <span class="ident">WHEN</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.WHERE"><code class="name">var <span class="ident">WHERE</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.WS"><code class="name">var <span class="ident">WS</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.WhenExpressionContext"><code class="name">var <span class="ident">WhenExpressionContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.WhereClauseContext"><code class="name">var <span class="ident">WhereClauseContext</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.atn"><code class="name">var <span class="ident">atn</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.decisionsToDFA"><code class="name">var <span class="ident">decisionsToDFA</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.grammarFileName"><code class="name">var <span class="ident">grammarFileName</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.literalNames"><code class="name">var <span class="ident">literalNames</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ruleNames"><code class="name">var <span class="ident">ruleNames</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.sharedContextCache"><code class="name">var <span class="ident">sharedContextCache</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.symbolicNames"><code class="name">var <span class="ident">symbolicNames</span></code></dt>
<dd>
<section class="desc"></section>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.aggregateFunctionName"><code class="name flex">
<span>def <span class="ident">aggregateFunctionName</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def aggregateFunctionName(self):

    localctx = SqlSmallParser.AggregateFunctionNameContext(self, self._ctx, self.state)
    self.enterRule(localctx, 72, self.RULE_aggregateFunctionName)
    self._la = 0 # Token type
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 483
        _la = self._input.LA(1)
        if not((((_la) &amp; ~0x3f) == 0 and ((1 &lt;&lt; _la) &amp; ((1 &lt;&lt; SqlSmallParser.AVG) | (1 &lt;&lt; SqlSmallParser.COUNT) | (1 &lt;&lt; SqlSmallParser.MAX) | (1 &lt;&lt; SqlSmallParser.MIN) | (1 &lt;&lt; SqlSmallParser.PERCENTILE_CONT) | (1 &lt;&lt; SqlSmallParser.PERCENTILE_DISC))) != 0) or ((((_la - 81)) &amp; ~0x3f) == 0 and ((1 &lt;&lt; (_la - 81)) &amp; ((1 &lt;&lt; (SqlSmallParser.STD - 81)) | (1 &lt;&lt; (SqlSmallParser.STDDEV - 81)) | (1 &lt;&lt; (SqlSmallParser.SUM - 81)) | (1 &lt;&lt; (SqlSmallParser.VAR - 81)) | (1 &lt;&lt; (SqlSmallParser.VARIANCE - 81)))) != 0)):
            self._errHandler.recoverInline(self)
        else:
            self._errHandler.reportMatch(self)
            self.consume()
    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.aggregationClause"><code class="name flex">
<span>def <span class="ident">aggregationClause</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def aggregationClause(self):

    localctx = SqlSmallParser.AggregationClauseContext(self, self._ctx, self.state)
    self.enterRule(localctx, 14, self.RULE_aggregationClause)
    self._la = 0 # Token type
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 163
        self.match(SqlSmallParser.GROUP)
        self.state = 164
        self.match(SqlSmallParser.BY)
        self.state = 165
        localctx._expression = self.expression(0)
        localctx.groupingExpressions.append(localctx._expression)
        self.state = 170
        self._errHandler.sync(self)
        _la = self._input.LA(1)
        while _la==SqlSmallParser.T__3:
            self.state = 166
            self.match(SqlSmallParser.T__3)
            self.state = 167
            localctx._expression = self.expression(0)
            localctx.groupingExpressions.append(localctx._expression)
            self.state = 172
            self._errHandler.sync(self)
            _la = self._input.LA(1)

    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.aliasedSubquery"><code class="name flex">
<span>def <span class="ident">aliasedSubquery</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def aliasedSubquery(self):

    localctx = SqlSmallParser.AliasedSubqueryContext(self, self._ctx, self.state)
    self.enterRule(localctx, 80, self.RULE_aliasedSubquery)
    self._la = 0 # Token type
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 501
        self.subquery()
        self.state = 504
        self._errHandler.sync(self)
        _la = self._input.LA(1)
        if _la==SqlSmallParser.AS:
            self.state = 502
            self.match(SqlSmallParser.AS)
            self.state = 503
            localctx.alias = self.identifier()


    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.aliasedTableName"><code class="name flex">
<span>def <span class="ident">aliasedTableName</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def aliasedTableName(self):

    localctx = SqlSmallParser.AliasedTableNameContext(self, self._ctx, self.state)
    self.enterRule(localctx, 86, self.RULE_aliasedTableName)
    self._la = 0 # Token type
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 528
        self.qualifiedTableName()
        self.state = 531
        self._errHandler.sync(self)
        _la = self._input.LA(1)
        if _la==SqlSmallParser.AS:
            self.state = 529
            self.match(SqlSmallParser.AS)
            self.state = 530
            localctx.alias = self.identifier()


    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.aliasedTableOrSubquerySeq"><code class="name flex">
<span>def <span class="ident">aliasedTableOrSubquerySeq</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def aliasedTableOrSubquerySeq(self):

    localctx = SqlSmallParser.AliasedTableOrSubquerySeqContext(self, self._ctx, self.state)
    self.enterRule(localctx, 82, self.RULE_aliasedTableOrSubquerySeq)
    self._la = 0 # Token type
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 508
        self._errHandler.sync(self)
        token = self._input.LA(1)
        if token in [SqlSmallParser.QN2, SqlSmallParser.QN3, SqlSmallParser.IDENT]:
            self.state = 506
            self.aliasedTableName()
            pass
        elif token in [SqlSmallParser.T__1]:
            self.state = 507
            self.aliasedSubquery()
            pass
        else:
            raise NoViableAltException(self)

        self.state = 517
        self._errHandler.sync(self)
        _la = self._input.LA(1)
        while _la==SqlSmallParser.T__3:
            self.state = 510
            self.match(SqlSmallParser.T__3)
            self.state = 513
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [SqlSmallParser.QN2, SqlSmallParser.QN3, SqlSmallParser.IDENT]:
                self.state = 511
                self.aliasedTableName()
                pass
            elif token in [SqlSmallParser.T__1]:
                self.state = 512
                self.aliasedSubquery()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 519
            self._errHandler.sync(self)
            _la = self._input.LA(1)

    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.aliasedTableSeq"><code class="name flex">
<span>def <span class="ident">aliasedTableSeq</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def aliasedTableSeq(self):

    localctx = SqlSmallParser.AliasedTableSeqContext(self, self._ctx, self.state)
    self.enterRule(localctx, 84, self.RULE_aliasedTableSeq)
    self._la = 0 # Token type
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 520
        self.aliasedTableName()
        self.state = 525
        self._errHandler.sync(self)
        _la = self._input.LA(1)
        while _la==SqlSmallParser.T__3:
            self.state = 521
            self.match(SqlSmallParser.T__3)
            self.state = 522
            self.aliasedTableName()
            self.state = 527
            self._errHandler.sync(self)
            _la = self._input.LA(1)

    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.allExpression"><code class="name flex">
<span>def <span class="ident">allExpression</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def allExpression(self):

    localctx = SqlSmallParser.AllExpressionContext(self, self._ctx, self.state)
    self.enterRule(localctx, 48, self.RULE_allExpression)
    try:
        self.state = 350
        self._errHandler.sync(self)
        token = self._input.LA(1)
        if token in [SqlSmallParser.ASTERISK]:
            self.enterOuterAlt(localctx, 1)
            self.state = 345
            self.match(SqlSmallParser.ASTERISK)
            pass
        elif token in [SqlSmallParser.IDENT]:
            self.enterOuterAlt(localctx, 2)
            self.state = 346
            self.identifier()
            self.state = 347
            self.match(SqlSmallParser.T__4)
            self.state = 348
            self.match(SqlSmallParser.ASTERISK)
            pass
        else:
            raise NoViableAltException(self)

    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.bareFunction"><code class="name flex">
<span>def <span class="ident">bareFunction</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bareFunction(self):

    localctx = SqlSmallParser.BareFunctionContext(self, self._ctx, self.state)
    self.enterRule(localctx, 62, self.RULE_bareFunction)
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 458
        localctx.function = self.bareFunctionName()
        self.state = 459
        self.match(SqlSmallParser.T__1)
        self.state = 460
        self.match(SqlSmallParser.T__2)
    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.bareFunctionName"><code class="name flex">
<span>def <span class="ident">bareFunctionName</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def bareFunctionName(self):

    localctx = SqlSmallParser.BareFunctionNameContext(self, self._ctx, self.state)
    self.enterRule(localctx, 76, self.RULE_bareFunctionName)
    self._la = 0 # Token type
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 487
        _la = self._input.LA(1)
        if not(((((_la - 52)) &amp; ~0x3f) == 0 and ((1 &lt;&lt; (_la - 52)) &amp; ((1 &lt;&lt; (SqlSmallParser.NEWID - 52)) | (1 &lt;&lt; (SqlSmallParser.PI - 52)) | (1 &lt;&lt; (SqlSmallParser.RAND - 52)) | (1 &lt;&lt; (SqlSmallParser.RANDOM - 52)))) != 0)):
            self._errHandler.recoverInline(self)
        else:
            self._errHandler.reportMatch(self)
            self.consume()
    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.batch"><code class="name flex">
<span>def <span class="ident">batch</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def batch(self):

    localctx = SqlSmallParser.BatchContext(self, self._ctx, self.state)
    self.enterRule(localctx, 0, self.RULE_batch)
    self._la = 0 # Token type
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 96
        self.query()
        self.state = 101
        self._errHandler.sync(self)
        _alt = self._interp.adaptivePredict(self._input,0,self._ctx)
        while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
            if _alt==1:
                self.state = 97
                self.match(SqlSmallParser.T__0)
                self.state = 98
                self.query() 
            self.state = 103
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,0,self._ctx)

        self.state = 105
        self._errHandler.sync(self)
        _la = self._input.LA(1)
        if _la==SqlSmallParser.T__0:
            self.state = 104
            self.match(SqlSmallParser.T__0)


        self.state = 107
        self.match(SqlSmallParser.EOF)
    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.booleanExpression"><code class="name flex">
<span>def <span class="ident">booleanExpression</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def booleanExpression(self, _p:int=0):
    _parentctx = self._ctx
    _parentState = self.state
    localctx = SqlSmallParser.BooleanExpressionContext(self, self._ctx, _parentState)
    _prevctx = localctx
    _startState = 52
    self.enterRecursionRule(localctx, 52, self.RULE_booleanExpression, _p)
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 373
        self._errHandler.sync(self)
        la_ = self._interp.adaptivePredict(self._input,43,self._ctx)
        if la_ == 1:
            localctx = SqlSmallParser.LogicalNotContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 360
            self.match(SqlSmallParser.NOT)
            self.state = 361
            self.booleanExpression(6)
            pass

        elif la_ == 2:
            localctx = SqlSmallParser.ComparisonContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx
            self.state = 362
            localctx.left = self.expression(0)
            self.state = 363
            localctx.op = self.comparisonOperator()
            self.state = 364
            localctx.right = self.expression(0)
            pass

        elif la_ == 3:
            localctx = SqlSmallParser.NestedBooleanContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx
            self.state = 366
            self.match(SqlSmallParser.T__1)
            self.state = 367
            self.booleanExpression(0)
            self.state = 368
            self.match(SqlSmallParser.T__2)
            pass

        elif la_ == 4:
            localctx = SqlSmallParser.PredicatedContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx
            self.state = 370
            self.expression(0)
            self.state = 371
            self.predicate()
            pass


        self._ctx.stop = self._input.LT(-1)
        self.state = 383
        self._errHandler.sync(self)
        _alt = self._interp.adaptivePredict(self._input,45,self._ctx)
        while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
            if _alt==1:
                if self._parseListeners is not None:
                    self.triggerExitRuleEvent()
                _prevctx = localctx
                self.state = 381
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,44,self._ctx)
                if la_ == 1:
                    localctx = SqlSmallParser.ConjunctionContext(self, SqlSmallParser.BooleanExpressionContext(self, _parentctx, _parentState))
                    localctx.left = _prevctx
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_booleanExpression)
                    self.state = 375
                    if not self.precpred(self._ctx, 4):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, &#34;self.precpred(self._ctx, 4)&#34;)
                    self.state = 376
                    self.match(SqlSmallParser.AND)
                    self.state = 377
                    localctx.right = self.booleanExpression(5)
                    pass

                elif la_ == 2:
                    localctx = SqlSmallParser.DisjunctionContext(self, SqlSmallParser.BooleanExpressionContext(self, _parentctx, _parentState))
                    localctx.left = _prevctx
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_booleanExpression)
                    self.state = 378
                    if not self.precpred(self._ctx, 3):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, &#34;self.precpred(self._ctx, 3)&#34;)
                    self.state = 379
                    self.match(SqlSmallParser.OR)
                    self.state = 380
                    localctx.right = self.booleanExpression(4)
                    pass

         
            self.state = 385
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,45,self._ctx)

    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.unrollRecursionContexts(_parentctx)
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.booleanExpression_sempred"><code class="name flex">
<span>def <span class="ident">booleanExpression_sempred</span></span>(<span>self, localctx, predIndex)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def booleanExpression_sempred(self, localctx:BooleanExpressionContext, predIndex:int):
        if predIndex == 5:
            return self.precpred(self._ctx, 4)
     

        if predIndex == 6:
            return self.precpred(self._ctx, 3)</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.booleanValue"><code class="name flex">
<span>def <span class="ident">booleanValue</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def booleanValue(self):

    localctx = SqlSmallParser.BooleanValueContext(self, self._ctx, self.state)
    self.enterRule(localctx, 58, self.RULE_booleanValue)
    self._la = 0 # Token type
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 418
        _la = self._input.LA(1)
        if not(_la==SqlSmallParser.FALSE or _la==SqlSmallParser.TRUE):
            self._errHandler.recoverInline(self)
        else:
            self._errHandler.reportMatch(self)
            self.consume()
    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.caseExpression"><code class="name flex">
<span>def <span class="ident">caseExpression</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def caseExpression(self):

    localctx = SqlSmallParser.CaseExpressionContext(self, self._ctx, self.state)
    self.enterRule(localctx, 38, self.RULE_caseExpression)
    self._la = 0 # Token type
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 275
        self.match(SqlSmallParser.CASE)
        self.state = 277
        self._errHandler.sync(self)
        _la = self._input.LA(1)
        if (((_la) &amp; ~0x3f) == 0 and ((1 &lt;&lt; _la) &amp; ((1 &lt;&lt; SqlSmallParser.T__1) | (1 &lt;&lt; SqlSmallParser.ABS) | (1 &lt;&lt; SqlSmallParser.ACOS) | (1 &lt;&lt; SqlSmallParser.ASIN) | (1 &lt;&lt; SqlSmallParser.ATAN) | (1 &lt;&lt; SqlSmallParser.AVG) | (1 &lt;&lt; SqlSmallParser.CASE) | (1 &lt;&lt; SqlSmallParser.CEILING) | (1 &lt;&lt; SqlSmallParser.CHOOSE) | (1 &lt;&lt; SqlSmallParser.COS) | (1 &lt;&lt; SqlSmallParser.COUNT) | (1 &lt;&lt; SqlSmallParser.DEGREES) | (1 &lt;&lt; SqlSmallParser.DENSE_RANK) | (1 &lt;&lt; SqlSmallParser.EXP) | (1 &lt;&lt; SqlSmallParser.FALSE) | (1 &lt;&lt; SqlSmallParser.FLOOR) | (1 &lt;&lt; SqlSmallParser.IIF) | (1 &lt;&lt; SqlSmallParser.LOG) | (1 &lt;&lt; SqlSmallParser.LOG10) | (1 &lt;&lt; SqlSmallParser.MAX) | (1 &lt;&lt; SqlSmallParser.MIN) | (1 &lt;&lt; SqlSmallParser.NEWID) | (1 &lt;&lt; SqlSmallParser.NULL) | (1 &lt;&lt; SqlSmallParser.PERCENTILE_CONT) | (1 &lt;&lt; SqlSmallParser.PERCENTILE_DISC))) != 0) or ((((_la - 64)) &amp; ~0x3f) == 0 and ((1 &lt;&lt; (_la - 64)) &amp; ((1 &lt;&lt; (SqlSmallParser.PI - 64)) | (1 &lt;&lt; (SqlSmallParser.POWER - 64)) | (1 &lt;&lt; (SqlSmallParser.RAND - 64)) | (1 &lt;&lt; (SqlSmallParser.RANDOM - 64)) | (1 &lt;&lt; (SqlSmallParser.RANK - 64)) | (1 &lt;&lt; (SqlSmallParser.ROUND - 64)) | (1 &lt;&lt; (SqlSmallParser.ROW_NUMBER - 64)) | (1 &lt;&lt; (SqlSmallParser.SIGN - 64)) | (1 &lt;&lt; (SqlSmallParser.SIN - 64)) | (1 &lt;&lt; (SqlSmallParser.SQRT - 64)) | (1 &lt;&lt; (SqlSmallParser.SQUARE - 64)) | (1 &lt;&lt; (SqlSmallParser.STD - 64)) | (1 &lt;&lt; (SqlSmallParser.STDDEV - 64)) | (1 &lt;&lt; (SqlSmallParser.SUM - 64)) | (1 &lt;&lt; (SqlSmallParser.TAN - 64)) | (1 &lt;&lt; (SqlSmallParser.TRUE - 64)) | (1 &lt;&lt; (SqlSmallParser.VAR - 64)) | (1 &lt;&lt; (SqlSmallParser.VARIANCE - 64)) | (1 &lt;&lt; (SqlSmallParser.MINUS - 64)) | (1 &lt;&lt; (SqlSmallParser.ASTERISK - 64)) | (1 &lt;&lt; (SqlSmallParser.STRING - 64)) | (1 &lt;&lt; (SqlSmallParser.INTEGER_VALUE - 64)) | (1 &lt;&lt; (SqlSmallParser.DECIMAL_VALUE - 64)) | (1 &lt;&lt; (SqlSmallParser.QN2 - 64)) | (1 &lt;&lt; (SqlSmallParser.IDENT - 64)))) != 0):
            self.state = 276
            localctx.baseCaseExpr = self.expression(0)


        self.state = 280 
        self._errHandler.sync(self)
        _la = self._input.LA(1)
        while True:
            self.state = 279
            self.whenExpression()
            self.state = 282 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if not (_la==SqlSmallParser.WHEN):
                break

        self.state = 286
        self._errHandler.sync(self)
        _la = self._input.LA(1)
        if _la==SqlSmallParser.ELSE:
            self.state = 284
            self.match(SqlSmallParser.ELSE)
            self.state = 285
            localctx.elseExpr = self.expression(0)


        self.state = 288
        self.match(SqlSmallParser.END)
    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.comparisonOperator"><code class="name flex">
<span>def <span class="ident">comparisonOperator</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def comparisonOperator(self):

    localctx = SqlSmallParser.ComparisonOperatorContext(self, self._ctx, self.state)
    self.enterRule(localctx, 56, self.RULE_comparisonOperator)
    self._la = 0 # Token type
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 416
        _la = self._input.LA(1)
        if not(((((_la - 94)) &amp; ~0x3f) == 0 and ((1 &lt;&lt; (_la - 94)) &amp; ((1 &lt;&lt; (SqlSmallParser.EQ - 94)) | (1 &lt;&lt; (SqlSmallParser.NSEQ - 94)) | (1 &lt;&lt; (SqlSmallParser.NEQ - 94)) | (1 &lt;&lt; (SqlSmallParser.NEQJ - 94)) | (1 &lt;&lt; (SqlSmallParser.LT - 94)) | (1 &lt;&lt; (SqlSmallParser.LTE - 94)) | (1 &lt;&lt; (SqlSmallParser.GT - 94)) | (1 &lt;&lt; (SqlSmallParser.GTE - 94)))) != 0)):
            self._errHandler.recoverInline(self)
        else:
            self._errHandler.reportMatch(self)
            self.consume()
    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.expression"><code class="name flex">
<span>def <span class="ident">expression</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expression(self, _p:int=0):
    _parentctx = self._ctx
    _parentState = self.state
    localctx = SqlSmallParser.ExpressionContext(self, self._ctx, _parentState)
    _prevctx = localctx
    _startState = 46
    self.enterRecursionRule(localctx, 46, self.RULE_expression, _p)
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 323
        self._errHandler.sync(self)
        la_ = self._interp.adaptivePredict(self._input,38,self._ctx)
        if la_ == 1:
            localctx = SqlSmallParser.ColumnNameContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 312
            localctx.name = self.qualifiedColumnName()
            pass

        elif la_ == 2:
            localctx = SqlSmallParser.CaseExprContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx
            self.state = 313
            self.caseExpression()
            pass

        elif la_ == 3:
            localctx = SqlSmallParser.AllExprContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx
            self.state = 314
            self.allExpression()
            pass

        elif la_ == 4:
            localctx = SqlSmallParser.LiteralExprContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx
            self.state = 315
            self.literal()
            pass

        elif la_ == 5:
            localctx = SqlSmallParser.RankFunctionContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx
            self.state = 316
            self.rankingFunction()
            pass

        elif la_ == 6:
            localctx = SqlSmallParser.FunctionExprContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx
            self.state = 317
            self.functionExpression()
            pass

        elif la_ == 7:
            localctx = SqlSmallParser.SubqueryExprContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx
            self.state = 318
            self.expressionSubquery()
            pass

        elif la_ == 8:
            localctx = SqlSmallParser.NestedExprContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx
            self.state = 319
            self.match(SqlSmallParser.T__1)
            self.state = 320
            self.expression(0)
            self.state = 321
            self.match(SqlSmallParser.T__2)
            pass


        self._ctx.stop = self._input.LT(-1)
        self.state = 342
        self._errHandler.sync(self)
        _alt = self._interp.adaptivePredict(self._input,40,self._ctx)
        while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
            if _alt==1:
                if self._parseListeners is not None:
                    self.triggerExitRuleEvent()
                _prevctx = localctx
                self.state = 340
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,39,self._ctx)
                if la_ == 1:
                    localctx = SqlSmallParser.MultiplyContext(self, SqlSmallParser.ExpressionContext(self, _parentctx, _parentState))
                    localctx.left = _prevctx
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                    self.state = 325
                    if not self.precpred(self._ctx, 12):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, &#34;self.precpred(self._ctx, 12)&#34;)
                    self.state = 326
                    localctx.op = self.match(SqlSmallParser.ASTERISK)
                    self.state = 327
                    localctx.right = self.expression(13)
                    pass

                elif la_ == 2:
                    localctx = SqlSmallParser.DivideContext(self, SqlSmallParser.ExpressionContext(self, _parentctx, _parentState))
                    localctx.left = _prevctx
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                    self.state = 328
                    if not self.precpred(self._ctx, 11):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, &#34;self.precpred(self._ctx, 11)&#34;)
                    self.state = 329
                    localctx.op = self.match(SqlSmallParser.SLASH)
                    self.state = 330
                    localctx.right = self.expression(12)
                    pass

                elif la_ == 3:
                    localctx = SqlSmallParser.ModuloContext(self, SqlSmallParser.ExpressionContext(self, _parentctx, _parentState))
                    localctx.left = _prevctx
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                    self.state = 331
                    if not self.precpred(self._ctx, 10):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, &#34;self.precpred(self._ctx, 10)&#34;)
                    self.state = 332
                    localctx.op = self.match(SqlSmallParser.PERCENT)
                    self.state = 333
                    localctx.right = self.expression(11)
                    pass

                elif la_ == 4:
                    localctx = SqlSmallParser.AddContext(self, SqlSmallParser.ExpressionContext(self, _parentctx, _parentState))
                    localctx.left = _prevctx
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                    self.state = 334
                    if not self.precpred(self._ctx, 9):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, &#34;self.precpred(self._ctx, 9)&#34;)
                    self.state = 335
                    localctx.op = self.match(SqlSmallParser.PLUS)
                    self.state = 336
                    localctx.right = self.expression(10)
                    pass

                elif la_ == 5:
                    localctx = SqlSmallParser.SubtractContext(self, SqlSmallParser.ExpressionContext(self, _parentctx, _parentState))
                    localctx.left = _prevctx
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_expression)
                    self.state = 337
                    if not self.precpred(self._ctx, 8):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, &#34;self.precpred(self._ctx, 8)&#34;)
                    self.state = 338
                    localctx.op = self.match(SqlSmallParser.MINUS)
                    self.state = 339
                    localctx.right = self.expression(9)
                    pass

         
            self.state = 344
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,40,self._ctx)

    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.unrollRecursionContexts(_parentctx)
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.expressionSubquery"><code class="name flex">
<span>def <span class="ident">expressionSubquery</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expressionSubquery(self):

    localctx = SqlSmallParser.ExpressionSubqueryContext(self, self._ctx, self.state)
    self.enterRule(localctx, 6, self.RULE_expressionSubquery)
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 143
        self.subquery()
    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.expression_sempred"><code class="name flex">
<span>def <span class="ident">expression_sempred</span></span>(<span>self, localctx, predIndex)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expression_sempred(self, localctx:ExpressionContext, predIndex:int):
        if predIndex == 0:
            return self.precpred(self._ctx, 12)
     

        if predIndex == 1:
            return self.precpred(self._ctx, 11)
     

        if predIndex == 2:
            return self.precpred(self._ctx, 10)
     

        if predIndex == 3:
            return self.precpred(self._ctx, 9)
     

        if predIndex == 4:
            return self.precpred(self._ctx, 8)</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.fromClause"><code class="name flex">
<span>def <span class="ident">fromClause</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fromClause(self):

    localctx = SqlSmallParser.FromClauseContext(self, self._ctx, self.state)
    self.enterRule(localctx, 10, self.RULE_fromClause)
    self._la = 0 # Token type
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 151
        self.match(SqlSmallParser.FROM)
        self.state = 152
        self.relation()
        self.state = 157
        self._errHandler.sync(self)
        _la = self._input.LA(1)
        while _la==SqlSmallParser.T__3:
            self.state = 153
            self.match(SqlSmallParser.T__3)
            self.state = 154
            self.relation()
            self.state = 159
            self._errHandler.sync(self)
            _la = self._input.LA(1)

    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.functionExpression"><code class="name flex">
<span>def <span class="ident">functionExpression</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def functionExpression(self):

    localctx = SqlSmallParser.FunctionExpressionContext(self, self._ctx, self.state)
    self.enterRule(localctx, 60, self.RULE_functionExpression)
    self._la = 0 # Token type
    try:
        self.state = 456
        self._errHandler.sync(self)
        token = self._input.LA(1)
        if token in [SqlSmallParser.NEWID, SqlSmallParser.PI, SqlSmallParser.RAND, SqlSmallParser.RANDOM]:
            localctx = SqlSmallParser.BareFuncContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 420
            self.bareFunction()
            pass
        elif token in [SqlSmallParser.ROUND]:
            localctx = SqlSmallParser.RoundFuncContext(self, localctx)
            self.enterOuterAlt(localctx, 2)
            self.state = 421
            self.roundFunction()
            pass
        elif token in [SqlSmallParser.POWER]:
            localctx = SqlSmallParser.PowerFuncContext(self, localctx)
            self.enterOuterAlt(localctx, 3)
            self.state = 422
            self.powerFunction()
            pass
        elif token in [SqlSmallParser.AVG, SqlSmallParser.COUNT, SqlSmallParser.MAX, SqlSmallParser.MIN, SqlSmallParser.PERCENTILE_CONT, SqlSmallParser.PERCENTILE_DISC, SqlSmallParser.STD, SqlSmallParser.STDDEV, SqlSmallParser.SUM, SqlSmallParser.VAR, SqlSmallParser.VARIANCE]:
            localctx = SqlSmallParser.AggFuncContext(self, localctx)
            self.enterOuterAlt(localctx, 4)
            self.state = 423
            localctx.function = self.aggregateFunctionName()
            self.state = 424
            self.match(SqlSmallParser.T__1)
            self.state = 426
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.ALL or _la==SqlSmallParser.DISTINCT or _la==SqlSmallParser.TOP:
                self.state = 425
                self.setQuantifier()


            self.state = 428
            self.expression(0)
            self.state = 429
            self.match(SqlSmallParser.T__2)
            pass
        elif token in [SqlSmallParser.ABS, SqlSmallParser.ACOS, SqlSmallParser.ASIN, SqlSmallParser.ATAN, SqlSmallParser.CEILING, SqlSmallParser.COS, SqlSmallParser.DEGREES, SqlSmallParser.EXP, SqlSmallParser.FLOOR, SqlSmallParser.LOG, SqlSmallParser.LOG10, SqlSmallParser.SIGN, SqlSmallParser.SIN, SqlSmallParser.SQRT, SqlSmallParser.SQUARE, SqlSmallParser.TAN]:
            localctx = SqlSmallParser.MathFuncContext(self, localctx)
            self.enterOuterAlt(localctx, 5)
            self.state = 431
            localctx.function = self.mathFunctionName()
            self.state = 432
            self.match(SqlSmallParser.T__1)
            self.state = 433
            self.expression(0)
            self.state = 434
            self.match(SqlSmallParser.T__2)
            pass
        elif token in [SqlSmallParser.IIF]:
            localctx = SqlSmallParser.IifFuncContext(self, localctx)
            self.enterOuterAlt(localctx, 6)
            self.state = 436
            self.match(SqlSmallParser.IIF)
            self.state = 437
            self.match(SqlSmallParser.T__1)
            self.state = 438
            localctx.test = self.booleanExpression(0)
            self.state = 439
            self.match(SqlSmallParser.T__3)
            self.state = 440
            localctx.yes = self.expression(0)
            self.state = 441
            self.match(SqlSmallParser.T__3)
            self.state = 442
            localctx.no = self.expression(0)
            self.state = 443
            self.match(SqlSmallParser.T__2)
            pass
        elif token in [SqlSmallParser.CHOOSE]:
            localctx = SqlSmallParser.ChooseFuncContext(self, localctx)
            self.enterOuterAlt(localctx, 7)
            self.state = 445
            self.match(SqlSmallParser.CHOOSE)
            self.state = 446
            self.match(SqlSmallParser.T__1)
            self.state = 447
            localctx.index = self.expression(0)
            self.state = 450 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 448
                self.match(SqlSmallParser.T__3)
                self.state = 449
                self.literal()
                self.state = 452 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==SqlSmallParser.T__3):
                    break

            self.state = 454
            self.match(SqlSmallParser.T__2)
            pass
        else:
            raise NoViableAltException(self)

    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.havingClause"><code class="name flex">
<span>def <span class="ident">havingClause</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def havingClause(self):

    localctx = SqlSmallParser.HavingClauseContext(self, self._ctx, self.state)
    self.enterRule(localctx, 16, self.RULE_havingClause)
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 173
        self.match(SqlSmallParser.HAVING)
        self.state = 174
        self.booleanExpression(0)
    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.identifier"><code class="name flex">
<span>def <span class="ident">identifier</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def identifier(self):

    localctx = SqlSmallParser.IdentifierContext(self, self._ctx, self.state)
    self.enterRule(localctx, 92, self.RULE_identifier)
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 537
        self.match(SqlSmallParser.IDENT)
    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.joinCriteria"><code class="name flex">
<span>def <span class="ident">joinCriteria</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def joinCriteria(self):

    localctx = SqlSmallParser.JoinCriteriaContext(self, self._ctx, self.state)
    self.enterRule(localctx, 28, self.RULE_joinCriteria)
    self._la = 0 # Token type
    try:
        self.state = 238
        self._errHandler.sync(self)
        token = self._input.LA(1)
        if token in [SqlSmallParser.ON]:
            localctx = SqlSmallParser.BooleanJoinContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 224
            self.match(SqlSmallParser.ON)
            self.state = 225
            self.booleanExpression(0)
            pass
        elif token in [SqlSmallParser.USING]:
            localctx = SqlSmallParser.UsingJoinContext(self, localctx)
            self.enterOuterAlt(localctx, 2)
            self.state = 226
            self.match(SqlSmallParser.USING)
            self.state = 227
            self.match(SqlSmallParser.T__1)
            self.state = 228
            self.identifier()
            self.state = 233
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SqlSmallParser.T__3:
                self.state = 229
                self.match(SqlSmallParser.T__3)
                self.state = 230
                self.identifier()
                self.state = 235
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 236
            self.match(SqlSmallParser.T__2)
            pass
        else:
            raise NoViableAltException(self)

    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.joinRelation"><code class="name flex">
<span>def <span class="ident">joinRelation</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def joinRelation(self):

    localctx = SqlSmallParser.JoinRelationContext(self, self._ctx, self.state)
    self.enterRule(localctx, 24, self.RULE_joinRelation)
    self._la = 0 # Token type
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 192
        self.joinType()
        self.state = 193
        self.match(SqlSmallParser.JOIN)
        self.state = 194
        localctx.right = self.relationPrimary()
        self.state = 196
        self._errHandler.sync(self)
        _la = self._input.LA(1)
        if _la==SqlSmallParser.ON or _la==SqlSmallParser.USING:
            self.state = 195
            self.joinCriteria()


    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.joinType"><code class="name flex">
<span>def <span class="ident">joinType</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def joinType(self):

    localctx = SqlSmallParser.JoinTypeContext(self, self._ctx, self.state)
    self.enterRule(localctx, 26, self.RULE_joinType)
    self._la = 0 # Token type
    try:
        self.state = 222
        self._errHandler.sync(self)
        la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
        if la_ == 1:
            self.enterOuterAlt(localctx, 1)
            self.state = 199
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.INNER:
                self.state = 198
                self.match(SqlSmallParser.INNER)


            pass

        elif la_ == 2:
            self.enterOuterAlt(localctx, 2)
            self.state = 201
            self.match(SqlSmallParser.CROSS)
            pass

        elif la_ == 3:
            self.enterOuterAlt(localctx, 3)
            self.state = 202
            self.match(SqlSmallParser.LEFT)
            self.state = 204
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.OUTER:
                self.state = 203
                self.match(SqlSmallParser.OUTER)


            pass

        elif la_ == 4:
            self.enterOuterAlt(localctx, 4)
            self.state = 207
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.LEFT:
                self.state = 206
                self.match(SqlSmallParser.LEFT)


            self.state = 209
            self.match(SqlSmallParser.SEMI)
            pass

        elif la_ == 5:
            self.enterOuterAlt(localctx, 5)
            self.state = 210
            self.match(SqlSmallParser.RIGHT)
            self.state = 212
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.OUTER:
                self.state = 211
                self.match(SqlSmallParser.OUTER)


            pass

        elif la_ == 6:
            self.enterOuterAlt(localctx, 6)
            self.state = 214
            self.match(SqlSmallParser.FULL)
            self.state = 216
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.OUTER:
                self.state = 215
                self.match(SqlSmallParser.OUTER)


            pass

        elif la_ == 7:
            self.enterOuterAlt(localctx, 7)
            self.state = 219
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.LEFT:
                self.state = 218
                self.match(SqlSmallParser.LEFT)


            self.state = 221
            self.match(SqlSmallParser.ANTI)
            pass


    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.limitClause"><code class="name flex">
<span>def <span class="ident">limitClause</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def limitClause(self):

    localctx = SqlSmallParser.LimitClauseContext(self, self._ctx, self.state)
    self.enterRule(localctx, 20, self.RULE_limitClause)
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 186
        self.match(SqlSmallParser.LIMIT)
        self.state = 187
        localctx.n = self.number()
    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.literal"><code class="name flex">
<span>def <span class="ident">literal</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def literal(self):

    localctx = SqlSmallParser.LiteralContext(self, self._ctx, self.state)
    self.enterRule(localctx, 50, self.RULE_literal)
    try:
        self.state = 357
        self._errHandler.sync(self)
        token = self._input.LA(1)
        if token in [SqlSmallParser.STRING]:
            localctx = SqlSmallParser.StringLiteralContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 352
            self.match(SqlSmallParser.STRING)
            pass
        elif token in [SqlSmallParser.MINUS, SqlSmallParser.INTEGER_VALUE, SqlSmallParser.DECIMAL_VALUE]:
            localctx = SqlSmallParser.NumberLiteralContext(self, localctx)
            self.enterOuterAlt(localctx, 2)
            self.state = 353
            self.number()
            pass
        elif token in [SqlSmallParser.TRUE]:
            localctx = SqlSmallParser.TrueLiteralContext(self, localctx)
            self.enterOuterAlt(localctx, 3)
            self.state = 354
            self.match(SqlSmallParser.TRUE)
            pass
        elif token in [SqlSmallParser.FALSE]:
            localctx = SqlSmallParser.FalseLiteralContext(self, localctx)
            self.enterOuterAlt(localctx, 4)
            self.state = 355
            self.match(SqlSmallParser.FALSE)
            pass
        elif token in [SqlSmallParser.NULL]:
            localctx = SqlSmallParser.NullLiteralContext(self, localctx)
            self.enterOuterAlt(localctx, 5)
            self.state = 356
            self.match(SqlSmallParser.NULL)
            pass
        else:
            raise NoViableAltException(self)

    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.mathFunctionName"><code class="name flex">
<span>def <span class="ident">mathFunctionName</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def mathFunctionName(self):

    localctx = SqlSmallParser.MathFunctionNameContext(self, self._ctx, self.state)
    self.enterRule(localctx, 74, self.RULE_mathFunctionName)
    self._la = 0 # Token type
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 485
        _la = self._input.LA(1)
        if not((((_la) &amp; ~0x3f) == 0 and ((1 &lt;&lt; _la) &amp; ((1 &lt;&lt; SqlSmallParser.ABS) | (1 &lt;&lt; SqlSmallParser.ACOS) | (1 &lt;&lt; SqlSmallParser.ASIN) | (1 &lt;&lt; SqlSmallParser.ATAN) | (1 &lt;&lt; SqlSmallParser.CEILING) | (1 &lt;&lt; SqlSmallParser.COS) | (1 &lt;&lt; SqlSmallParser.DEGREES) | (1 &lt;&lt; SqlSmallParser.EXP) | (1 &lt;&lt; SqlSmallParser.FLOOR) | (1 &lt;&lt; SqlSmallParser.LOG) | (1 &lt;&lt; SqlSmallParser.LOG10))) != 0) or ((((_la - 75)) &amp; ~0x3f) == 0 and ((1 &lt;&lt; (_la - 75)) &amp; ((1 &lt;&lt; (SqlSmallParser.SIGN - 75)) | (1 &lt;&lt; (SqlSmallParser.SIN - 75)) | (1 &lt;&lt; (SqlSmallParser.SQRT - 75)) | (1 &lt;&lt; (SqlSmallParser.SQUARE - 75)) | (1 &lt;&lt; (SqlSmallParser.TAN - 75)))) != 0)):
            self._errHandler.recoverInline(self)
        else:
            self._errHandler.reportMatch(self)
            self.consume()
    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.namedExpression"><code class="name flex">
<span>def <span class="ident">namedExpression</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def namedExpression(self):

    localctx = SqlSmallParser.NamedExpressionContext(self, self._ctx, self.state)
    self.enterRule(localctx, 40, self.RULE_namedExpression)
    self._la = 0 # Token type
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 290
        self.expression(0)
        self.state = 293
        self._errHandler.sync(self)
        _la = self._input.LA(1)
        if _la==SqlSmallParser.AS:
            self.state = 291
            self.match(SqlSmallParser.AS)
            self.state = 292
            localctx.name = self.identifier()


    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.namedExpressionSeq"><code class="name flex">
<span>def <span class="ident">namedExpressionSeq</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def namedExpressionSeq(self):

    localctx = SqlSmallParser.NamedExpressionSeqContext(self, self._ctx, self.state)
    self.enterRule(localctx, 42, self.RULE_namedExpressionSeq)
    self._la = 0 # Token type
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 295
        self.namedExpression()
        self.state = 300
        self._errHandler.sync(self)
        _la = self._input.LA(1)
        while _la==SqlSmallParser.T__3:
            self.state = 296
            self.match(SqlSmallParser.T__3)
            self.state = 297
            self.namedExpression()
            self.state = 302
            self._errHandler.sync(self)
            _la = self._input.LA(1)

    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.number"><code class="name flex">
<span>def <span class="ident">number</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def number(self):

    localctx = SqlSmallParser.NumberContext(self, self._ctx, self.state)
    self.enterRule(localctx, 94, self.RULE_number)
    self._la = 0 # Token type
    try:
        self.state = 547
        self._errHandler.sync(self)
        la_ = self._interp.adaptivePredict(self._input,64,self._ctx)
        if la_ == 1:
            localctx = SqlSmallParser.DecimalLiteralContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 540
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.MINUS:
                self.state = 539
                self.match(SqlSmallParser.MINUS)


            self.state = 542
            self.match(SqlSmallParser.DECIMAL_VALUE)
            pass

        elif la_ == 2:
            localctx = SqlSmallParser.IntegerLiteralContext(self, localctx)
            self.enterOuterAlt(localctx, 2)
            self.state = 544
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.MINUS:
                self.state = 543
                self.match(SqlSmallParser.MINUS)


            self.state = 546
            self.match(SqlSmallParser.INTEGER_VALUE)
            pass


    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.orderClause"><code class="name flex">
<span>def <span class="ident">orderClause</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def orderClause(self):

    localctx = SqlSmallParser.OrderClauseContext(self, self._ctx, self.state)
    self.enterRule(localctx, 18, self.RULE_orderClause)
    self._la = 0 # Token type
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 176
        self.match(SqlSmallParser.ORDER)
        self.state = 177
        self.match(SqlSmallParser.BY)
        self.state = 178
        localctx._sortItem = self.sortItem()
        localctx.order.append(localctx._sortItem)
        self.state = 183
        self._errHandler.sync(self)
        _la = self._input.LA(1)
        while _la==SqlSmallParser.T__3:
            self.state = 179
            self.match(SqlSmallParser.T__3)
            self.state = 180
            localctx._sortItem = self.sortItem()
            localctx.order.append(localctx._sortItem)
            self.state = 185
            self._errHandler.sync(self)
            _la = self._input.LA(1)

    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.overClause"><code class="name flex">
<span>def <span class="ident">overClause</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def overClause(self):

    localctx = SqlSmallParser.OverClauseContext(self, self._ctx, self.state)
    self.enterRule(localctx, 78, self.RULE_overClause)
    self._la = 0 # Token type
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 489
        self.match(SqlSmallParser.OVER)
        self.state = 490
        self.match(SqlSmallParser.T__1)
        self.state = 494
        self._errHandler.sync(self)
        _la = self._input.LA(1)
        if _la==SqlSmallParser.PARTITION:
            self.state = 491
            self.match(SqlSmallParser.PARTITION)
            self.state = 492
            self.match(SqlSmallParser.BY)
            self.state = 493
            self.expression(0)


        self.state = 497
        self._errHandler.sync(self)
        _la = self._input.LA(1)
        if _la==SqlSmallParser.ORDER:
            self.state = 496
            self.orderClause()


        self.state = 499
        self.match(SqlSmallParser.T__2)
    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.powerFunction"><code class="name flex">
<span>def <span class="ident">powerFunction</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def powerFunction(self):

    localctx = SqlSmallParser.PowerFunctionContext(self, self._ctx, self.state)
    self.enterRule(localctx, 68, self.RULE_powerFunction)
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 474
        self.match(SqlSmallParser.POWER)
        self.state = 475
        self.match(SqlSmallParser.T__1)
        self.state = 476
        self.expression(0)
        self.state = 477
        self.match(SqlSmallParser.T__3)
        self.state = 478
        self.number()
        self.state = 479
        self.match(SqlSmallParser.T__2)
    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.predicate"><code class="name flex">
<span>def <span class="ident">predicate</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def predicate(self):

    localctx = SqlSmallParser.PredicateContext(self, self._ctx, self.state)
    self.enterRule(localctx, 54, self.RULE_predicate)
    self._la = 0 # Token type
    try:
        self.state = 414
        self._errHandler.sync(self)
        la_ = self._interp.adaptivePredict(self._input,50,self._ctx)
        if la_ == 1:
            localctx = SqlSmallParser.BetweenConditionContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 387
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.NOT:
                self.state = 386
                self.match(SqlSmallParser.NOT)


            self.state = 389
            localctx.kind = self.match(SqlSmallParser.BETWEEN)
            self.state = 390
            localctx.lower = self.expression(0)
            self.state = 391
            self.match(SqlSmallParser.AND)
            self.state = 392
            localctx.upper = self.expression(0)
            pass

        elif la_ == 2:
            localctx = SqlSmallParser.InConditionContext(self, localctx)
            self.enterOuterAlt(localctx, 2)
            self.state = 395
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.NOT:
                self.state = 394
                self.match(SqlSmallParser.NOT)


            self.state = 397
            localctx.kind = self.match(SqlSmallParser.IN)
            self.state = 398
            self.match(SqlSmallParser.T__1)
            self.state = 399
            self.expression(0)
            self.state = 404
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==SqlSmallParser.T__3:
                self.state = 400
                self.match(SqlSmallParser.T__3)
                self.state = 401
                self.expression(0)
                self.state = 406
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 407
            self.match(SqlSmallParser.T__2)
            pass

        elif la_ == 3:
            localctx = SqlSmallParser.IsConditionContext(self, localctx)
            self.enterOuterAlt(localctx, 3)
            self.state = 409
            self.match(SqlSmallParser.IS)
            self.state = 411
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.NOT:
                self.state = 410
                self.match(SqlSmallParser.NOT)


            self.state = 413
            localctx.kind = self._input.LT(1)
            _la = self._input.LA(1)
            if not(((((_la - 33)) &amp; ~0x3f) == 0 and ((1 &lt;&lt; (_la - 33)) &amp; ((1 &lt;&lt; (SqlSmallParser.FALSE - 33)) | (1 &lt;&lt; (SqlSmallParser.NULL - 33)) | (1 &lt;&lt; (SqlSmallParser.TRUE - 33)))) != 0)):
                localctx.kind = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            pass


    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.qualifiedColumnName"><code class="name flex">
<span>def <span class="ident">qualifiedColumnName</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def qualifiedColumnName(self):

    localctx = SqlSmallParser.QualifiedColumnNameContext(self, self._ctx, self.state)
    self.enterRule(localctx, 90, self.RULE_qualifiedColumnName)
    self._la = 0 # Token type
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 535
        _la = self._input.LA(1)
        if not(_la==SqlSmallParser.QN2 or _la==SqlSmallParser.IDENT):
            self._errHandler.recoverInline(self)
        else:
            self._errHandler.reportMatch(self)
            self.consume()
    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.qualifiedTableName"><code class="name flex">
<span>def <span class="ident">qualifiedTableName</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def qualifiedTableName(self):

    localctx = SqlSmallParser.QualifiedTableNameContext(self, self._ctx, self.state)
    self.enterRule(localctx, 88, self.RULE_qualifiedTableName)
    self._la = 0 # Token type
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 533
        _la = self._input.LA(1)
        if not(((((_la - 115)) &amp; ~0x3f) == 0 and ((1 &lt;&lt; (_la - 115)) &amp; ((1 &lt;&lt; (SqlSmallParser.QN2 - 115)) | (1 &lt;&lt; (SqlSmallParser.QN3 - 115)) | (1 &lt;&lt; (SqlSmallParser.IDENT - 115)))) != 0)):
            self._errHandler.recoverInline(self)
        else:
            self._errHandler.reportMatch(self)
            self.consume()
    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.query"><code class="name flex">
<span>def <span class="ident">query</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def query(self):

    localctx = SqlSmallParser.QueryContext(self, self._ctx, self.state)
    self.enterRule(localctx, 2, self.RULE_query)
    self._la = 0 # Token type
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 109
        self.selectClause()
        self.state = 110
        self.fromClause()
        self.state = 112
        self._errHandler.sync(self)
        _la = self._input.LA(1)
        if _la==SqlSmallParser.WHERE:
            self.state = 111
            self.whereClause()


        self.state = 115
        self._errHandler.sync(self)
        _la = self._input.LA(1)
        if _la==SqlSmallParser.GROUP:
            self.state = 114
            self.aggregationClause()


        self.state = 118
        self._errHandler.sync(self)
        _la = self._input.LA(1)
        if _la==SqlSmallParser.HAVING:
            self.state = 117
            self.havingClause()


        self.state = 121
        self._errHandler.sync(self)
        _la = self._input.LA(1)
        if _la==SqlSmallParser.ORDER:
            self.state = 120
            self.orderClause()


        self.state = 124
        self._errHandler.sync(self)
        _la = self._input.LA(1)
        if _la==SqlSmallParser.LIMIT:
            self.state = 123
            self.limitClause()


    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.rankingFunction"><code class="name flex">
<span>def <span class="ident">rankingFunction</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rankingFunction(self):

    localctx = SqlSmallParser.RankingFunctionContext(self, self._ctx, self.state)
    self.enterRule(localctx, 64, self.RULE_rankingFunction)
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 462
        localctx.function = self.rankingFunctionName()
        self.state = 463
        self.match(SqlSmallParser.T__1)
        self.state = 464
        self.match(SqlSmallParser.T__2)
        self.state = 465
        self.overClause()
    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.rankingFunctionName"><code class="name flex">
<span>def <span class="ident">rankingFunctionName</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rankingFunctionName(self):

    localctx = SqlSmallParser.RankingFunctionNameContext(self, self._ctx, self.state)
    self.enterRule(localctx, 70, self.RULE_rankingFunctionName)
    self._la = 0 # Token type
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 481
        _la = self._input.LA(1)
        if not(((((_la - 26)) &amp; ~0x3f) == 0 and ((1 &lt;&lt; (_la - 26)) &amp; ((1 &lt;&lt; (SqlSmallParser.DENSE_RANK - 26)) | (1 &lt;&lt; (SqlSmallParser.RANK - 26)) | (1 &lt;&lt; (SqlSmallParser.ROW_NUMBER - 26)))) != 0)):
            self._errHandler.recoverInline(self)
        else:
            self._errHandler.reportMatch(self)
            self.consume()
    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.relation"><code class="name flex">
<span>def <span class="ident">relation</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def relation(self):

    localctx = SqlSmallParser.RelationContext(self, self._ctx, self.state)
    self.enterRule(localctx, 34, self.RULE_relation)
    self._la = 0 # Token type
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 249
        self.relationPrimary()
        self.state = 253
        self._errHandler.sync(self)
        _la = self._input.LA(1)
        while (((_la) &amp; ~0x3f) == 0 and ((1 &lt;&lt; _la) &amp; ((1 &lt;&lt; SqlSmallParser.ANTI) | (1 &lt;&lt; SqlSmallParser.CROSS) | (1 &lt;&lt; SqlSmallParser.FULL) | (1 &lt;&lt; SqlSmallParser.INNER) | (1 &lt;&lt; SqlSmallParser.JOIN) | (1 &lt;&lt; SqlSmallParser.LEFT))) != 0) or _la==SqlSmallParser.RIGHT or _la==SqlSmallParser.SEMI:
            self.state = 250
            self.joinRelation()
            self.state = 255
            self._errHandler.sync(self)
            _la = self._input.LA(1)

    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.relationPrimary"><code class="name flex">
<span>def <span class="ident">relationPrimary</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def relationPrimary(self):

    localctx = SqlSmallParser.RelationPrimaryContext(self, self._ctx, self.state)
    self.enterRule(localctx, 36, self.RULE_relationPrimary)
    self._la = 0 # Token type
    try:
        self.state = 273
        self._errHandler.sync(self)
        la_ = self._interp.adaptivePredict(self._input,31,self._ctx)
        if la_ == 1:
            localctx = SqlSmallParser.TableContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 256
            self.qualifiedTableName()
            self.state = 259
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.AS:
                self.state = 257
                self.match(SqlSmallParser.AS)
                self.state = 258
                localctx.alias = self.identifier()


            pass

        elif la_ == 2:
            localctx = SqlSmallParser.AliasedQueryContext(self, localctx)
            self.enterOuterAlt(localctx, 2)
            self.state = 261
            self.subquery()
            self.state = 264
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.AS:
                self.state = 262
                self.match(SqlSmallParser.AS)
                self.state = 263
                localctx.alias = self.identifier()


            pass

        elif la_ == 3:
            localctx = SqlSmallParser.AliasedRelationContext(self, localctx)
            self.enterOuterAlt(localctx, 3)
            self.state = 266
            self.match(SqlSmallParser.T__1)
            self.state = 267
            self.relation()
            self.state = 268
            self.match(SqlSmallParser.T__2)
            self.state = 271
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==SqlSmallParser.AS:
                self.state = 269
                self.match(SqlSmallParser.AS)
                self.state = 270
                localctx.alias = self.identifier()


            pass


    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.roundFunction"><code class="name flex">
<span>def <span class="ident">roundFunction</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def roundFunction(self):

    localctx = SqlSmallParser.RoundFunctionContext(self, self._ctx, self.state)
    self.enterRule(localctx, 66, self.RULE_roundFunction)
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 467
        self.match(SqlSmallParser.ROUND)
        self.state = 468
        self.match(SqlSmallParser.T__1)
        self.state = 469
        self.expression(0)
        self.state = 470
        self.match(SqlSmallParser.T__3)
        self.state = 471
        localctx.digits = self.number()
        self.state = 472
        self.match(SqlSmallParser.T__2)
    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.selectClause"><code class="name flex">
<span>def <span class="ident">selectClause</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def selectClause(self):

    localctx = SqlSmallParser.SelectClauseContext(self, self._ctx, self.state)
    self.enterRule(localctx, 8, self.RULE_selectClause)
    self._la = 0 # Token type
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 145
        self.match(SqlSmallParser.SELECT)
        self.state = 147
        self._errHandler.sync(self)
        _la = self._input.LA(1)
        if _la==SqlSmallParser.ALL or _la==SqlSmallParser.DISTINCT or _la==SqlSmallParser.TOP:
            self.state = 146
            self.setQuantifier()


        self.state = 149
        self.namedExpressionSeq()
    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.sempred"><code class="name flex">
<span>def <span class="ident">sempred</span></span>(<span>self, localctx, ruleIndex, predIndex)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
    if self._predicates == None:
        self._predicates = dict()
    self._predicates[23] = self.expression_sempred
    self._predicates[26] = self.booleanExpression_sempred
    pred = self._predicates.get(ruleIndex, None)
    if pred is None:
        raise Exception(&#34;No predicate with index:&#34; + str(ruleIndex))
    else:
        return pred(localctx, predIndex)</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.setQuantifier"><code class="name flex">
<span>def <span class="ident">setQuantifier</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setQuantifier(self):

    localctx = SqlSmallParser.SetQuantifierContext(self, self._ctx, self.state)
    self.enterRule(localctx, 32, self.RULE_setQuantifier)
    try:
        self.state = 247
        self._errHandler.sync(self)
        token = self._input.LA(1)
        if token in [SqlSmallParser.DISTINCT]:
            self.enterOuterAlt(localctx, 1)
            self.state = 244
            self.match(SqlSmallParser.DISTINCT)
            pass
        elif token in [SqlSmallParser.ALL]:
            self.enterOuterAlt(localctx, 2)
            self.state = 245
            self.match(SqlSmallParser.ALL)
            pass
        elif token in [SqlSmallParser.TOP]:
            self.enterOuterAlt(localctx, 3)
            self.state = 246
            self.topClause()
            pass
        else:
            raise NoViableAltException(self)

    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.sortItem"><code class="name flex">
<span>def <span class="ident">sortItem</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sortItem(self):

    localctx = SqlSmallParser.SortItemContext(self, self._ctx, self.state)
    self.enterRule(localctx, 30, self.RULE_sortItem)
    self._la = 0 # Token type
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 240
        self.expression(0)
        self.state = 242
        self._errHandler.sync(self)
        _la = self._input.LA(1)
        if _la==SqlSmallParser.ASC or _la==SqlSmallParser.DESC:
            self.state = 241
            localctx.ordering = self._input.LT(1)
            _la = self._input.LA(1)
            if not(_la==SqlSmallParser.ASC or _la==SqlSmallParser.DESC):
                localctx.ordering = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()


    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.subquery"><code class="name flex">
<span>def <span class="ident">subquery</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def subquery(self):

    localctx = SqlSmallParser.SubqueryContext(self, self._ctx, self.state)
    self.enterRule(localctx, 4, self.RULE_subquery)
    self._la = 0 # Token type
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 126
        self.match(SqlSmallParser.T__1)
        self.state = 127
        self.selectClause()
        self.state = 128
        self.fromClause()
        self.state = 130
        self._errHandler.sync(self)
        _la = self._input.LA(1)
        if _la==SqlSmallParser.WHERE:
            self.state = 129
            self.whereClause()


        self.state = 133
        self._errHandler.sync(self)
        _la = self._input.LA(1)
        if _la==SqlSmallParser.GROUP:
            self.state = 132
            self.aggregationClause()


        self.state = 136
        self._errHandler.sync(self)
        _la = self._input.LA(1)
        if _la==SqlSmallParser.HAVING:
            self.state = 135
            self.havingClause()


        self.state = 139
        self._errHandler.sync(self)
        _la = self._input.LA(1)
        if _la==SqlSmallParser.ORDER:
            self.state = 138
            self.orderClause()


        self.state = 141
        self.match(SqlSmallParser.T__2)
    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.topClause"><code class="name flex">
<span>def <span class="ident">topClause</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def topClause(self):

    localctx = SqlSmallParser.TopClauseContext(self, self._ctx, self.state)
    self.enterRule(localctx, 22, self.RULE_topClause)
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 189
        self.match(SqlSmallParser.TOP)
        self.state = 190
        localctx.n = self.number()
    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.whenExpression"><code class="name flex">
<span>def <span class="ident">whenExpression</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def whenExpression(self):

    localctx = SqlSmallParser.WhenExpressionContext(self, self._ctx, self.state)
    self.enterRule(localctx, 44, self.RULE_whenExpression)
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 303
        self.match(SqlSmallParser.WHEN)
        self.state = 306
        self._errHandler.sync(self)
        la_ = self._interp.adaptivePredict(self._input,37,self._ctx)
        if la_ == 1:
            self.state = 304
            localctx.baseBoolExpr = self.booleanExpression(0)
            pass

        elif la_ == 2:
            self.state = 305
            localctx.baseWhenExpr = self.expression(0)
            pass


        self.state = 308
        self.match(SqlSmallParser.THEN)
        self.state = 309
        localctx.thenExpr = self.expression(0)
    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
<dt id="burdock.sql.parser.SqlSmallParser.SqlSmallParser.whereClause"><code class="name flex">
<span>def <span class="ident">whereClause</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def whereClause(self):

    localctx = SqlSmallParser.WhereClauseContext(self, self._ctx, self.state)
    self.enterRule(localctx, 12, self.RULE_whereClause)
    try:
        self.enterOuterAlt(localctx, 1)
        self.state = 160
        self.match(SqlSmallParser.WHERE)
        self.state = 161
        self.booleanExpression(0)
    except RecognitionException as re:
        localctx.exception = re
        self._errHandler.reportError(self, re)
        self._errHandler.recover(self, re)
    finally:
        self.exitRule()
    return localctx</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="burdock.sql.parser" href="index.html">burdock.sql.parser</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="burdock.sql.parser.SqlSmallParser.serializedATN" href="#burdock.sql.parser.SqlSmallParser.serializedATN">serializedATN</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser">SqlSmallParser</a></code></h4>
<ul class="">
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ABS" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.ABS">ABS</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ACOS" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.ACOS">ACOS</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ALL" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.ALL">ALL</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.AMPERSAND" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.AMPERSAND">AMPERSAND</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.AND" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.AND">AND</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ANTI" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.ANTI">ANTI</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.AS" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.AS">AS</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ASC" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.ASC">ASC</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ASIN" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.ASIN">ASIN</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ASTERISK" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.ASTERISK">ASTERISK</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ATAN" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.ATAN">ATAN</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.AVG" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.AVG">AVG</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.AddContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.AddContext">AddContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.AggFuncContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.AggFuncContext">AggFuncContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.AggregateFunctionNameContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.AggregateFunctionNameContext">AggregateFunctionNameContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.AggregationClauseContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.AggregationClauseContext">AggregationClauseContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.AliasedQueryContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.AliasedQueryContext">AliasedQueryContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.AliasedRelationContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.AliasedRelationContext">AliasedRelationContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.AliasedSubqueryContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.AliasedSubqueryContext">AliasedSubqueryContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.AliasedTableNameContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.AliasedTableNameContext">AliasedTableNameContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.AliasedTableOrSubquerySeqContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.AliasedTableOrSubquerySeqContext">AliasedTableOrSubquerySeqContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.AliasedTableSeqContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.AliasedTableSeqContext">AliasedTableSeqContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.AllExprContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.AllExprContext">AllExprContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.AllExpressionContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.AllExpressionContext">AllExpressionContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.BETWEEN" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.BETWEEN">BETWEEN</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.BRACKETED_COMMENT" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.BRACKETED_COMMENT">BRACKETED_COMMENT</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.BRACKETED_EMPTY_COMMENT" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.BRACKETED_EMPTY_COMMENT">BRACKETED_EMPTY_COMMENT</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.BY" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.BY">BY</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.BareFuncContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.BareFuncContext">BareFuncContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.BareFunctionContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.BareFunctionContext">BareFunctionContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.BareFunctionNameContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.BareFunctionNameContext">BareFunctionNameContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.BatchContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.BatchContext">BatchContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.BetweenConditionContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.BetweenConditionContext">BetweenConditionContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.BooleanExpressionContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.BooleanExpressionContext">BooleanExpressionContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.BooleanJoinContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.BooleanJoinContext">BooleanJoinContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.BooleanValueContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.BooleanValueContext">BooleanValueContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.CASE" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.CASE">CASE</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.CEILING" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.CEILING">CEILING</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.CHOOSE" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.CHOOSE">CHOOSE</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.CONCAT_PIPE" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.CONCAT_PIPE">CONCAT_PIPE</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.COS" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.COS">COS</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.COT" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.COT">COT</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.COUNT" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.COUNT">COUNT</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.CROSS" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.CROSS">CROSS</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.CaseExprContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.CaseExprContext">CaseExprContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.CaseExpressionContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.CaseExpressionContext">CaseExpressionContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ChooseFuncContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.ChooseFuncContext">ChooseFuncContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ColumnNameContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.ColumnNameContext">ColumnNameContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ComparisonContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.ComparisonContext">ComparisonContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ComparisonOperatorContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.ComparisonOperatorContext">ComparisonOperatorContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ConjunctionContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.ConjunctionContext">ConjunctionContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.DECIMAL_VALUE" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.DECIMAL_VALUE">DECIMAL_VALUE</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.DEGREES" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.DEGREES">DEGREES</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.DENSE_RANK" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.DENSE_RANK">DENSE_RANK</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.DESC" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.DESC">DESC</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.DISTINCT" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.DISTINCT">DISTINCT</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.DIV" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.DIV">DIV</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.DecimalLiteralContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.DecimalLiteralContext">DecimalLiteralContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.DisjunctionContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.DisjunctionContext">DisjunctionContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.DivideContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.DivideContext">DivideContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ELSE" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.ELSE">ELSE</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.END" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.END">END</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.EOF" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.EOF">EOF</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.EQ" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.EQ">EQ</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ESCAPED_IDENTIFIER" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.ESCAPED_IDENTIFIER">ESCAPED_IDENTIFIER</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.EXP" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.EXP">EXP</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ExpressionContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.ExpressionContext">ExpressionContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ExpressionSubqueryContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.ExpressionSubqueryContext">ExpressionSubqueryContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.FALSE" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.FALSE">FALSE</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.FLOOR" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.FLOOR">FLOOR</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.FROM" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.FROM">FROM</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.FULL" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.FULL">FULL</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.FalseLiteralContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.FalseLiteralContext">FalseLiteralContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.FromClauseContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.FromClauseContext">FromClauseContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.FunctionExprContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.FunctionExprContext">FunctionExprContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.FunctionExpressionContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.FunctionExpressionContext">FunctionExpressionContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.GROUP" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.GROUP">GROUP</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.GT" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.GT">GT</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.GTE" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.GTE">GTE</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.HAT" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.HAT">HAT</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.HAVING" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.HAVING">HAVING</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.HavingClauseContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.HavingClauseContext">HavingClauseContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.IDENT" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.IDENT">IDENT</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.IDENTIFIER" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.IDENTIFIER">IDENTIFIER</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.IF" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.IF">IF</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.IIF" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.IIF">IIF</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.IN" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.IN">IN</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.INNER" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.INNER">INNER</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.INTEGER_VALUE" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.INTEGER_VALUE">INTEGER_VALUE</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.INTERSECT" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.INTERSECT">INTERSECT</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.IS" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.IS">IS</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.IdentifierContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.IdentifierContext">IdentifierContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.IifFuncContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.IifFuncContext">IifFuncContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.InConditionContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.InConditionContext">InConditionContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.IntegerLiteralContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.IntegerLiteralContext">IntegerLiteralContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.IsConditionContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.IsConditionContext">IsConditionContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.JOIN" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.JOIN">JOIN</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.JoinCriteriaContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.JoinCriteriaContext">JoinCriteriaContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.JoinRelationContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.JoinRelationContext">JoinRelationContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.JoinTypeContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.JoinTypeContext">JoinTypeContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.LEFT" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.LEFT">LEFT</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.LETTER" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.LETTER">LETTER</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.LIMIT" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.LIMIT">LIMIT</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.LOG" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.LOG">LOG</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.LOG10" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.LOG10">LOG10</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.LT" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.LT">LT</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.LTE" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.LTE">LTE</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.LimitClauseContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.LimitClauseContext">LimitClauseContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.LiteralContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.LiteralContext">LiteralContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.LiteralExprContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.LiteralExprContext">LiteralExprContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.LogicalNotContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.LogicalNotContext">LogicalNotContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.MAX" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.MAX">MAX</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.MIN" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.MIN">MIN</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.MINUS" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.MINUS">MINUS</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.MathFuncContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.MathFuncContext">MathFuncContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.MathFunctionNameContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.MathFunctionNameContext">MathFunctionNameContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ModuloContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.ModuloContext">ModuloContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.MultiplyContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.MultiplyContext">MultiplyContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.NEQ" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.NEQ">NEQ</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.NEQJ" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.NEQJ">NEQJ</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.NEWID" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.NEWID">NEWID</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.NOT" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.NOT">NOT</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.NSEQ" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.NSEQ">NSEQ</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.NULL" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.NULL">NULL</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.NUMERIC" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.NUMERIC">NUMERIC</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.NamedExpressionContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.NamedExpressionContext">NamedExpressionContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.NamedExpressionSeqContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.NamedExpressionSeqContext">NamedExpressionSeqContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.NestedBooleanContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.NestedBooleanContext">NestedBooleanContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.NestedExprContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.NestedExprContext">NestedExprContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.NullLiteralContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.NullLiteralContext">NullLiteralContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.NumberContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.NumberContext">NumberContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.NumberLiteralContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.NumberLiteralContext">NumberLiteralContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ON" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.ON">ON</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.OR" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.OR">OR</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ORDER" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.ORDER">ORDER</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.OUTER" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.OUTER">OUTER</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.OVER" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.OVER">OVER</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.OrderClauseContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.OrderClauseContext">OrderClauseContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.OverClauseContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.OverClauseContext">OverClauseContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.PARTITION" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.PARTITION">PARTITION</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.PERCENT" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.PERCENT">PERCENT</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.PERCENTILE_CONT" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.PERCENTILE_CONT">PERCENTILE_CONT</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.PERCENTILE_DISC" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.PERCENTILE_DISC">PERCENTILE_DISC</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.PI" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.PI">PI</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.PIPE" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.PIPE">PIPE</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.PLUS" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.PLUS">PLUS</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.POWER" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.POWER">POWER</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.PowerFuncContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.PowerFuncContext">PowerFuncContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.PowerFunctionContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.PowerFunctionContext">PowerFunctionContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.PredicateContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.PredicateContext">PredicateContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.PredicatedContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.PredicatedContext">PredicatedContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.QN2" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.QN2">QN2</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.QN3" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.QN3">QN3</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.QualifiedColumnNameContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.QualifiedColumnNameContext">QualifiedColumnNameContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.QualifiedTableNameContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.QualifiedTableNameContext">QualifiedTableNameContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.QueryContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.QueryContext">QueryContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RAND" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RAND">RAND</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RANDOM" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RANDOM">RANDOM</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RANK" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RANK">RANK</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RIGHT" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RIGHT">RIGHT</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ROUND" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.ROUND">ROUND</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ROWNUM" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.ROWNUM">ROWNUM</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ROW_NUMBER" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.ROW_NUMBER">ROW_NUMBER</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_aggregateFunctionName" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_aggregateFunctionName">RULE_aggregateFunctionName</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_aggregationClause" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_aggregationClause">RULE_aggregationClause</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_aliasedSubquery" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_aliasedSubquery">RULE_aliasedSubquery</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_aliasedTableName" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_aliasedTableName">RULE_aliasedTableName</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_aliasedTableOrSubquerySeq" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_aliasedTableOrSubquerySeq">RULE_aliasedTableOrSubquerySeq</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_aliasedTableSeq" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_aliasedTableSeq">RULE_aliasedTableSeq</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_allExpression" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_allExpression">RULE_allExpression</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_bareFunction" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_bareFunction">RULE_bareFunction</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_bareFunctionName" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_bareFunctionName">RULE_bareFunctionName</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_batch" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_batch">RULE_batch</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_booleanExpression" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_booleanExpression">RULE_booleanExpression</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_booleanValue" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_booleanValue">RULE_booleanValue</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_caseExpression" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_caseExpression">RULE_caseExpression</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_comparisonOperator" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_comparisonOperator">RULE_comparisonOperator</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_expression" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_expression">RULE_expression</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_expressionSubquery" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_expressionSubquery">RULE_expressionSubquery</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_fromClause" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_fromClause">RULE_fromClause</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_functionExpression" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_functionExpression">RULE_functionExpression</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_havingClause" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_havingClause">RULE_havingClause</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_identifier" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_identifier">RULE_identifier</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_joinCriteria" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_joinCriteria">RULE_joinCriteria</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_joinRelation" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_joinRelation">RULE_joinRelation</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_joinType" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_joinType">RULE_joinType</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_limitClause" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_limitClause">RULE_limitClause</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_literal" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_literal">RULE_literal</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_mathFunctionName" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_mathFunctionName">RULE_mathFunctionName</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_namedExpression" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_namedExpression">RULE_namedExpression</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_namedExpressionSeq" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_namedExpressionSeq">RULE_namedExpressionSeq</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_number" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_number">RULE_number</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_orderClause" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_orderClause">RULE_orderClause</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_overClause" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_overClause">RULE_overClause</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_powerFunction" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_powerFunction">RULE_powerFunction</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_predicate" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_predicate">RULE_predicate</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_qualifiedColumnName" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_qualifiedColumnName">RULE_qualifiedColumnName</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_qualifiedTableName" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_qualifiedTableName">RULE_qualifiedTableName</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_query" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_query">RULE_query</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_rankingFunction" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_rankingFunction">RULE_rankingFunction</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_rankingFunctionName" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_rankingFunctionName">RULE_rankingFunctionName</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_relation" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_relation">RULE_relation</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_relationPrimary" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_relationPrimary">RULE_relationPrimary</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_roundFunction" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_roundFunction">RULE_roundFunction</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_selectClause" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_selectClause">RULE_selectClause</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_setQuantifier" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_setQuantifier">RULE_setQuantifier</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_sortItem" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_sortItem">RULE_sortItem</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_subquery" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_subquery">RULE_subquery</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_topClause" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_topClause">RULE_topClause</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_whenExpression" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_whenExpression">RULE_whenExpression</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_whereClause" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RULE_whereClause">RULE_whereClause</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RankFunctionContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RankFunctionContext">RankFunctionContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RankingFunctionContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RankingFunctionContext">RankingFunctionContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RankingFunctionNameContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RankingFunctionNameContext">RankingFunctionNameContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RelationContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RelationContext">RelationContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RelationPrimaryContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RelationPrimaryContext">RelationPrimaryContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RoundFuncContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RoundFuncContext">RoundFuncContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.RoundFunctionContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.RoundFunctionContext">RoundFunctionContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SELECT" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.SELECT">SELECT</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SEMI" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.SEMI">SEMI</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SIGN" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.SIGN">SIGN</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SIMPLE_COMMENT" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.SIMPLE_COMMENT">SIMPLE_COMMENT</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SIN" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.SIN">SIN</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SLASH" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.SLASH">SLASH</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SORT" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.SORT">SORT</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SPACE" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.SPACE">SPACE</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SQL" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.SQL">SQL</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SQRT" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.SQRT">SQRT</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SQUARE" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.SQUARE">SQUARE</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.STD" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.STD">STD</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.STDDEV" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.STDDEV">STDDEV</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.STRING" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.STRING">STRING</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SUM" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.SUM">SUM</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SelectClauseContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.SelectClauseContext">SelectClauseContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SetQuantifierContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.SetQuantifierContext">SetQuantifierContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SortItemContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.SortItemContext">SortItemContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.StringLiteralContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.StringLiteralContext">StringLiteralContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SubqueryContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.SubqueryContext">SubqueryContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SubqueryExprContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.SubqueryExprContext">SubqueryExprContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.SubtractContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.SubtractContext">SubtractContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.TAN" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.TAN">TAN</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.THEN" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.THEN">THEN</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.TILDE" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.TILDE">TILDE</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.TOP" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.TOP">TOP</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.TRUE" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.TRUE">TRUE</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.T__0" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.T__0">T__0</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.T__1" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.T__1">T__1</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.T__2" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.T__2">T__2</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.T__3" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.T__3">T__3</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.T__4" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.T__4">T__4</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.TableContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.TableContext">TableContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.TopClauseContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.TopClauseContext">TopClauseContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.TrueLiteralContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.TrueLiteralContext">TrueLiteralContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.UNION" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.UNION">UNION</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.USING" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.USING">USING</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.UsingJoinContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.UsingJoinContext">UsingJoinContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.VAR" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.VAR">VAR</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.VARIANCE" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.VARIANCE">VARIANCE</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.WHEN" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.WHEN">WHEN</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.WHERE" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.WHERE">WHERE</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.WS" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.WS">WS</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.WhenExpressionContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.WhenExpressionContext">WhenExpressionContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.WhereClauseContext" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.WhereClauseContext">WhereClauseContext</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.aggregateFunctionName" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.aggregateFunctionName">aggregateFunctionName</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.aggregationClause" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.aggregationClause">aggregationClause</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.aliasedSubquery" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.aliasedSubquery">aliasedSubquery</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.aliasedTableName" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.aliasedTableName">aliasedTableName</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.aliasedTableOrSubquerySeq" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.aliasedTableOrSubquerySeq">aliasedTableOrSubquerySeq</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.aliasedTableSeq" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.aliasedTableSeq">aliasedTableSeq</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.allExpression" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.allExpression">allExpression</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.atn" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.atn">atn</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.bareFunction" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.bareFunction">bareFunction</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.bareFunctionName" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.bareFunctionName">bareFunctionName</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.batch" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.batch">batch</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.booleanExpression" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.booleanExpression">booleanExpression</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.booleanExpression_sempred" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.booleanExpression_sempred">booleanExpression_sempred</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.booleanValue" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.booleanValue">booleanValue</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.caseExpression" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.caseExpression">caseExpression</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.comparisonOperator" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.comparisonOperator">comparisonOperator</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.decisionsToDFA" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.decisionsToDFA">decisionsToDFA</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.expression" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.expression">expression</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.expressionSubquery" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.expressionSubquery">expressionSubquery</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.expression_sempred" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.expression_sempred">expression_sempred</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.fromClause" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.fromClause">fromClause</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.functionExpression" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.functionExpression">functionExpression</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.grammarFileName" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.grammarFileName">grammarFileName</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.havingClause" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.havingClause">havingClause</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.identifier" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.identifier">identifier</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.joinCriteria" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.joinCriteria">joinCriteria</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.joinRelation" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.joinRelation">joinRelation</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.joinType" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.joinType">joinType</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.limitClause" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.limitClause">limitClause</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.literal" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.literal">literal</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.literalNames" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.literalNames">literalNames</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.mathFunctionName" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.mathFunctionName">mathFunctionName</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.namedExpression" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.namedExpression">namedExpression</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.namedExpressionSeq" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.namedExpressionSeq">namedExpressionSeq</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.number" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.number">number</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.orderClause" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.orderClause">orderClause</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.overClause" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.overClause">overClause</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.powerFunction" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.powerFunction">powerFunction</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.predicate" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.predicate">predicate</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.qualifiedColumnName" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.qualifiedColumnName">qualifiedColumnName</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.qualifiedTableName" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.qualifiedTableName">qualifiedTableName</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.query" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.query">query</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.rankingFunction" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.rankingFunction">rankingFunction</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.rankingFunctionName" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.rankingFunctionName">rankingFunctionName</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.relation" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.relation">relation</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.relationPrimary" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.relationPrimary">relationPrimary</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.roundFunction" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.roundFunction">roundFunction</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.ruleNames" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.ruleNames">ruleNames</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.selectClause" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.selectClause">selectClause</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.sempred" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.sempred">sempred</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.setQuantifier" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.setQuantifier">setQuantifier</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.sharedContextCache" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.sharedContextCache">sharedContextCache</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.sortItem" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.sortItem">sortItem</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.subquery" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.subquery">subquery</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.symbolicNames" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.symbolicNames">symbolicNames</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.topClause" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.topClause">topClause</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.whenExpression" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.whenExpression">whenExpression</a></code></li>
<li><code><a title="burdock.sql.parser.SqlSmallParser.SqlSmallParser.whereClause" href="#burdock.sql.parser.SqlSmallParser.SqlSmallParser.whereClause">whereClause</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>