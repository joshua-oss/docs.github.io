<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.5" />
<title>burdock.sql.private_rewriter API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>burdock.sql.private_rewriter</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import random
import string

from .parse import QueryParser
from .ast import Validate

from .ast.validate import Validate
from .ast.ast import Select, From, Query, AliasedRelation, Where, Aggregate, Order
from .ast.ast import Literal, Column, TableColumn, AllColumns
from .ast.ast import NamedExpression, NestedExpression, Expression, Seq
from .ast.ast import AggFunction, MathFunction, ArithmeticExpression, BooleanCompare, GroupingExpression

&#34;&#34;&#34;
    Modifies parsed ASTs to augment with information needed
    to support differential privacy.  Uses a matching 
    object which contains metadata necessary for differential
    privacy, such as min/max, cardinality, and key columns.

    This routine is intended to be used prior to post-processing
    with random noise generation.

&#34;&#34;&#34;
class Rewriter:
    def __init__(self, metadata, options=None):
        self.options = RewriterOptions() if options is None else options
        self.metadata = metadata

    &#34;&#34;&#34;
        Takes an expression for a noisy mean and rewrites
        to a noisy sum and a noisy count
    &#34;&#34;&#34;
    def calculate_avg(self, exp, scope):
        expr = exp.expression
        quant = exp.quantifier

        sum_expr = self.push_sum_or_count(AggFunction(&#34;SUM&#34;, quant, expr), scope)
        count_expr = self.push_sum_or_count(AggFunction(&#34;COUNT&#34;, quant, expr), scope)

        new_exp = NestedExpression(ArithmeticExpression(sum_expr, &#34;/&#34;, count_expr))
        return new_exp

    &#34;&#34;&#34;
        Takes an expression for a noisy mean and rewrites
        to a noisy sum and a noisy count
    &#34;&#34;&#34;
    def calculate_variance(self, exp, scope):
        expr = exp.expression
        quant = exp.quantifier

        avg_of_square = self.calculate_avg(AggFunction(&#34;AVG&#34;, quant, ArithmeticExpression(expr, &#39;*&#39;, expr)), scope)
        avg = self.calculate_avg(AggFunction(&#34;AVG&#34;, quant, expr), scope)
        avg_squared = ArithmeticExpression(avg, &#39;*&#39;, avg)

        new_exp = ArithmeticExpression(avg_of_square, &#34;-&#34;, avg_squared)
        return new_exp

    &#34;&#34;&#34;
        Takes an expression for a noisy mean and rewrites
        to a noisy sum and a noisy count
    &#34;&#34;&#34;
    def calculate_stddev(self, exp, scope):
        expr = AggFunction(&#39;STD&#39;, exp.quantifier, exp.expression)
        var_expr = self.calculate_variance(expr, scope)

        new_exp = MathFunction(&#34;SQRT&#34;, var_expr)
        return new_exp

    &#34;&#34;&#34;
        Push a sum or count expression to child scope
        and convert to a sum
    &#34;&#34;&#34;
    def push_sum_or_count(self, exp, scope):
        new_name = scope.push_name(AggFunction(exp.name, exp.quantifier, exp.expression))

        new_exp = AggFunction(&#34;SUM&#34;, None, Column(new_name))
        return new_exp

    &#34;&#34;&#34;
        rewrite AVG, VAR, etc. and push all sum or count
        to child scope, preserving all other portions of
        expression
    &#34;&#34;&#34;
    def rewrite_outer_named_expression(self, ne, scope):
        name = ne.name
        exp = ne.expression
        if type(exp) is not AggFunction:
            outer_col_exps = exp.find_nodes(Column, AggFunction)
        else:
            outer_col_exps = []
        if type(exp) is Column:
            outer_col_exps += [exp]
        for outer_col_exp in outer_col_exps:
            new_name = scope.push_name(Column(outer_col_exp.name))
            outer_col_exp.name = new_name
        agg_exps = exp.find_nodes(AggFunction)
        if type(exp) is AggFunction:
            agg_exps = agg_exps + [exp]
        for agg_exp in agg_exps:
            child_agg_exps = agg_exp.find_nodes(AggFunction)
            if len(child_agg_exps) &gt; 0:
                raise ValueError(&#34;Cannot have nested aggregate functions: &#34; + str(agg_exp))
            agg_func = agg_exp.name
            if agg_func in [&#34;SUM&#34;, &#34;COUNT&#34;]:
                new_exp = self.push_sum_or_count(agg_exp, scope)
            elif agg_func == &#34;AVG&#34;:
                new_exp = self.calculate_avg(agg_exp, scope)
            elif agg_func in [&#34;VAR&#34;,&#34;VARIANCE&#34;]:
                new_exp = self.calculate_variance(agg_exp, scope)
            elif agg_func in [&#34;STD&#34;,&#34;STDDEV&#34;]:
                new_exp = self.calculate_stddev(agg_exp, scope)
            else:
                raise ValueError(&#34;We don&#39;t know how to rewrite aggregate function: &#34; + str(agg_exp))
            agg_exp.name = &#34;&#34;
            agg_exp.quantifier = None
            agg_exp.expression = new_exp
        return NamedExpression(name, exp)


    def query(self, query):
        query = QueryParser(self.metadata).query(str(query))
        Validate().validateQuery(query, self.metadata)

        child_scope = Scope()
        # we make sure aggregates are in select scope for subqueries
        if query.agg is not None:
            for ge in query.agg.groupingExpressions:
                child_scope.push_name(ge.expression)

        select = Seq([self.rewrite_outer_named_expression(ne, child_scope) for ne in query.select.namedExpressions])
        select = Select(None, select)

        subquery = Query(child_scope.select(), query.source, query.where, query.agg, query.having, None, None)
        subquery = self.exact_aggregates(subquery)
        subquery = [AliasedRelation(subquery, &#34;exact_aggregates&#34;)]

        q = Query(select, From(subquery), None, query.agg, None, query.order, query.limit)

        return QueryParser(self.metadata).query(str(q))

    def exact_aggregates(self, query):

        key_col = self.key_col(query)

        child_scope = Scope()

        keycount_expr = AggFunction(&#34;COUNT&#34;, &#34;DISTINCT&#34;, Column(key_col))
        child_scope.push_name(keycount_expr.expression)
        keycount = NamedExpression(&#34;keycount&#34;, keycount_expr) # need to either treat this as reserved or pass through to outer

        select = Seq([keycount] + [self.rewrite_outer_named_expression(ne, child_scope) for ne in query.select.namedExpressions])
        select = Select(None, select)

        subquery = Query(child_scope.select(), query.source, query.where, query.agg, query.having, None, None)
        if self.options.reservoir_sample:
            subquery = self.per_key_random(subquery)
            subquery = [AliasedRelation(subquery, &#34;per_key_random&#34;)]

            filtered = Where(BooleanCompare(Column(&#34;per_key_random.row_num&#34;), &#34;&lt;=&#34;, Literal(str(self.options.max_contrib), self.options.max_contrib)))
            return Query(select, From(subquery), filtered, query.agg, None, None, None)
        else:
            subquery = self.per_key_clamped(subquery)
            subquery = [AliasedRelation(subquery, &#34;per_key_all&#34;)]
            return Query(select, From(subquery), None, query.agg, None, None, None)

    def per_key_random(self, query):
        key_col = self.key_col(query)

        select = Seq([NamedExpression(None, AllColumns()), NamedExpression(&#34;row_num&#34;, Expression(&#34;ROW_NUMBER() OVER (PARTITION BY {0} ORDER BY random())&#34;.format(key_col)))])
        select = Select(None, select)

        subquery = self.per_key_clamped(query)
        subquery = [AliasedRelation(subquery, &#34;per_key_clamped&#34;)]

        return Query(select, From(subquery), None, None, None, None, None)


    def per_key_clamped(self, query):

        key_col = self.key_col(query)

        child_scope = Scope()

        keygroup = [GroupingExpression(Column(key_col))] + (query.agg.groupingExpressions.seq if query.agg is not None else [])
        new_agg = Aggregate(Seq(keygroup))

        relations = query.source.relations

        select = Seq([self.clampExpression(ne, relations, child_scope, self.options.clamp_columns) for ne in query.select.namedExpressions])
        select = Select(None, select)
        subquery = Query(child_scope.select(), query.source, query.where, None, None, None, None)

        if self.options.clamp_columns:
            subquery = [AliasedRelation(subquery, &#34;clamped&#34;)]
        else:
            subquery = [AliasedRelation(subquery, &#34;not_clamped&#34;)]

        return Query(select, From(subquery), None, new_agg, None, None, None)


    &#34;&#34;&#34;
        Lookup the expression referenced in each named expression and
        write a clamped select for it, using the schema
    &#34;&#34;&#34;
    def clampExpression(self, ne, relations, scope, do_clamp=True):
        exp = ne.expression
        cols = exp.find_nodes(Column)
        if type(exp) is Column:
            cols += [exp]
        for col in cols:
            colname = col.name
            minval = None
            maxval = None
            sym = col.symbol(relations)
            if do_clamp and sym.valtype in [&#34;float&#34;, &#34;int&#34;] and not sym.unbounded:
                minval = sym.minval
                maxval = sym.maxval
                if minval is None or sym.is_key:
                    cexpr = Column(colname)
                    ce_name = scope.push_name(cexpr, str(colname))
                else:
                    clamped_string = &#34;CASE WHEN {0} &lt; {1} THEN {1} WHEN {0} &gt; {2} THEN {2} ELSE {0} END&#34;.format(str(colname), minval, maxval)
                    cexpr = Expression(clamped_string)
                    ce_name = scope.push_name(cexpr, str(colname))
            else:
                cexpr = Column(colname)
                ce_name = scope.push_name(cexpr, str(colname))
            col.name = ce_name
        return ne

    &#34;&#34;&#34;
        Return the key column, given a from clause
    &#34;&#34;&#34;
    def key_col(self, query):
        rsyms = query.source.relations[0].all_symbols(AllColumns())
        tcsyms = [r for name, r in rsyms if type(r) is TableColumn]
        keys = [str(tc) for tc in tcsyms if tc.is_key]
        if len(keys) &gt; 1:
            raise ValueError(&#34;We only know how to handle tables with one key: &#34; + str(keys))
        elif len(keys) &lt; 1:
            raise ValueError(&#34;No key column available in query relations&#34;)

        kp = keys[0].split(&#34;.&#34;)
        return kp[len(kp) - 1]



&#34;&#34;&#34;
    A name scope for a select query
&#34;&#34;&#34;
class Scope:
    def __init__(self):
        self.expressions = {}

    def select(self, quantifier=None):
        return Select(quantifier, [NamedExpression(name, self.expressions[name]) for name in self.expressions.keys()])

    &#34;&#34;&#34;
        Returns a named expression from an expression, using
        an existing name if already provided in this scope,
        or generating a new name and adding to the names
        dictionary if the expression does not exist in scope.
    &#34;&#34;&#34;
    def push_name(self, expression, proposed=None):
        # see if the proposed name is taken
        if proposed is not None:
            if proposed in self.expressions:
                if self.expressions[proposed] == expression:
                    return proposed
                else:
                    pass
            else:
                self.expressions[proposed] = expression
                return proposed

        # see if the expression has been used 
        names = [name for name in self.expressions.keys() if self.expressions[name] == expression]
        if len(names) &gt; 0:
            return names[0]

        # see if the expression has been used under the symbol name
        proposed = expression.symbol_name()
        if proposed in self.expressions:
            if self.expressions[proposed] == expression:
                return proposed
            else:
                pass
        else:
            self.expressions[proposed] = expression
            return proposed

        # Expression hasn&#39;t been used, but name is taken. Generate random.
        while not proposed in self.expressions:
            proposed = &#39;&#39;.join(random.choice(string.ascii_letters) for i in range(7))

        self.expressions[proposed] = expression
        return proposed

class RewriterOptions:
    &#34;&#34;&#34;Options that modify rewriter behavior&#34;&#34;&#34;
    def __init__(self, row_privacy=False, reservoir_sample=True, clamp_columns=True, max_contrib=1):
        &#34;&#34;&#34;Initialize options before running the rewriter

        :param row_privacy: boolean, True if each row is a separate individual
        :param reservoir_sample: boolean, set to False if the data collection will never have more than max_contrib record per individual
        :param clamp_columns: boolean, set to False to allow values that exceed lower and higher limit specified in metadata.  May impact privacy
        :param max_contrib: int, set to maximum number of individuals that can appear in any query result.  Affects sensitivity
        &#34;&#34;&#34;
        self.row_privacy = row_privacy
        self.reservoir_sample = reservoir_sample
        self.clamp_columns = clamp_columns
        self.max_contrib = max_contrib</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="burdock.sql.private_rewriter.Rewriter"><code class="flex name class">
<span>class <span class="ident">Rewriter</span></span>
<span>(</span><span>metadata, options=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Rewriter:
    def __init__(self, metadata, options=None):
        self.options = RewriterOptions() if options is None else options
        self.metadata = metadata

    &#34;&#34;&#34;
        Takes an expression for a noisy mean and rewrites
        to a noisy sum and a noisy count
    &#34;&#34;&#34;
    def calculate_avg(self, exp, scope):
        expr = exp.expression
        quant = exp.quantifier

        sum_expr = self.push_sum_or_count(AggFunction(&#34;SUM&#34;, quant, expr), scope)
        count_expr = self.push_sum_or_count(AggFunction(&#34;COUNT&#34;, quant, expr), scope)

        new_exp = NestedExpression(ArithmeticExpression(sum_expr, &#34;/&#34;, count_expr))
        return new_exp

    &#34;&#34;&#34;
        Takes an expression for a noisy mean and rewrites
        to a noisy sum and a noisy count
    &#34;&#34;&#34;
    def calculate_variance(self, exp, scope):
        expr = exp.expression
        quant = exp.quantifier

        avg_of_square = self.calculate_avg(AggFunction(&#34;AVG&#34;, quant, ArithmeticExpression(expr, &#39;*&#39;, expr)), scope)
        avg = self.calculate_avg(AggFunction(&#34;AVG&#34;, quant, expr), scope)
        avg_squared = ArithmeticExpression(avg, &#39;*&#39;, avg)

        new_exp = ArithmeticExpression(avg_of_square, &#34;-&#34;, avg_squared)
        return new_exp

    &#34;&#34;&#34;
        Takes an expression for a noisy mean and rewrites
        to a noisy sum and a noisy count
    &#34;&#34;&#34;
    def calculate_stddev(self, exp, scope):
        expr = AggFunction(&#39;STD&#39;, exp.quantifier, exp.expression)
        var_expr = self.calculate_variance(expr, scope)

        new_exp = MathFunction(&#34;SQRT&#34;, var_expr)
        return new_exp

    &#34;&#34;&#34;
        Push a sum or count expression to child scope
        and convert to a sum
    &#34;&#34;&#34;
    def push_sum_or_count(self, exp, scope):
        new_name = scope.push_name(AggFunction(exp.name, exp.quantifier, exp.expression))

        new_exp = AggFunction(&#34;SUM&#34;, None, Column(new_name))
        return new_exp

    &#34;&#34;&#34;
        rewrite AVG, VAR, etc. and push all sum or count
        to child scope, preserving all other portions of
        expression
    &#34;&#34;&#34;
    def rewrite_outer_named_expression(self, ne, scope):
        name = ne.name
        exp = ne.expression
        if type(exp) is not AggFunction:
            outer_col_exps = exp.find_nodes(Column, AggFunction)
        else:
            outer_col_exps = []
        if type(exp) is Column:
            outer_col_exps += [exp]
        for outer_col_exp in outer_col_exps:
            new_name = scope.push_name(Column(outer_col_exp.name))
            outer_col_exp.name = new_name
        agg_exps = exp.find_nodes(AggFunction)
        if type(exp) is AggFunction:
            agg_exps = agg_exps + [exp]
        for agg_exp in agg_exps:
            child_agg_exps = agg_exp.find_nodes(AggFunction)
            if len(child_agg_exps) &gt; 0:
                raise ValueError(&#34;Cannot have nested aggregate functions: &#34; + str(agg_exp))
            agg_func = agg_exp.name
            if agg_func in [&#34;SUM&#34;, &#34;COUNT&#34;]:
                new_exp = self.push_sum_or_count(agg_exp, scope)
            elif agg_func == &#34;AVG&#34;:
                new_exp = self.calculate_avg(agg_exp, scope)
            elif agg_func in [&#34;VAR&#34;,&#34;VARIANCE&#34;]:
                new_exp = self.calculate_variance(agg_exp, scope)
            elif agg_func in [&#34;STD&#34;,&#34;STDDEV&#34;]:
                new_exp = self.calculate_stddev(agg_exp, scope)
            else:
                raise ValueError(&#34;We don&#39;t know how to rewrite aggregate function: &#34; + str(agg_exp))
            agg_exp.name = &#34;&#34;
            agg_exp.quantifier = None
            agg_exp.expression = new_exp
        return NamedExpression(name, exp)


    def query(self, query):
        query = QueryParser(self.metadata).query(str(query))
        Validate().validateQuery(query, self.metadata)

        child_scope = Scope()
        # we make sure aggregates are in select scope for subqueries
        if query.agg is not None:
            for ge in query.agg.groupingExpressions:
                child_scope.push_name(ge.expression)

        select = Seq([self.rewrite_outer_named_expression(ne, child_scope) for ne in query.select.namedExpressions])
        select = Select(None, select)

        subquery = Query(child_scope.select(), query.source, query.where, query.agg, query.having, None, None)
        subquery = self.exact_aggregates(subquery)
        subquery = [AliasedRelation(subquery, &#34;exact_aggregates&#34;)]

        q = Query(select, From(subquery), None, query.agg, None, query.order, query.limit)

        return QueryParser(self.metadata).query(str(q))

    def exact_aggregates(self, query):

        key_col = self.key_col(query)

        child_scope = Scope()

        keycount_expr = AggFunction(&#34;COUNT&#34;, &#34;DISTINCT&#34;, Column(key_col))
        child_scope.push_name(keycount_expr.expression)
        keycount = NamedExpression(&#34;keycount&#34;, keycount_expr) # need to either treat this as reserved or pass through to outer

        select = Seq([keycount] + [self.rewrite_outer_named_expression(ne, child_scope) for ne in query.select.namedExpressions])
        select = Select(None, select)

        subquery = Query(child_scope.select(), query.source, query.where, query.agg, query.having, None, None)
        if self.options.reservoir_sample:
            subquery = self.per_key_random(subquery)
            subquery = [AliasedRelation(subquery, &#34;per_key_random&#34;)]

            filtered = Where(BooleanCompare(Column(&#34;per_key_random.row_num&#34;), &#34;&lt;=&#34;, Literal(str(self.options.max_contrib), self.options.max_contrib)))
            return Query(select, From(subquery), filtered, query.agg, None, None, None)
        else:
            subquery = self.per_key_clamped(subquery)
            subquery = [AliasedRelation(subquery, &#34;per_key_all&#34;)]
            return Query(select, From(subquery), None, query.agg, None, None, None)

    def per_key_random(self, query):
        key_col = self.key_col(query)

        select = Seq([NamedExpression(None, AllColumns()), NamedExpression(&#34;row_num&#34;, Expression(&#34;ROW_NUMBER() OVER (PARTITION BY {0} ORDER BY random())&#34;.format(key_col)))])
        select = Select(None, select)

        subquery = self.per_key_clamped(query)
        subquery = [AliasedRelation(subquery, &#34;per_key_clamped&#34;)]

        return Query(select, From(subquery), None, None, None, None, None)


    def per_key_clamped(self, query):

        key_col = self.key_col(query)

        child_scope = Scope()

        keygroup = [GroupingExpression(Column(key_col))] + (query.agg.groupingExpressions.seq if query.agg is not None else [])
        new_agg = Aggregate(Seq(keygroup))

        relations = query.source.relations

        select = Seq([self.clampExpression(ne, relations, child_scope, self.options.clamp_columns) for ne in query.select.namedExpressions])
        select = Select(None, select)
        subquery = Query(child_scope.select(), query.source, query.where, None, None, None, None)

        if self.options.clamp_columns:
            subquery = [AliasedRelation(subquery, &#34;clamped&#34;)]
        else:
            subquery = [AliasedRelation(subquery, &#34;not_clamped&#34;)]

        return Query(select, From(subquery), None, new_agg, None, None, None)


    &#34;&#34;&#34;
        Lookup the expression referenced in each named expression and
        write a clamped select for it, using the schema
    &#34;&#34;&#34;
    def clampExpression(self, ne, relations, scope, do_clamp=True):
        exp = ne.expression
        cols = exp.find_nodes(Column)
        if type(exp) is Column:
            cols += [exp]
        for col in cols:
            colname = col.name
            minval = None
            maxval = None
            sym = col.symbol(relations)
            if do_clamp and sym.valtype in [&#34;float&#34;, &#34;int&#34;] and not sym.unbounded:
                minval = sym.minval
                maxval = sym.maxval
                if minval is None or sym.is_key:
                    cexpr = Column(colname)
                    ce_name = scope.push_name(cexpr, str(colname))
                else:
                    clamped_string = &#34;CASE WHEN {0} &lt; {1} THEN {1} WHEN {0} &gt; {2} THEN {2} ELSE {0} END&#34;.format(str(colname), minval, maxval)
                    cexpr = Expression(clamped_string)
                    ce_name = scope.push_name(cexpr, str(colname))
            else:
                cexpr = Column(colname)
                ce_name = scope.push_name(cexpr, str(colname))
            col.name = ce_name
        return ne

    &#34;&#34;&#34;
        Return the key column, given a from clause
    &#34;&#34;&#34;
    def key_col(self, query):
        rsyms = query.source.relations[0].all_symbols(AllColumns())
        tcsyms = [r for name, r in rsyms if type(r) is TableColumn]
        keys = [str(tc) for tc in tcsyms if tc.is_key]
        if len(keys) &gt; 1:
            raise ValueError(&#34;We only know how to handle tables with one key: &#34; + str(keys))
        elif len(keys) &lt; 1:
            raise ValueError(&#34;No key column available in query relations&#34;)

        kp = keys[0].split(&#34;.&#34;)
        return kp[len(kp) - 1]</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="burdock.sql.private_rewriter.Rewriter.calculate_avg"><code class="name flex">
<span>def <span class="ident">calculate_avg</span></span>(<span>self, exp, scope)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_avg(self, exp, scope):
    expr = exp.expression
    quant = exp.quantifier

    sum_expr = self.push_sum_or_count(AggFunction(&#34;SUM&#34;, quant, expr), scope)
    count_expr = self.push_sum_or_count(AggFunction(&#34;COUNT&#34;, quant, expr), scope)

    new_exp = NestedExpression(ArithmeticExpression(sum_expr, &#34;/&#34;, count_expr))
    return new_exp</code></pre>
</details>
</dd>
<dt id="burdock.sql.private_rewriter.Rewriter.calculate_stddev"><code class="name flex">
<span>def <span class="ident">calculate_stddev</span></span>(<span>self, exp, scope)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_stddev(self, exp, scope):
    expr = AggFunction(&#39;STD&#39;, exp.quantifier, exp.expression)
    var_expr = self.calculate_variance(expr, scope)

    new_exp = MathFunction(&#34;SQRT&#34;, var_expr)
    return new_exp</code></pre>
</details>
</dd>
<dt id="burdock.sql.private_rewriter.Rewriter.calculate_variance"><code class="name flex">
<span>def <span class="ident">calculate_variance</span></span>(<span>self, exp, scope)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def calculate_variance(self, exp, scope):
    expr = exp.expression
    quant = exp.quantifier

    avg_of_square = self.calculate_avg(AggFunction(&#34;AVG&#34;, quant, ArithmeticExpression(expr, &#39;*&#39;, expr)), scope)
    avg = self.calculate_avg(AggFunction(&#34;AVG&#34;, quant, expr), scope)
    avg_squared = ArithmeticExpression(avg, &#39;*&#39;, avg)

    new_exp = ArithmeticExpression(avg_of_square, &#34;-&#34;, avg_squared)
    return new_exp</code></pre>
</details>
</dd>
<dt id="burdock.sql.private_rewriter.Rewriter.clampExpression"><code class="name flex">
<span>def <span class="ident">clampExpression</span></span>(<span>self, ne, relations, scope, do_clamp=True)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clampExpression(self, ne, relations, scope, do_clamp=True):
    exp = ne.expression
    cols = exp.find_nodes(Column)
    if type(exp) is Column:
        cols += [exp]
    for col in cols:
        colname = col.name
        minval = None
        maxval = None
        sym = col.symbol(relations)
        if do_clamp and sym.valtype in [&#34;float&#34;, &#34;int&#34;] and not sym.unbounded:
            minval = sym.minval
            maxval = sym.maxval
            if minval is None or sym.is_key:
                cexpr = Column(colname)
                ce_name = scope.push_name(cexpr, str(colname))
            else:
                clamped_string = &#34;CASE WHEN {0} &lt; {1} THEN {1} WHEN {0} &gt; {2} THEN {2} ELSE {0} END&#34;.format(str(colname), minval, maxval)
                cexpr = Expression(clamped_string)
                ce_name = scope.push_name(cexpr, str(colname))
        else:
            cexpr = Column(colname)
            ce_name = scope.push_name(cexpr, str(colname))
        col.name = ce_name
    return ne</code></pre>
</details>
</dd>
<dt id="burdock.sql.private_rewriter.Rewriter.exact_aggregates"><code class="name flex">
<span>def <span class="ident">exact_aggregates</span></span>(<span>self, query)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exact_aggregates(self, query):

    key_col = self.key_col(query)

    child_scope = Scope()

    keycount_expr = AggFunction(&#34;COUNT&#34;, &#34;DISTINCT&#34;, Column(key_col))
    child_scope.push_name(keycount_expr.expression)
    keycount = NamedExpression(&#34;keycount&#34;, keycount_expr) # need to either treat this as reserved or pass through to outer

    select = Seq([keycount] + [self.rewrite_outer_named_expression(ne, child_scope) for ne in query.select.namedExpressions])
    select = Select(None, select)

    subquery = Query(child_scope.select(), query.source, query.where, query.agg, query.having, None, None)
    if self.options.reservoir_sample:
        subquery = self.per_key_random(subquery)
        subquery = [AliasedRelation(subquery, &#34;per_key_random&#34;)]

        filtered = Where(BooleanCompare(Column(&#34;per_key_random.row_num&#34;), &#34;&lt;=&#34;, Literal(str(self.options.max_contrib), self.options.max_contrib)))
        return Query(select, From(subquery), filtered, query.agg, None, None, None)
    else:
        subquery = self.per_key_clamped(subquery)
        subquery = [AliasedRelation(subquery, &#34;per_key_all&#34;)]
        return Query(select, From(subquery), None, query.agg, None, None, None)</code></pre>
</details>
</dd>
<dt id="burdock.sql.private_rewriter.Rewriter.key_col"><code class="name flex">
<span>def <span class="ident">key_col</span></span>(<span>self, query)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def key_col(self, query):
    rsyms = query.source.relations[0].all_symbols(AllColumns())
    tcsyms = [r for name, r in rsyms if type(r) is TableColumn]
    keys = [str(tc) for tc in tcsyms if tc.is_key]
    if len(keys) &gt; 1:
        raise ValueError(&#34;We only know how to handle tables with one key: &#34; + str(keys))
    elif len(keys) &lt; 1:
        raise ValueError(&#34;No key column available in query relations&#34;)

    kp = keys[0].split(&#34;.&#34;)
    return kp[len(kp) - 1]</code></pre>
</details>
</dd>
<dt id="burdock.sql.private_rewriter.Rewriter.per_key_clamped"><code class="name flex">
<span>def <span class="ident">per_key_clamped</span></span>(<span>self, query)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def per_key_clamped(self, query):

    key_col = self.key_col(query)

    child_scope = Scope()

    keygroup = [GroupingExpression(Column(key_col))] + (query.agg.groupingExpressions.seq if query.agg is not None else [])
    new_agg = Aggregate(Seq(keygroup))

    relations = query.source.relations

    select = Seq([self.clampExpression(ne, relations, child_scope, self.options.clamp_columns) for ne in query.select.namedExpressions])
    select = Select(None, select)
    subquery = Query(child_scope.select(), query.source, query.where, None, None, None, None)

    if self.options.clamp_columns:
        subquery = [AliasedRelation(subquery, &#34;clamped&#34;)]
    else:
        subquery = [AliasedRelation(subquery, &#34;not_clamped&#34;)]

    return Query(select, From(subquery), None, new_agg, None, None, None)</code></pre>
</details>
</dd>
<dt id="burdock.sql.private_rewriter.Rewriter.per_key_random"><code class="name flex">
<span>def <span class="ident">per_key_random</span></span>(<span>self, query)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def per_key_random(self, query):
    key_col = self.key_col(query)

    select = Seq([NamedExpression(None, AllColumns()), NamedExpression(&#34;row_num&#34;, Expression(&#34;ROW_NUMBER() OVER (PARTITION BY {0} ORDER BY random())&#34;.format(key_col)))])
    select = Select(None, select)

    subquery = self.per_key_clamped(query)
    subquery = [AliasedRelation(subquery, &#34;per_key_clamped&#34;)]

    return Query(select, From(subquery), None, None, None, None, None)</code></pre>
</details>
</dd>
<dt id="burdock.sql.private_rewriter.Rewriter.push_sum_or_count"><code class="name flex">
<span>def <span class="ident">push_sum_or_count</span></span>(<span>self, exp, scope)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push_sum_or_count(self, exp, scope):
    new_name = scope.push_name(AggFunction(exp.name, exp.quantifier, exp.expression))

    new_exp = AggFunction(&#34;SUM&#34;, None, Column(new_name))
    return new_exp</code></pre>
</details>
</dd>
<dt id="burdock.sql.private_rewriter.Rewriter.query"><code class="name flex">
<span>def <span class="ident">query</span></span>(<span>self, query)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def query(self, query):
    query = QueryParser(self.metadata).query(str(query))
    Validate().validateQuery(query, self.metadata)

    child_scope = Scope()
    # we make sure aggregates are in select scope for subqueries
    if query.agg is not None:
        for ge in query.agg.groupingExpressions:
            child_scope.push_name(ge.expression)

    select = Seq([self.rewrite_outer_named_expression(ne, child_scope) for ne in query.select.namedExpressions])
    select = Select(None, select)

    subquery = Query(child_scope.select(), query.source, query.where, query.agg, query.having, None, None)
    subquery = self.exact_aggregates(subquery)
    subquery = [AliasedRelation(subquery, &#34;exact_aggregates&#34;)]

    q = Query(select, From(subquery), None, query.agg, None, query.order, query.limit)

    return QueryParser(self.metadata).query(str(q))</code></pre>
</details>
</dd>
<dt id="burdock.sql.private_rewriter.Rewriter.rewrite_outer_named_expression"><code class="name flex">
<span>def <span class="ident">rewrite_outer_named_expression</span></span>(<span>self, ne, scope)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rewrite_outer_named_expression(self, ne, scope):
    name = ne.name
    exp = ne.expression
    if type(exp) is not AggFunction:
        outer_col_exps = exp.find_nodes(Column, AggFunction)
    else:
        outer_col_exps = []
    if type(exp) is Column:
        outer_col_exps += [exp]
    for outer_col_exp in outer_col_exps:
        new_name = scope.push_name(Column(outer_col_exp.name))
        outer_col_exp.name = new_name
    agg_exps = exp.find_nodes(AggFunction)
    if type(exp) is AggFunction:
        agg_exps = agg_exps + [exp]
    for agg_exp in agg_exps:
        child_agg_exps = agg_exp.find_nodes(AggFunction)
        if len(child_agg_exps) &gt; 0:
            raise ValueError(&#34;Cannot have nested aggregate functions: &#34; + str(agg_exp))
        agg_func = agg_exp.name
        if agg_func in [&#34;SUM&#34;, &#34;COUNT&#34;]:
            new_exp = self.push_sum_or_count(agg_exp, scope)
        elif agg_func == &#34;AVG&#34;:
            new_exp = self.calculate_avg(agg_exp, scope)
        elif agg_func in [&#34;VAR&#34;,&#34;VARIANCE&#34;]:
            new_exp = self.calculate_variance(agg_exp, scope)
        elif agg_func in [&#34;STD&#34;,&#34;STDDEV&#34;]:
            new_exp = self.calculate_stddev(agg_exp, scope)
        else:
            raise ValueError(&#34;We don&#39;t know how to rewrite aggregate function: &#34; + str(agg_exp))
        agg_exp.name = &#34;&#34;
        agg_exp.quantifier = None
        agg_exp.expression = new_exp
    return NamedExpression(name, exp)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="burdock.sql.private_rewriter.RewriterOptions"><code class="flex name class">
<span>class <span class="ident">RewriterOptions</span></span>
<span>(</span><span>row_privacy=False, reservoir_sample=True, clamp_columns=True, max_contrib=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Options that modify rewriter behavior</p>
<p>Initialize options before running the rewriter</p>
<p>:param row_privacy: boolean, True if each row is a separate individual
:param reservoir_sample: boolean, set to False if the data collection will never have more than max_contrib record per individual
:param clamp_columns: boolean, set to False to allow values that exceed lower and higher limit specified in metadata.
May impact privacy
:param max_contrib: int, set to maximum number of individuals that can appear in any query result.
Affects sensitivity</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class RewriterOptions:
    &#34;&#34;&#34;Options that modify rewriter behavior&#34;&#34;&#34;
    def __init__(self, row_privacy=False, reservoir_sample=True, clamp_columns=True, max_contrib=1):
        &#34;&#34;&#34;Initialize options before running the rewriter

        :param row_privacy: boolean, True if each row is a separate individual
        :param reservoir_sample: boolean, set to False if the data collection will never have more than max_contrib record per individual
        :param clamp_columns: boolean, set to False to allow values that exceed lower and higher limit specified in metadata.  May impact privacy
        :param max_contrib: int, set to maximum number of individuals that can appear in any query result.  Affects sensitivity
        &#34;&#34;&#34;
        self.row_privacy = row_privacy
        self.reservoir_sample = reservoir_sample
        self.clamp_columns = clamp_columns
        self.max_contrib = max_contrib</code></pre>
</details>
</dd>
<dt id="burdock.sql.private_rewriter.Scope"><code class="flex name class">
<span>class <span class="ident">Scope</span></span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Scope:
    def __init__(self):
        self.expressions = {}

    def select(self, quantifier=None):
        return Select(quantifier, [NamedExpression(name, self.expressions[name]) for name in self.expressions.keys()])

    &#34;&#34;&#34;
        Returns a named expression from an expression, using
        an existing name if already provided in this scope,
        or generating a new name and adding to the names
        dictionary if the expression does not exist in scope.
    &#34;&#34;&#34;
    def push_name(self, expression, proposed=None):
        # see if the proposed name is taken
        if proposed is not None:
            if proposed in self.expressions:
                if self.expressions[proposed] == expression:
                    return proposed
                else:
                    pass
            else:
                self.expressions[proposed] = expression
                return proposed

        # see if the expression has been used 
        names = [name for name in self.expressions.keys() if self.expressions[name] == expression]
        if len(names) &gt; 0:
            return names[0]

        # see if the expression has been used under the symbol name
        proposed = expression.symbol_name()
        if proposed in self.expressions:
            if self.expressions[proposed] == expression:
                return proposed
            else:
                pass
        else:
            self.expressions[proposed] = expression
            return proposed

        # Expression hasn&#39;t been used, but name is taken. Generate random.
        while not proposed in self.expressions:
            proposed = &#39;&#39;.join(random.choice(string.ascii_letters) for i in range(7))

        self.expressions[proposed] = expression
        return proposed</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="burdock.sql.private_rewriter.Scope.push_name"><code class="name flex">
<span>def <span class="ident">push_name</span></span>(<span>self, expression, proposed=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def push_name(self, expression, proposed=None):
    # see if the proposed name is taken
    if proposed is not None:
        if proposed in self.expressions:
            if self.expressions[proposed] == expression:
                return proposed
            else:
                pass
        else:
            self.expressions[proposed] = expression
            return proposed

    # see if the expression has been used 
    names = [name for name in self.expressions.keys() if self.expressions[name] == expression]
    if len(names) &gt; 0:
        return names[0]

    # see if the expression has been used under the symbol name
    proposed = expression.symbol_name()
    if proposed in self.expressions:
        if self.expressions[proposed] == expression:
            return proposed
        else:
            pass
    else:
        self.expressions[proposed] = expression
        return proposed

    # Expression hasn&#39;t been used, but name is taken. Generate random.
    while not proposed in self.expressions:
        proposed = &#39;&#39;.join(random.choice(string.ascii_letters) for i in range(7))

    self.expressions[proposed] = expression
    return proposed</code></pre>
</details>
</dd>
<dt id="burdock.sql.private_rewriter.Scope.select"><code class="name flex">
<span>def <span class="ident">select</span></span>(<span>self, quantifier=None)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select(self, quantifier=None):
    return Select(quantifier, [NamedExpression(name, self.expressions[name]) for name in self.expressions.keys()])</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="burdock.sql" href="index.html">burdock.sql</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="burdock.sql.private_rewriter.Rewriter" href="#burdock.sql.private_rewriter.Rewriter">Rewriter</a></code></h4>
<ul class="">
<li><code><a title="burdock.sql.private_rewriter.Rewriter.calculate_avg" href="#burdock.sql.private_rewriter.Rewriter.calculate_avg">calculate_avg</a></code></li>
<li><code><a title="burdock.sql.private_rewriter.Rewriter.calculate_stddev" href="#burdock.sql.private_rewriter.Rewriter.calculate_stddev">calculate_stddev</a></code></li>
<li><code><a title="burdock.sql.private_rewriter.Rewriter.calculate_variance" href="#burdock.sql.private_rewriter.Rewriter.calculate_variance">calculate_variance</a></code></li>
<li><code><a title="burdock.sql.private_rewriter.Rewriter.clampExpression" href="#burdock.sql.private_rewriter.Rewriter.clampExpression">clampExpression</a></code></li>
<li><code><a title="burdock.sql.private_rewriter.Rewriter.exact_aggregates" href="#burdock.sql.private_rewriter.Rewriter.exact_aggregates">exact_aggregates</a></code></li>
<li><code><a title="burdock.sql.private_rewriter.Rewriter.key_col" href="#burdock.sql.private_rewriter.Rewriter.key_col">key_col</a></code></li>
<li><code><a title="burdock.sql.private_rewriter.Rewriter.per_key_clamped" href="#burdock.sql.private_rewriter.Rewriter.per_key_clamped">per_key_clamped</a></code></li>
<li><code><a title="burdock.sql.private_rewriter.Rewriter.per_key_random" href="#burdock.sql.private_rewriter.Rewriter.per_key_random">per_key_random</a></code></li>
<li><code><a title="burdock.sql.private_rewriter.Rewriter.push_sum_or_count" href="#burdock.sql.private_rewriter.Rewriter.push_sum_or_count">push_sum_or_count</a></code></li>
<li><code><a title="burdock.sql.private_rewriter.Rewriter.query" href="#burdock.sql.private_rewriter.Rewriter.query">query</a></code></li>
<li><code><a title="burdock.sql.private_rewriter.Rewriter.rewrite_outer_named_expression" href="#burdock.sql.private_rewriter.Rewriter.rewrite_outer_named_expression">rewrite_outer_named_expression</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="burdock.sql.private_rewriter.RewriterOptions" href="#burdock.sql.private_rewriter.RewriterOptions">RewriterOptions</a></code></h4>
</li>
<li>
<h4><code><a title="burdock.sql.private_rewriter.Scope" href="#burdock.sql.private_rewriter.Scope">Scope</a></code></h4>
<ul class="">
<li><code><a title="burdock.sql.private_rewriter.Scope.push_name" href="#burdock.sql.private_rewriter.Scope.push_name">push_name</a></code></li>
<li><code><a title="burdock.sql.private_rewriter.Scope.select" href="#burdock.sql.private_rewriter.Scope.select">select</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.5</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>